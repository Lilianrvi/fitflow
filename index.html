<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitFlow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/quagga/dist/quagga.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let map;
let autocompleteService;

// Cette fonction initialise UNIQUEMENT le service de recherche de villes
window.initializeGooglePlacesService = function() {
    if (!autocompleteService && window.google && window.google.maps) {
        autocompleteService = new google.maps.places.AutocompleteService();
        console.log("Google Places Autocomplete Service est prêt.");
    }
};

// Cette fonction initialise UNIQUEMENT la carte visuelle (pour la modale)
function initializeGoogleMap(mapDiv, center, zoom) {
    if (!mapDiv) return null; // Sécurité
    return new google.maps.Map(mapDiv, {
        center: center,
        zoom: zoom,
        disableDefaultUI: true
    });
}
    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCteAtkb2XuW2S6DneusPwnkNxOd3QaAH4&libraries=places&callback=initializeGooglePlacesService"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
        :root {
    /* Couleurs de base du thème sombre */
    --background-start-rgb: 29, 31, 43;
    --background-end-rgb: 50, 43, 83;
    --glass-bg-rgb: 255, 255, 255;

    /* Couleurs spécifiques au thème Workout (violet) */
    --theme-primary-workout: #A78BFA;
    --theme-dark-workout: #7C3AED;
    --theme-light-workout: #C4B5FD;
    --theme-gradient-workout: linear-gradient(160deg, #3B315F 0%, #23253A 100%);
    --theme-shadow-workout: rgba(124, 58, 237, 0.2);

    /* Couleurs spécifiques au thème Nutrition (vert) */
    --theme-primary-nutrition: #34D399;
    --theme-dark-nutrition: #059669;
    --theme-light-nutrition: #6EE7B7;
    --theme-gradient-nutrition: linear-gradient(160deg, #1A3E39 0%, #152A26 100%);
    --theme-shadow-nutrition: rgba(5, 150, 105, 0.2);

    /* Variables dynamiques par défaut (thème workout) */
    --theme-primary: var(--theme-primary-workout);
    --theme-dark: var(--theme-dark-workout);
    --theme-light: var(--theme-light-workout);
    --theme-gradient: var(--theme-gradient-workout);
    --theme-shadow: var(--theme-shadow-workout);
    
    --meal-color: #34D399;
    --pr-gold-color: #fde047;
    --pr-gold-color-dark: #facc15;
}

#background-glow-spot {
    position: absolute;
    top: 0;
    right: 0;
    width: 550px; /* Augmenté pour une plus grande zone */
    height: 550px; /* Augmenté pour une plus grande zone */
    background: radial-gradient(circle, var(--theme-shadow) 100%, transparent 60%); /* Dégradé plus large */
    opacity: 0.8; /* Opacité augmentée pour plus d'intensité */
    filter: blur(70px); /* Flou plus important pour un effet plus diffus */
    transform: translate(25%, -25%); /* Moins décalé pour être plus visible */
    z-index: 0; 
    pointer-events: none;
    transition: all 0.4s ease-in-out; /* Transition sur 'all' pour la couleur et la transformation */
}

/* Application du thème par défaut */
.app-container.workout-theme {
    --theme-primary: var(--theme-primary-workout);
    --theme-dark: var(--theme-dark-workout);
    --theme-light: var(--theme-light-workout);
    --theme-gradient: var(--theme-gradient-workout);
    --theme-shadow: var(--theme-shadow-workout);
}

/* Application du thème nutrition */
.app-container.nutrition-theme {
    --theme-primary: var(--theme-primary-nutrition);
    --theme-dark: var(--theme-dark-nutrition);
    --theme-light: var(--theme-light-nutrition);
    --theme-gradient: var(--theme-gradient-nutrition);
    --theme-shadow: var(--theme-shadow-nutrition);
}
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(160deg, rgb(var(--background-start-rgb)) 0%, rgb(var(--background-end-rgb)) 100%);
            color: #E5E7EB;
        }
        .app-container {
    background-image: var(--theme-gradient);
    position: relative;
    transition: background-image 0.4s ease-in-out;
}
        .glass-card {
            background: rgba(var(--glass-bg-rgb), 0.05);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(var(--glass-bg-rgb), 0.1);
            transition: all 0.2s ease-in-out;
            position: relative; 
        }
        .page { display: none; }
        .page.active { display: block; animation: fadeIn 0.4s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        .animate-fadeOut { animation: fadeOut 0.3s ease-out forwards; }


        .bottom-nav-item i {
    transition: transform 0.3s cubic-bezier(0.2, 1, 0.2, 1), color 0.3s ease;
    transform: translateY(0); /* On définit sa position de départ */
}

/* 2. On définit l'état final de l'icône active */
.bottom-nav-item.active i {
    color: var(--theme-primary);
    transform: translateY(-4px); /* L'icône monte légèrement pour un effet "pop" */
}

        .max-level-animated-badge {
    /* On crée un dégradé qui commence et se termine de la même façon pour une boucle parfaite */
    background: linear-gradient(90deg, #FDE047, #FFFFFF, #C4B5FD, #FFFFFF, #FDE047);
    background-size: 400% 400%; /* On ajuste la taille pour l'animation existante */
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: scroll-infiniment 10s linear infinite;
    filter: drop-shadow(0 0 8px #FDE047);
}
        
        .input-glass {
            background: rgba(0,0,0, 0.2);
            border: 1px solid rgba(255,255,255, 0.1);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            width: 100%;
            color: white;
            font-weight: 500;
            transition: border-color 0.2s;
        }
        .input-glass:focus {
    outline: none;
    border-color: var(--theme-primary);
}
        .btn-primary {
    background-color: var(--theme-primary);
    color: #111827;
    font-weight: 700;
    padding: 0.8rem 1.5rem;
    border-radius: 0.75rem;
    transition: transform 0.2s ease, background-color 0.2s ease;
}
        .btn-primary:hover {
            transform: scale(1.05);
        }
        .btn-primary:disabled {
            background-color: #5f5a6e;
            cursor: not-allowed;
        }
        .modal-bg { background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px); }
        
        .draggable { cursor: grab; }
        .draggable.dragging { 
    opacity: 0.5;
    background: rgba(var(--theme-primary), 0.1);
    border: 1px dashed var(--theme-primary);
}

.input-stepper-wrapper {
            position: relative;
        }
        .input-stepper-arrows {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            height: calc(100% - 8px);
            justify-content: space-around;
        }
        .input-stepper-arrows button {
            color: #9CA3AF;
            line-height: 1;
            padding: 0 4px;
        }
        .input-stepper-arrows button:hover {
            color: white;
        }

.drag-over {
    /* Style pour le placeholder où l'élément sera déposé */
    border-top: 2px solid var(--accent-color) !important;
}

/* --- STYLES POUR LE GUIDE INTERACTIF --- */
        .guide-accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 1rem;
            font-size: 1.125rem; /* text-lg */
            font-weight: 700; /* font-bold */
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.75rem; /* rounded-xl */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .guide-accordion-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .guide-accordion-header .icon-rotate {
            transition: transform 0.3s ease-out;
        }
        .guide-accordion-header.active .icon-rotate {
            transform: rotate(180deg);
        }
        .guide-accordion-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1rem;
        }
        .guide-accordion-panel p {
            margin-bottom: 0.75rem;
            line-height: 1.6;
            color: #D1D5DB; /* text-gray-300 */
        }
        .guide-accordion-panel strong {
    color: var(--theme-light);
}

        .calendar-day.drag-over { background-color: rgba(var(--theme-primary), 0.2); border: 1px solid var(--theme-primary); }
        .calendar-day.past-day { color: #6B7280; cursor: not-allowed; }
        .calendar-day.past-day .event-dot { background-color: #6B7280; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .truncate-ellipsis { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .truncate-2-lines { overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; word-break: break-all; }

        #scanner-container {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.95);
            z-index: 50;
        }
        #reader {
            width: 90%;
            max-width: 500px;
            margin: auto;
            border-radius: 1rem;
            overflow: hidden;
        }
        .toggle-switch {
            background-color: rgba(0,0,0,0.2);
            border-radius: 9999px;
            padding: 4px;
            display: flex;
            position: relative;
        }
        .toggle-switch .slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            width: calc(50% - 4px);
            background-color: var(--accent-color);
            border-radius: 9999px;
            transition: transform 0.2s ease-in-out;
        }
        .toggle-switch button {
            width: 50%;
            padding: 8px;
            background-color: transparent;
            border: none;
            color: white;
            font-weight: 600;
            z-index: 1;
            cursor: pointer;
        }
        
        .rank-modal-content {
            background-color: #1F2130;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeInModal 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            position: relative;
            overflow: hidden;
        }

        .glow {
            filter: drop-shadow(0 0 8px currentColor);
        }
        .animated-glow {
             animation: glow-pulse 2s ease-in-out infinite;
        }
        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 8px currentColor); }
            50% { filter: drop-shadow(0 0 16px currentColor); }
        }

        /* Animation pour la bordure enflammée */
        @keyframes flame-border-animation {
            0% { border-image-source: linear-gradient(0deg, #fBBF24, #f87171, #f59e0b); }
            25% { border-image-source: linear-gradient(90deg, #fBBF24, #f87171, #f59e0b); }
            50% { border-image-source: linear-gradient(180deg, #fBBF24, #f87171, #f59e0b); }
            75% { border-image-source: linear-gradient(270deg, #fBBF24, #f87171, #f59e0b); }
            100% { border-image-source: linear-gradient(360deg, #fBBF24, #f87171, #f59e0b); }
        }
        
        /* Animation pour la bordure cosmique */
        @keyframes cosmic-border-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes fadeInModal {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes fiery-pulse {
            0% { box-shadow: 0 0 12px #fde047, 0 0 6px #f87171; }
            50% { box-shadow: 0 0 18px #f87171, 0 0 9px #fde047; }
            100% { box-shadow: 0 0 12px #fde047, 0 0 6px #f87171; }
        }

        .rank-badge-container {
            position: relative;
            z-index: 1;
        }

        #page-container {
    z-index: 1;
}

        .rank-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(var(--accent-color), 0.1), transparent 70%);
            z-index: 0;
            pointer-events: none;
        }
        
        .progress-bar-tiers {
            display: flex;
            background-color: rgba(0,0,0,0.2);
            border-radius: 9999px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .progress-bar-tiers > div {
            flex: 1;
            height: 0.5rem;
            position: relative;
        }
        .progress-bar-tiers > div:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: rgba(0,0,0,0.3);
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--color);
            opacity: 1;
            animation: fall 5s linear forwards;
        }
        @keyframes fall {
            to {
                transform: translateY(calc(100vh + 30px)) rotateZ(720deg);
                opacity: 0;
            }
        }
        
        /* Custom Dropdown */
        .custom-select-container {
            position: relative;
        }

        #info-card:has(.custom-select-options.active) {
            z-index: 60; /* Élève TOUTE la carte au-dessus des autres quand un menu est ouvert */
        }

        .custom-select-button {
            background-color: rgba(0,0,0, 0.2); /* Fond identique aux inputs */
            border: 1px solid rgba(255,255,255, 0.1);
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .custom-select-button:hover, .custom-select-button.active {
    border-color: var(--theme-primary);
}
        .custom-select-options, .shop-sort-options {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: var(--theme-gradient);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 1rem;
            z-index: 50; /* Valeur plus élevée pour garantir la superposition */
            overflow: hidden;
            animation: fadeIn 0.2s ease;
        }
        .custom-select-options.active {
            display: block;
        }
        .custom-select-option {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .custom-select-option:hover {
    background-color: var(--theme-primary);
    color: #111827;
}

        @keyframes shake {
    0% { transform: translateX(0); }
    15% { transform: translateX(-5px); }
    30% { transform: translateX(5px); }
    45% { transform: translateX(-5px); }
    60% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
    100% { transform: translateX(0); }
}
.animate-shake {
    animation: shake 0.5s ease-in-out;
}

.standard-error-message {
    font-size: 0.8rem;
    color: #EF4444; /* red-500 */
    text-align: center;
    margin-top: 0.75rem; /* Un peu d'espace au-dessus */
    min-height: 1.5rem; /* Hauteur minimale pour éviter les sauts de mise en page */
}

/* 2. Style SPÉCIFIQUE pour le message d'erreur du poids sur le profil */
.profile-weight-error-message {
    position: absolute;
    bottom: 0.15rem; /* Positionné en bas de la carte parente */
    left: 1.25rem;
    right: 1.25rem;
    font-size: 0.75rem;
    color: #EF4444;
    text-align: center;
    opacity: 0;
    transform: translateY(5px);
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    pointer-events: none;
}
.profile-weight-error-message:not(:empty) {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

.input-error-message:not(:empty) {
    /* Fait apparaître le message */
    opacity: 1;
    transform: translateY(0); /* Le remet à sa position finale */
    pointer-events: auto;
}

.shop-content-scroll-area .glass-card {
    position: relative; /* Nécessaire pour le positionnement de l'effet */
    overflow: hidden;   /* Le reflet ne doit pas déborder de la carte */
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

@keyframes success-fx {
  /* L'animation principale gère la pulsation verte et le léger soulèvement */
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); /* Vert de votre thème */
  }
  50% {
    transform: scale(1.03);
    box-shadow: 0 0 15px 4px rgba(52, 211, 153, 0.4); /* Pulsation verte subtile */
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(52, 211, 153, 0);
  }
}

@keyframes shimmer-fx {
  /* Une seconde animation, uniquement pour le reflet, qui se jouera en même temps */
  100% {
    transform: translateX(150%);
  }
}

/* --- NOUVEAUX STYLES POUR LES SUCCÈS DÉTAILLÉS --- */
/* --- Système de notification --- */
@keyframes star-twinkle {
    0%, 100% { transform: scale(0.8); opacity: 0.7; }
    50% { transform: scale(1.2); opacity: 1; }
}

/* --- STYLES ENTIÈREMENT REVUS POUR LES SUCCÈS (V2) --- */

/* --- Système de notification --- */
/* --- STYLES ENTIÈREMENT REVUS POUR LES SUCCÈS (V3) --- */

/* --- Page Principale des Succès --- */
/* --- STYLES ENTIÈREMENT REVUS POUR LES SUCCÈS (V4) --- */

/* --- Page Principale des Succès --- */
.achievement-card {
    position: relative;
    width: 100%;
    display: flex;
    align-items: center;
    gap: 1rem;
    text-align: left;
    background: rgba(var(--glass-bg-rgb), 0.05);
    padding: 1rem;
    border-radius: 0.75rem;
    border: 1px solid rgba(var(--glass-bg-rgb), 0.1);
    transition: all 0.2s ease-in-out;
}
.achievement-card:hover {
    background-color: rgba(var(--glass-bg-rgb), 0.1);
}
.achievement-icon-wrapper {
    width: 3.5rem; /* 56px */
    height: 3.5rem;
    background-color: rgba(0,0,0,0.2);
    border-radius: 0.5rem;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
.lock-overlay {
    position: absolute;
    inset: 0;
    background-color: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #D1D5DB; /* gray-300 */
    font-size: 1.25rem;
}
.has-rewards {
    border-color: rgba(253, 224, 71, 0.7);
    box-shadow: 0 0 15px rgba(253, 224, 71, 0.2);
}

/* --- Système de notification --- */
.notification-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background-color: #EF4444; /* red-500 */
    color: white;
    min-width: 22px;
    height: 22px;
    padding: 0 6px;
    border-radius: 9999px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-weight: bold;
}

.streak-flame-gradient {
            background: linear-gradient(180deg, #FDE047, #F59E0B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
            display: inline-block;
            filter: drop-shadow(0 0 8px #F97316);
            font-size: 1.7rem; /* Taille intermédiaire */
            vertical-align: -0.15em; /* Alignement par le bas */
        }

/* --- Styles de la Modale de Détail (FINALE V3) --- */
.tier-list-container { 
    list-style: none; 
    padding: 0; 
}
.tier-item {
    display: flex;
    position: relative;
    gap: 1.5rem;
    padding: 0;
}
.tier-timeline {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 2rem;
}
.tier-icon {
    width: 2rem;
    height: 2rem;
    border-radius: 9999px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    z-index: 1;
    font-size: 0.875rem;
    transition: all 0.3s ease;
    background-color: #23253A;
}
.tier-connector {
    flex-grow: 1;
    width: 2px;
    background-color: #374151;
}
.tier-item:last-child .tier-connector {
    flex-grow: 0;
    height: 3.5rem;
}
.tier-details {
    flex-grow: 1;
    padding: 1.5rem 0;
    border-bottom: 1px solid rgba(255,255,255,0.08);
}

/* --- Styles des Récompenses (TEXTE UNIQUEMENT) --- */
.tier-reward {
    font-size: 0.875rem; /* 14px */
    font-weight: 500;
    transition: all 0.3s ease;
}
.tier-reward.locked {
    color: #6B7280; /* Gris */
}
.tier-reward.claimable {
    color: #FBBF24; /* Jaune */
    font-weight: 600;
}
.tier-reward.claimed {
    color: #6B7280; /* Gris */
    text-decoration: line-through;
}

/* --- STYLES DES BOUTONS (TAILLE UNIFORME) --- */
.reward-btn {
    padding: 0.4rem 0; /* Ajustement du padding */
    width: 115px; /* Largeur fixe pour tous les boutons */
    font-size: 0.8rem;
    border-radius: 6px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.claim-btn {
    background-color: var(--pr-gold-color); /* Utilise une couleur dorée */
    color: #111827; /* Texte sombre */
}
.claim-btn:hover { opacity: 0.9; }
.claimed-btn { background-color: #16A34A; color: white; cursor: not-allowed; }
.locked-btn { background-color: #374151; color: #6B7280; cursor: not-allowed; }

/* --- États des Paliers --- */
.tier-item.locked { opacity: 0.5; }
.tier-item.locked .tier-icon { background-color: #374151; color: #6B7280; }

.tier-item.current .tier-icon {
    background-color: #FBBF24;
    color: #111827;
}
.tier-item.current .tier-connector {
    background: linear-gradient(#FBBF24, #374151);
}

.tier-item.unlocked .tier-icon { 
    background-color: #FBBF24; 
    color: #111827; 
}
.tier-item.unlocked .tier-connector { 
    background-color: #FBBF24; 
}
.tier-item.unlocked:has(+ .tier-item.current) .tier-connector {
    background: linear-gradient(#FBBF24, #374151);
}

/* --- ANIMATION DU SABLIER --- */
@keyframes sand-flow-top {
    0%, 10% { transform: scaleY(1); }
    80%, 100% { transform: scaleY(0); }
}
@keyframes sand-flow-bottom {
    0%, 10% { transform: scaleY(0); }
    80%, 100% { transform: scaleY(1); }
}
@keyframes hourglass-flip {
    0%, 90% { transform: rotate(0deg); }
    100% { transform: rotate(180deg); }
}
.sablier {
    width: 14px;
    height: 22px;
	--sand-color: #483611;
    --glass-color: rgba(0, 0, 0, 0.2);
    --frame-color: #483611;
	--polygonH: polygon(0% 0%,100% 0%,100% 5.55%,95% 5.55%,95% 28%,60% 46%,60% 54%,95% 72%,95% 94.45%,100% 94.45%,100% 100%,0% 100%,0% 94.45%,5% 94.45%,5% 72%,40% 54%,40% 46%,5% 28%,5% 5.55%,0% 5.55%);
	animation-name: flip;
	animation-duration: 4s;
	animation-iteration-count: infinite;
	animation-timing-function: ease-in-out;
	background-image: linear-gradient(var(--frame-color) 1px, var(--glass-color) 1px 21px, var(--frame-color) 21px);
	clip-path: var(--polygonH);
	position: relative;
	z-index: 0;
}
.sablier:before {
	--polygonB1: polygon(0% 0%,100% 0%,100% 24%,50% 47%,50% 47%,50% 47%,50% 47%,50% 47%,50% 47%,50% 47%,50% 47%,0% 24%);
	--polygonB2: polygon(0% 4%,100% 4%,100% 24%,55% 45%,55% 100%,55% 100%,55% 100%,45% 100%,45% 100%,45% 100%,45% 45%,0% 24%);
	--polygonB3: polygon(0% 24%,100% 24%,100% 24%,55% 45%,55% 80%,100% 100%,100% 100%,0% 100%,0% 100%,45% 80%,45% 45%,0% 24%);
	--polygonB4: polygon(45% 45%,55% 45%,55% 45%,55% 45%,55% 58%,100% 76%,100% 100%,0% 100%,0% 76%,45% 58%,45% 45%,45% 45%);
	--polygonB5: polygon(50% 53%,50% 53%,50% 53%,50% 53%,50% 53%,100% 76%,100% 100%,0% 100%,0% 76%,50% 53%,50% 53%,50% 53%);
	animation-name: fill;
	animation-duration: 4s;
	animation-iteration-count: infinite;
	animation-timing-function: linear;
	content: "";
	display: block;
	position: absolute;
	background-color: var(--sand-color);
	clip-path: var(--polygonB1);
	top: 1px;
	left: 1px;
	width: 12px;
	height: 20px;
	z-index: 1;
}
@keyframes fill {
	from { clip-path: var(--polygonB1); }
	10% { clip-path: var(--polygonB2); }
	45% { clip-path: var(--polygonB3); }
	80% { clip-path: var(--polygonB4); }
	85%, to { clip-path: var(--polygonB5); }
}
@keyframes flip {
	from, 90% { transform: rotate(0); }
	to { transform: rotate(180deg); }
}

/* --- CODE FINAL ET DÉFINITIF POUR L'ANIMATION D'ÉCHEC COMBINÉE --- */

/* Animation 1 : La distorsion "glitch" (inchangée) */
@keyframes subtle-fail-fx {
  /* Le texte devient rouge immédiatement et le reste pendant le rebond */
  0%, 75% {
    color: #EF4444;
  }
  
  /* Le mouvement de rebond, adouci et moins ample */
  0% { transform: translateX(0); }
  25% { transform: translateX(-4px); } /* Mouvement réduit */
  50% { transform: translateX(4px); }  /* Mouvement réduit */
  75% { transform: translateX(-2px); }
  
  /* L'animation se termine en revenant à l'état initial (texte et position) */
  100% {
    transform: translateX(0);
    color: #111827; /* Couleur de texte de base */
  }
}

.animate-purchase-fail {
  /* On applique notre animation finale avec une durée rapide */
  animation: subtle-fail-fx 0.4s ease-out;
}

/* 3. NOUVELLE animation pour le succès d'achat (reflet élégant) */
.animate-purchase-success::after {
    /* Crée le reflet et lui applique sa propre animation */
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        100deg,
        rgba(255, 255, 255, 0) 20%,
        rgba(255, 255, 255, 0.4) 50%,
        rgba(255, 255, 255, 0) 80%
    );
    transform: translateX(-150%);
    animation: shimmer-fx 0.85s cubic-bezier(0.25, 1, 0.5, 1) forwards;
    pointer-events: none;
}

.quests-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
}
/* Nouveau design des cartes (V2) */
.quest-card-v2 {
    background: rgba(var(--glass-bg-rgb), 0.05);
    border: 1px solid rgba(var(--glass-bg-rgb), 0.1);
    border-radius: 1rem;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    text-align: center;
    transition: all 0.3s ease;
    height: auto; 
    position: relative;
}

/* Style pour la progression circulaire */
.quest-progress-circle-wrapper {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none; /* Correction: retire la bordure pour ne pas avoir de double contour */
    transition: all 0.5s ease;
    position: relative;
    /* Correction: la barre de progression est le dégradé du background */
    padding: 3px;
}

.quest-progress-inner-circle {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: rgb(29, 31, 43); /* Couleur de fond de la carte */
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Style pour le cercle de progression une fois la quête terminée */
.quest-card-v2.completed .quest-progress-circle-wrapper {
    background: linear-gradient(135deg, #fde047, #facc15);
    border-color: #fde047;
}
.quest-card-v2.completed .quest-progress-inner-circle {
    background-color: #111827;
}

/* Style de l'icône dans le cercle */
.quest-progress-circle-wrapper .quest-icon {
    font-size: 1.75rem;
    color: var(--theme-primary);
}

/* Style de l'icône quand la quête est terminée */
.quest-card-v2.completed .quest-icon {
    color: white; 
}

/* --- NOUVEAU : Styles pour les boutons et conteneurs de statut --- */
.quest-status-container {
    width: 120px;
    margin: 0 auto;
}

.quest-status-btn {
    padding: 0.4rem 0.5rem; 
    width: 100%;
    font-size: 0.8rem;
    border-radius: 6px; 
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.quest-status-btn.quest-claim-btn {
    background-color: var(--pr-gold-color);
    color: #111827;
}

.quest-status-btn.claimed-btn {
    background-color: #16A34A;
    color: white;
    cursor: not-allowed;
}

.quest-status-btn.locked-btn {
    background-color: #374151;
    color: #6B7280;
    cursor: not-allowed;
}
/* --- FIN DES NOUVEAUX STYLES --- */

/* L'animation de lueur respecte le thème */
@keyframes claim-glow-v2 {
    0%, 100% {
        border-color: var(--theme-light);
        box-shadow: 0 0 15px var(--theme-shadow);
    }
    50% {
        border-color: var(--theme-primary);
        box-shadow: 0 0 25px var(--theme-shadow);
    }
}
.quest-card-v2.claimable {
    animation: claim-glow-v2 2s infinite ease-in-out;
}

/* Animation de collecte */
@keyframes claim-success-anim {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.5; }
    100% { transform: scale(1); opacity: 0.6; }
}
.quest-card-v2.is-claiming {
    animation: claim-success-anim 0.4s ease-out forwards;
}

@keyframes shimmer-effect {
    to {
        transform: translateX(150%);
    }
}

@keyframes purchase-glow {
    0% { box-shadow: 0 0 0px 0px rgba(52, 211, 153, 0.7); }
    50% { box-shadow: 0 0 10px 3px rgba(52, 211, 153, 0.7); }
    100% { box-shadow: 0 0 0px 0px rgba(52, 211, 153, 0); }
}

@keyframes purchase-success-pulse {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(167, 139, 250, 0); /* --accent-color */
    }
    50% {
        transform: scale(1.03); /* La carte se soulève légèrement */
        box-shadow: 0 0 15px 5px rgba(167, 139, 250, 0.3); /* Une pulsation douce avec la couleur d'accent */
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(167, 139, 250, 0);
    }
}

.animate-purchase-success {
    /* Applique l'animation de pulsation à la carte elle-même */
    animation: success-fx 0.7s ease-out forwards;
}

/* For profile save confirmation (optional, could be simple checkmark fade) */
@keyframes checkmark-fade-in {
    0% { opacity: 0; transform: scale(0.5); }
    100% { opacity: 1; transform: scale(1); }
}
.animate-checkmark {
    animation: checkmark-fade-in 0.3s ease-out forwards;
}

/* Refined toast-notification styles for subtlety */
/* Make sure these overwrite any previous toast styles */
#toast-container {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    width: 90%; /* Largeur définie pour un meilleur alignement */
    pointer-events: none;
    display: flex;
    flex-direction: column; /* Empile les notifications verticalement */
    align-items: center;    /* Les centre horizontalement */
    gap: 8px;               /* Ajoute un espace entre les notifications */
}

.toast-notification {
    padding: 0.6rem 1.2rem; /* Reduced padding */
    border-radius: 9999px; /* Pill shape for "mega subtle" */
    font-weight: 600;
    text-align: center;
    font-size: 0.8rem; /* Smaller font size */
    box-shadow: 0 4px 12px rgba(0,0,0,0.3); /* Soft shadow */
    opacity: 0;
    transform: translateY(-20px); /* Start slightly above and move down */
    transition: all 0.3s cubic-bezier(0.25, 1.02, 0.73, 1); /* Smooth transition */
    visibility: hidden; /* Hide element until 'show' */
    white-space: nowrap; /* Prevent text wrapping */
}

.toast-notification.show {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
}

.shop-content-scroll-area {
    padding-bottom: 100px; /* Adjust this value if needed, needs to be more than nav height */
}

.item-select-btn[data-item-id="${equippedId}"] {
    border-color: var(--theme-primary);
}

/* Style pour l'onglet actif de la boutique */
.shop-tab-btn.active {
    color: var(--theme-primary);
    border-bottom: 2px solid var(--theme-primary);
}

#global-modal-container {
    /* ... d'autres styles ... */
    overflow: hidden; /* <-- CHANGÉ EN HIDDEN */
    z-index: 30;
    pointer-events: none;
}

        /* Styles pour la modale de recadrage d'image */
        #cropper-modal-container {
    background-color: rgba(0,0,0,0.8);
    backdrop-filter: blur(5px);
}
#cropper-modal-content {
    background-color: #1F2130;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}
#cropper-image-container {
    width: 100%;
    height: 40vh;
    background-color: #111827;
}
/* Pour avoir un aperçu circulaire */
.cropper-view-box,
.cropper-face {
    border-radius: 50%;
}

        showcase-container {
            background: rgba(0,0,0, 0.15);
            border-radius: 1.25rem;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .showcase-title-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem; /* Rapproche le crayon du titre */
            margin-bottom: 0.75rem;
        }

        .showcase-item {
    aspect-ratio: 1 / 1;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 0.75rem;
    /* On passe la bordure à 2px d'épaisseur */
    border: 2px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    transition: all 0.2s ease;
}
        .showcase-item:hover {
            transform: scale(1.05);
            border-color: rgba(var(--accent-color), 0.5);
        }

        /* NOUVELLE Animation de reflet "Flash" */
        .showcase-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 30%;
            height: 100%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.25) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            /* Animation plus fréquente, mais avec un passage plus lent */
            animation: final-glare-animation 2.8s infinite cubic-bezier(0.83, 0, 0.17, 1);
            pointer-events: none;
        }

        @keyframes final-glare-animation {
            0% {
                transform: translateX(-200%) skewX(-25deg);
            }
            /* Le reflet prend plus de temps pour traverser (25% au lieu de 15%) */
            25% {
                transform: translateX(400%) skewX(-25deg);
            }
            100% {
                transform: translateX(400%) skewX(-25deg);
            }
        }

        /* --- SYSTÈME VISUEL DE RARETÉ --- */ 

        /* 1. COULEURS POUR LES TITRES */
        .rarity-commun-text { color: #9CA3AF; }      /* Gris */
        .rarity-rare-text { color: #60A5FA; }        /* Bleu */
        .rarity-epique-text { color: #8d62f0; }      /* Violet */
        .rarity-legendaire-text { color: #ffffff; }  /* Or */
        .rarity-mythique-text {
    background: repeating-linear-gradient(
        90deg,
    #f0d133 0%, /* Votre bleu turquoise de base */
    #fbdc81 50%, /* Un bleu-cyan très clair et éclatant */
    #f0d133 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;}    /* Jaune Vif */
        .rarity-divin-text {
    /* On crée un motif répétitif avec ses propres couleurs */
    background: repeating-linear-gradient(
        90deg,
    #42fdfd 0%, /* Votre bleu turquoise de base */
    #befffc 50%, /* Un bleu-cyan très clair et éclatant */
    #42fdfd 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

        /* 2. LUEUR BLANCHE POUR LES ICÔNES DE COLLECTION */
        /* Pas de lueur pour Commun */
        .icon-glow-rare { box-shadow: 0 0 4px 2px rgba(96, 165, 250, 0.7); } /* Bleu */
.icon-glow-epique { box-shadow: 0 0 6px 3px rgba(187, 136, 255, 0.7); } /* Violet */
.icon-glow-legendaire { box-shadow: 0 0 8px 4px rgba(255, 255, 255, 0.8); }
.icon-glow-mythique { box-shadow: 0 0 10px 5px rgba(255, 226, 81, 0.9); } /* Jaune Vif */
.icon-glow-divin {
    box-shadow: 0 0 10px 6px #fff, 0 0 10px 10px #42fdfd;
}
.icon-glow-createur {
    box-shadow: 0 0 10px 6px #fff, 0 0 10px 10px #B91C1C;
}

.rarity-commun-border {
    border-color: #6B7280; /* Gris sobre */
}
.rarity-rare-border {
    border-color: #60A5FA; /* Bleu */
}
.rarity-epique-border {
    border-color: #8d62f0; /* Violet */
}
.rarity-legendaire-border {
    border-color: #ffffff; /* Or */
}
.rarity-mythique-border {
    border-color: #f0d133; /* Jaune Vif */
}
.rarity-divin-border {
    border-color: #06B6D4;
}
.rarity-createur-border {
    border-color: #B91C1C;
}

.rarity-createur-text {
    background: repeating-linear-gradient(
        90deg,
        #B91C1C 0%,
        #d75c53 50%,
        #B91C1C 100%
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

@keyframes scroll-infiniment {
    0% {
        background-position: 0% 50%;
    }
    100% {
        /* On déplace le fond d'une très grande distance pour assurer le défilement */
        background-position: 400% 50%;
    }
}

/* 2. Icône Divine avec un dégradé répétitif */
.animated-icon-divin {
    /* On crée un motif répétitif avec ses propres couleurs */
    background: repeating-linear-gradient(
        90deg,
    #42fdfd 0%, /* Votre bleu turquoise de base */
    #befffc 50%, /* Un bleu-cyan très clair et éclatant */
    #42fdfd 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

/* 3. Icône Créateur avec son propre dégradé répétitif */
.animated-icon-createur {
    /* On crée un motif répétitif avec ses propres couleurs */
    background: repeating-linear-gradient(
        90deg,
        #B91C1C 0%,
        #d75c53 50%,
        #B91C1C 100%
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

.animated-icon-mythique {
    /* On crée un motif répétitif avec ses propres couleurs */
    background: repeating-linear-gradient(
        90deg,
    #f0d133 0%, /* Votre bleu turquoise de base */
    #fbdc81 50%, /* Un bleu-cyan très clair et éclatant */
    #f0d133 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

.title-gymbro-originel {
    background: repeating-linear-gradient(
        90deg,
    #E91E63 0%, /* Rose bonbon profond, couleur de base */
    #FFC0CB 50%, /* Rose très clair et lumineux */
    #E91E63 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}
.title-pompier-muscle, .title-the-bench-monster {
    background: repeating-linear-gradient(
        90deg,
    #E8612A 0%, /* Orange brûlé, couleur de base */
    #FFB380 50%, /* Un orange très clair et lumineux */
    #E8612A 100% /* Retour à la couleur de base */
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

.title-createur-supreme {
    /* On crée un motif répétitif avec ses propres couleurs */
    background: repeating-linear-gradient(
        90deg,
        #B91C1C 0%,
        #d75c53 50%,
        #B91C1C 100%
    );
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;

    /* On utilise la même animation pour la cohérence */
    animation: scroll-infiniment 6s linear infinite;
}

        /* --- NOUVELLES KEYFRAMES D'ANIMATION --- */

        /* Animation "Glitch" pour les objets Épiques */
        @keyframes epic-glitch-text {
            0%, 5%, 100% { text-shadow: 0 0 5px #A78BFA; transform: translateX(0); }
            5.1% { text-shadow: 0 0 10px #EC4899, 2px 2px 2px #60A5FA; transform: translateX(-3px); }
            5.2% { text-shadow: 0 0 10px #EC4899, -2px -2px 2px #60A5FA; transform: translateX(3px); }
            5.3% { text-shadow: 0 0 5px #A78BFA; transform: translateX(0); }
        }

        @keyframes celestial-aura-border {
    0%, 100% {
        box-shadow: 0 0 15px 5px #E0F2FE, 0 0 25px 10px #06B6D4, inset 0 0 10px #fff;
    }
    50% {
        box-shadow: 0 0 25px 8px #E0F2FE, 0 0 40px 15px #06B6D4, inset 0 0 15px #fff;
    }
}

        @keyframes epic-glitch-aura {
    0%, 5%, 100% { box-shadow: 0 0 12px 3px rgba(167, 139, 250, 0.7); }
    5.1% { box-shadow: 4px 0 12px 3px rgba(236, 72, 153, 0.7), -4px 0 12px 3px rgba(96, 165, 250, 0.7); }
    5.2% { box-shadow: -4px 0 12px 3px rgba(236, 72, 153, 0.7), 4px 0 12px 3px rgba(96, 165, 250, 0.7); }
    5.3% { box-shadow: 0 0 12px 3px rgba(167, 139, 250, 0.7); }
}

        /* Animation "Aura" pour les objets Légendaires */
        @keyframes legendary-aura-pulse {
            0%, 100% { filter: drop-shadow(0 0 10px #FBBF24) drop-shadow(0 0 5px #FFFFFF); }
            50% { filter: drop-shadow(0 0 18px #F59E0B) drop-shadow(0 0 8px #FFFFFF); }
        }

        /* Animation "Énergie" pour les objets Mythiques */
        @keyframes mythic-crackle {
            0%, 100% { text-shadow: 2px 2px 2px #A78BFA, -2px -2px 2px #FDE047; }
            25% { text-shadow: -2px 2px 2px #A78BFA, 2px -2px 2px #FDE047; }
            50% { text-shadow: 2px -2px 2px #A78BFA, -2px 2px 2px #FDE047; }
            75% { text-shadow: -2px -2px 2px #A78BFA, 2px 2px 2px #FDE047; }
        }
        @keyframes mythic-aura-pulse {
            0%, 100% { filter: drop-shadow(0 0 15px #FFFFFF) drop-shadow(0 0 25px #A78BFA); }
            50% { filter: drop-shadow(0 0 25px #FFFFFF) drop-shadow(0 0 40px #A78BFA); }
        }

        /* Animation "Nébuleuse" pour la bordure Mythique */
        @keyframes mythic-nebula-border {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Animation "Solaire" pour la bordure Légendaire */
        @keyframes solar-flare-border {
    0%, 100% { 
        /* On retire "inset" pour que l'ombre soit uniquement extérieure */
        box-shadow: 0 0 20px 3px #FBBF24; 
    }
    50% { 
        box-shadow: 0 0 30px 8px #FBBF24; 
    }
}

@keyframes xp-glow-pulse {
    0%, 100% {
        box-shadow: 0 0 4px currentColor;
    }
    50% {
        box-shadow: 0 0 10px currentColor;
    }
}

.tier-switcher-container {
    background-color: rgba(0,0,0,0.2);
    border-radius: 0.75rem;
    padding: 1rem;
    border: 1px solid rgba(255,255,255,0.05);
}

.tier-switcher-arrow {
    width: 2.5rem; /* 40px */
    height: 2.5rem;
    border-radius: 9999px;
    background-color: rgba(255,255,255,0.05);
    color: #9CA3AF; /* gray-400 */
    transition: all 0.2s ease;
}
.tier-switcher-arrow:hover:not(:disabled) {
    background-color: rgba(255,255,255,0.1);
    color: white;
}
.tier-switcher-arrow:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.tier-color-swatch {
    width: 1.5rem; /* 24px */
    height: 1.5rem;
    border-radius: 9999px;
    flex-shrink: 0;
    transition: all 0.3s ease;
}

.tier-color-swatch {
    width: 1.25rem; /* 20px */
    height: 1.25rem;
    border-radius: 9999px;
    flex-shrink: 0;
}

@keyframes gold-radiance {
    0% { background-position: 0% 50%; opacity: 0.2; }
    50% { background-position: 100% 50%; opacity: 0.5; }
    100% { background-position: 0% 50%; opacity: 0.2; }
}

.level-details-modal-maxed::before {
    content: '';
    position: absolute;
    inset: -150px;
    background: radial-gradient(circle, #FDE047, transparent 60%);
    background-size: 200% 200%;
    animation: gold-radiance 8s ease-in-out infinite;
    z-index: 0;
}

@keyframes star-move {
  from { transform: translateY(0px) scale(0.5); opacity: 0; }
  to { transform: translateY(-300px) scale(1.2); opacity: 1; }
}

.starfield {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    height: 300px;
    pointer-events: none;
}
.star {
    width: 2px;
    height: 2px;
    background: #FDE047;
    border-radius: 50%;
    position: absolute;
    animation-name: star-move;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    opacity: 0;
}
.star:nth-child(1) { left: 25%; animation-duration: 5s; animation-delay: 0s; }
.star:nth-child(2) { left: 50%; animation-duration: 3s; animation-delay: 1s; }
.star:nth-child(3) { left: 70%; animation-duration: 6s; animation-delay: 0.5s; }
.star:nth-child(4) { left: 90%; animation-duration: 4s; animation-delay: 2s; }
.star:nth-child(5) { left: 15%; animation-duration: 5.5s; animation-delay: 3s; }
.star:nth-child(6) { left: 40%; animation-duration: 3.5s; animation-delay: 1.5s; }
.star:nth-child(7) { left: 80%; animation-duration: 4.5s; animation-delay: 2.5s; }
.star:nth-child(8) { left: 5%; animation-duration: 6.5s; animation-delay: 3.5s; }

.level-details-modal {
    background-color: #161823;
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    animation: fadeInModal 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
}

@keyframes nebula-flow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.nebula-bg {
    content: '';
    position: absolute;
    inset: -100px; /* Plus grand que la modale pour un effet doux */
    z-index: 0;
    opacity: 0.3;
    background: linear-gradient(
        160deg,
        transparent 30%,
        var(--nebula-color),
        transparent 70%
    );
    background-size: 300% 300%;
    animation: nebula-flow 12s ease-in-out infinite;
    filter: blur(80px); /* Flou très prononcé */
}

.stat-card {
    background: rgba(0,0,0,0.2);
    border-radius: 0.75rem;
    padding: 0.75rem;
    border: 1px solid rgba(255,255,255,0.05);
}

.level-display-main {
    font-size: 6rem; /* 96px */
    font-weight: 900; /* black */
    line-height: 1;
    white-space: nowrap; /* <-- AJOUTEZ CETTE LIGNE */
}

#flow-switcher {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 8px; /* Ajustez pour un alignement parfait avec la nav */
            width: 68px;
            height: 68px;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s cubic-bezier(0.2, 1, 0.2, 1);
            z-index: 10;
        }

        #flow-switcher .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            /* La transition gère l'animation de la rotation ET du fondu */
            transition: transform 0.4s cubic-bezier(0.2, 1, 0.2, 1), opacity 0.4s ease;
        }

        /* Thème du bouton en mode WORKOUT (inchangé) */
        #app-container.workout-active #flow-switcher {
            background: linear-gradient(145deg, var(--theme-primary), var(--theme-dark));
            box-shadow: 0 5px 20px var(--theme-shadow);
        }
        
        /* 2. AJOUT DU CENTRAGE DANS LES TRANSFORMATIONS */
        /* Position des icônes en mode WORKOUT */
        #app-container.workout-active #flow-switcher .workout-icon { 
            transform: translate(-50%, -50%) rotate(0deg);
            opacity: 1;
        }
        #app-container.workout-active #flow-switcher .nutrition-icon { 
            transform: translate(-50%, -50%) rotate(-90deg); 
            opacity: 0;
        }

        /* Thème du bouton en mode NUTRITION (inchangé) */
        #app-container.nutrition-active #flow-switcher {
            background: linear-gradient(145deg, var(--theme-primary), var(--theme-dark));
            box-shadow: 0 5px 20px var(--theme-shadow);
        }

        /* Position des icônes en mode NUTRITION */
        #app-container.nutrition-active #flow-switcher .workout-icon { 
            transform: translate(-50%, -50%) rotate(90deg);
            opacity: 0;
        }
        #app-container.nutrition-active #flow-switcher .nutrition-icon { 
            transform: translate(-50%, -50%) rotate(0deg); 
            opacity: 1;
        }

        /* --- Animation de transition de page --- */
        .page-transition {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .page-fade-out {
            opacity: 0;
            transform: scale(0.98);
        }

        .page-transition-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50; 
    pointer-events: none;
    display: none;
    /* Durée de la transition réduite à 300ms */
    transition: transform 0.3s ease-in-out, background-color 0.3s ease-in-out;
}

.page-transition-overlay.active {
    display: block;
    pointer-events: auto;
}

.page-transition-overlay.enter {
    transform: translateY(0);
}

.page-transition-overlay.exit {
    transform: translateY(-100%);
}

.page-transition-overlay.color-workout {
    background-color: var(--workout-primary);
}

.page-transition-overlay.color-nutrition {
    background-color: var(--nutrition-primary);
}

.page-transition-icon-wrapper {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 51;
    pointer-events: none;
    transition: opacity 0.2s ease-in-out; /* Changement ici : transition de l'opacité */
}

.page-transition-icon-wrapper.active {
    opacity: 1;
}

.page-transition-icon {
    font-size: 3rem;
    color: white;
}

.page-transition-icon-ring {
    position: absolute;
    width: 6rem;
    height: 6rem;
    border: 4px solid transparent;
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    opacity: 0.5;
}

/* Keyframes pour l'animation de rotation */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes switcher-press {
          50% {
            transform: translateX(-50%) scale(0.9);
          }
        }

        #flow-switcher.is-switching {
          animation: switcher-press 0.4s cubic-bezier(0.2, 1, 0.2, 1);
        }

        .calendar-event-badge {
    background-color: #EF4444; /* Rouge vif */
    color: white;
    width: 18px;
    height: 18px;
    border-radius: 9999px;
    font-size: 11px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    margin-top: 2px; /* Espace sous le numéro du jour */
}

#nav-social {
    position: relative; /* Nécessaire pour positionner la pastille par rapport à l'icône */
}

#nav-social.has-notification::after,
#social-inbox-btn.has-notification::after {
    /* Utilise une variable CSS pour afficher le nombre injecté par JavaScript */
    content: var(--notification-count);
    
    /* Style du conteneur de la pastille */
    position: absolute;
    top: 0px;
    right: 0px;
    min-width: 22px; /* Largeur minimale pour un cercle parfait */
    height: 22px;
    padding: 0 6px; /* Permet à la pastille de s'élargir si le nombre est > 9 */
    background-color: #ff3b30; /* Rouge vif */
    border-radius: 9999px; /* Forme de pilule/cercle */
    border: 2px solid var(--background-start-rgb);
    box-shadow: 0 0 5px rgba(255, 59, 48, 0.7);
    transform: translate(30%, -30%); /* Positionnement esthétique */

    /* Style du texte (le nombre) */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-weight: bold;
    color: white;
    line-height: 1;
}

.secondary-btn {
    background-color: transparent;
    color: var(--theme-primary);
    font-weight: 700;
    padding: 0.8rem 1.5rem;
    border-radius: 0.75rem;
    border: 2px solid var(--theme-primary);
    transition: all 0.2s ease;
}
.secondary-btn:hover {
    background-color: var(--theme-shadow);
    transform: scale(1.05);
}

#friend-options-popover {
    position: absolute;
    z-index: 30;
    animation: fadeIn 0.15s ease-out;
}

.dynamic-animated-gradient-text {
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent !important;
    animation: scroll-infiniment 6s linear infinite;
    background-size: 400% 400%;
    /* On utilise des variables CSS pour injecter les couleurs dynamiquement */
    background-image: repeating-linear-gradient(
        90deg,
        var(--base-color) 0%,
        var(--highlight-color) 50%,
        var(--base-color) 100%
    );
}

.dynamic-animated-gradient-icon {
    /* Identique au précédent, mais pour l'icône */
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent !important;
    animation: scroll-infiniment 6s linear infinite;
    background-size: 400% 400%;
    background-image: repeating-linear-gradient(
        90deg,
        var(--base-color-icon) 0%,
        var(--highlight-color-icon) 50%,
        var(--base-color-icon) 100%
    );
}

.toggle-switch-v2 {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
}
.toggle-switch-v2 input {
    opacity: 0;
    width: 0;
    height: 0;
}
.toggle-switch-v2 .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0,0,0,0.3);
    transition: .4s;
    border-radius: 34px;
}
.toggle-switch-v2 .slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}
input:checked + .slider {
    background-color: var(--theme-primary);
}
input:checked + .slider:before {
    transform: translateX(22px);
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.spinning-vinyl {
    animation: spin 2s linear infinite;
}

#clan-music-controls {
                position: fixed;
                bottom: 20px;
                right: 20px;
                z-index: 1050;
                display: flex;
                align-items: center;
                gap: 15px;
            }

            #toggle-clan-music-btn-vinyl {
                position: relative; 
                background-image: url('https://i.imgur.com/7H6rSVA.png');
                background-size: cover;
                width: 50px;
                height: 50px;
                border-radius: 50%;
                cursor: default; /* Changé de 'pointer' à 'default' */
                animation: spin 4s linear infinite;
                animation-play-state: paused;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }

            #toggle-clan-music-btn-vinyl:hover {
               transform: scale(1.1);
               box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
            }

            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }

            /* NOUVEAU STYLE POUR LES PARTICULES */
            .particle {
                position: absolute;
                width: 10px;
                height: 10px;
                pointer-events: none;
                /* CORRECTION : L'image SVG a été retournée verticalement avec un transform SVG */
                background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><g transform="scale(1, -1) translate(0, -512)"><path fill="%23FFFFFF" d="M384 144c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 36.5 24.4 67.4 57.1 76.8L256 464H96V256h16c44.2 0 80-35.8 80-80s-35.8-80-80-80H80c-53 0-96 43-96 96v320c0 17.7 14.3 32 32 32s32-14.3 32-32V480H256c17.7 0 32-14.3 32-32s-14.3-32-32-32H128V320h128c3.3 0 6.5-.2 9.6-.6c34.9-4.2 64.9-25.1 82.6-53.7c17.2-27.9 25.8-60.9 25.8-95.7z"/></g></svg>');
                background-size: contain;
                background-repeat: no-repeat;
                animation: fly-out 1.8s ease-out forwards;
                opacity: 1;
            }

            @keyframes fly-out {
                0% {
                    transform: translate(0, 0) scale(1);
                    opacity: 1;
                }
                100% {
                    transform: translate(var(--tx), var(--ty)) scale(0);
                    opacity: 0;
                }
            }

            #toggle-clan-mute-btn {
                width: 40px;
                height: 40px;
                border-radius: 9999px; /* Cercle parfait */
                background-color: rgba(0, 0, 0, 0.3); /* Fond sombre semi-transparent */
                backdrop-filter: blur(5px); /* Effet de flou */
                display: flex;
                align-items: center;
                justify-content: center;
                color: white; /* Couleur de l'icône */
                transition: all 0.2s ease-out;
                border: none; /* On retire la bordure précédente */
                cursor: pointer;
            }

            #toggle-clan-mute-btn:hover {
                background-color: rgba(0, 0, 0, 0.5); /* Effet au survol */
                transform: translateY(-2px);
            }

            .settings-pencil-btn {
                font-size: 1rem;
                color: #6B7280; /* Gris par défaut */
                transition: color 0.2s ease-in-out;
            }
            .settings-pencil-btn:hover {
                color: #FFFFFF; /* Blanc au survol */
            }

            .vault-lift-tab.active {
    background-color: rgba(255, 255, 255, 0.1);
    color: white;
}

input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield; /* Pour Firefox */
        }

        #studio-canvas {
    background-color: #161823;
    background-image: 
        linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
    background-size: 30px 30px;
}

.phase-block {
    background: rgba(var(--glass-bg-rgb), 0.03);
    border: 1px solid rgba(var(--glass-bg-rgb), 0.08);
    border-radius: 1.5rem; /* 24px */
    padding: 1.5rem;
}

.phase-header {
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(var(--glass-bg-rgb), 0.1);
}

.weeks-container {
    margin-top: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.week-block {
    background: rgba(0,0,0,0.15);
    border-radius: 1rem; /* 16px */
    padding: 1rem;
}

.days-grid {
    margin-top: 0.75rem; /* 12px */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 0.75rem;
}

.day-card {
    background: rgba(0,0,0,0.2);
    border-radius: 0.75rem; /* 12px */
    padding: 0.75rem;
    aspect-ratio: 1 / 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
    border: 1px solid transparent;
    transition: all 0.2s ease-in-out;
}

.day-card:hover {
    border-color: var(--theme-primary);
    transform: translateY(-4px);
    background: rgba(var(--theme-primary-rgb, 167, 139, 250), 0.1);
}

.day-card .day-title {
    font-weight: 700;
    font-size: 0.875rem; /* 14px */
}

.day-card .blocks-preview {
    align-self: flex-end;
}

#block-editor-backdrop {
    position: absolute;
    inset: 0;
    background-color: rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    z-index: 35;
}
#block-editor-panel {
    position: fixed; /* Ou absolute par rapport à #app-container */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90%;
    max-width: 450px;
    background-color: #1F2130; /* Une couleur de fond solide */
    border-left: 1px solid rgba(255,255,255,0.1);
    transform: translateX(100%); /* Caché par défaut */
    transition: transform 0.4s cubic-bezier(0.2, 1, 0.2, 1);
    z-index: 40; /* Au-dessus du reste */
}
#block-editor-panel.active {
    transform: translateX(0); /* Apparaît à l'écran */
}
#block-editor-container.active #block-editor-backdrop {
    opacity: 1;
}
#block-editor-container.active #block-editor-panel {
    transform: translateX(0);
}

.studio-tab-btn { transition: all 0.2s ease-in-out; }

        .days-scroller-container {
            position: relative;
        }

        .days-scroller {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: minmax(130px, 1fr);
    overflow-x: auto;
    /* La ligne "scrollbar-hide: ;" a été supprimée car c'est une classe, pas une propriété */
}

        .day-card-delete-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 24px;
            height: 24px;
            border-radius: 9999px;
            background-color: #EF4444; /* red-500 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            z-index: 10;
        }
        .day-card:hover .day-card-delete-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .week-scroll-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border-radius: 9999px;
            background-color: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            cursor: pointer;
            transition: opacity 0.2s;
            opacity: 0;
            pointer-events: none;
        }

        .days-scroller-container:hover .week-scroll-arrow {
            opacity: 1;
            pointer-events: auto;
        }
        
        .week-scroll-arrow.left { left: -12px; }
        .week-scroll-arrow.right { right: -12px; }
        .week-scroll-arrow:disabled { opacity: 0.2 !important; cursor: not-allowed; }

    </style>
</head>
<body class="flex justify-center items-center min-h-screen p-4">
    <audio id="clan-music-player" loop></audio>

    <div id="app-container" class="app-container relative w-full max-w-md h-[850px] max-h-[90vh] rounded-[40px] shadow-2xl overflow-hidden border-2 border-gray-800">
        
        <!-- Spot de lueur d'arrière-plan global -->
        <div id="background-glow-spot"></div>

        <div id="page-transition-overlay" class="page-transition-overlay">
            <div id="page-transition-icon-wrapper" class="page-transition-icon-wrapper">
                <div id="page-transition-icon-ring" class="page-transition-icon-ring"></div>
                <i id="page-transition-icon" class="fa-solid page-transition-icon"></i>
            </div>
        </div>
        <div id="toast-container"></div>
        <div id="cropper-modal-container" class="fixed inset-0 z-40 hidden"></div>
        <div id="page-container" class="absolute inset-0 overflow-y-auto scrollbar-hide"></div>
        <div id="bottom-nav-container" class="absolute bottom-4 left-4 right-4 h-16 z-20"></div>
        <div id="global-modal-container" class="absolute inset-0 z-30 pointer-events-none"></div>
        <div id="scanner-container" class="fixed inset-0 z-40 hidden"></div>
    </div>

 <script type="module">

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInWithCustomToken, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, addDoc, updateDoc, serverTimestamp, limit, getDocs, Timestamp, arrayUnion, arrayRemove, deleteDoc, orderBy, runTransaction, writeBatch, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

function getInitialState() {
    return {
        activeSide: 'workout',
        workouts: [],
        meals: [],
        workoutTags: [],
        mealTags: [],
        mealsSortOrder: 'alpha',
        calendarEvents: [],
        sessionHistory: [],
        userGoals: { calories: 2500, protein: 180, bodyWeight: 75 },
        userProfile: {
            name: 'User',
            dob: null,
            sex: null,
            country: null,
            profilePicUrl: null,
            coins: 0,
            inventory: {
                borders: ['b001'],
                titles: ['t001'],
                collectibles: []
            },
            equipped: {
                border: 'b001',
                title: 't001',
                showcase: [null, null, null]
            },
            achievements: {},
            leveling: {
                realLevel: 1,
                xp: 0,
                isMaxedOut: false
            },
            clanId: null,
            isCreator: false,
            quests: {
                lastDailyReset: null,
                lastWeeklyReset: null,
                daily: [],
                weekly: []
            },
            sbdVault: {
                squat: { verified: null, pending_tribunal: null, processing: null },
                bench: { verified: null, pending_tribunal: null, processing: null },
                deadlift: { verified: null, pending_tribunal: null, processing: null }
            },
            sbd_ranks: {
        squat: { best_1rm: 0, rank: "Non classé" },
        bench: { best_1rm: 0, rank: "Non classé" },
        deadlift: { best_1rm: 0, rank: "Non classé" },
        total: 0
    },
    judgeStatus: 'none', // 'none', 'confirmed', 'elite'
    judgeHonorScore: 100
        },
        shop: {
            activeTab: 'box',
            scrollPosition: undefined,
            bordersSortOrder: 'possession',
            titlesSortOrder: 'possession',
            collectiblesSortOrder: 'possession'
        },
        achievementsSortOrder: 'progress_desc',
        itemSelectorSortOrder: 'rarity_desc',
        exerciseStats: {},
        clanMusicMuted: false,
        activePage: 'Accueil',
        calendarDate: new Date(),
        currentPageParams: {},
        editingWorkout: null,
        editingMeal: null,
        isAnimating: false,
        selectedChartExerciseId: null,
        activeWorkoutSession: null,
        tempUserProfile: null,
        viewFilter: 'workout',
        workoutsSortOrder: 'alpha',
        statsSortOrder: 'rank_desc',
        sortOrderLabels: {
            'rank_desc': 'Meilleurs Rangs',
            'rank_asc': 'Pires Rangs',
            'alpha': 'Ordre Alphabétique'
        },
        rankInfoModal: {
            selectedRank: 'Novice'
        },
        streaks: {
            workout: { count: 0, lastChance: false },
            nutrition: { count: 0 }
        },
        recurrence: {
            workout: { enabled: false, period: 'week', templates: { week: {}, month: {} } },
            nutrition: { enabled: false, period: 'week', templates: { week: {}, month: {} } }
        },
        currentClanData: null,
        friends: {
            accepted: [],
            pendingSent: [],
            pendingReceived: [],
            sortOrder: 'rank_desc'
        },
        social: { activeTab: 'gym' },
        inbox: { unreadMessages: [] },
        creatorPrograms: [],
        programStudio: {
    activeTab: 'info' // 'info', 'structure', 'publish'
}
    };
}

function isUserAJudge(userProfile) {
    // ANCIENNE LIGNE : return userProfile?.achievements?.secret_dev_achievement ? true : false;
    
    // NOUVELLE LIGNE :
    return true; // Tout le monde est maintenant un juge.
}

async function submitSBDPerformanceForValidation(liftData) {
    if (!currentUserId || !liftData.videoUrl || !liftData.videoPath) {
        showToast("Une erreur est survenue, informations vidéo manquantes.", "error");
        return null; // On retourne null en cas d'erreur
    }
    try {
        const perfDocRef = await addDoc(collection(db, 'sbd_performances'), {
            userId: currentUserId,
            liftType: liftData.liftType,
            weight: liftData.weight,
            reps: liftData.reps,
            bodyweight: liftData.bodyweight,
            timestamp: serverTimestamp(),
            status: 'pending_video',
            validationMethod: 'video'
        });

        // On crée la validation et on garde une référence
        const validationDocRef = await addDoc(collection(db, 'video_validations'), {
            sbdPerfId: perfDocRef.id,
            userId: currentUserId,
            videoUrl: liftData.videoUrl,
            videoPath: liftData.videoPath,
            status: 'processing',
            judgements: []
        });
        
        // On retourne l'ID du document de validation qui vient d'être créé
        return validationDocRef.id;

    } catch (error) {
        console.error("Erreur lors de la soumission de la performance SBD :", error);
        showToast("Une erreur est survenue lors de la soumission.", "error");
        return null; // On retourne null en cas d'erreur
    }
}
 
// --- Variables globales de l'application ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = {
  apiKey: "AIzaSyA3rqrGWagKM3A3xJfwltw_QtrL1-r9E4g",
  authDomain: "fitflow-92448.firebaseapp.com",
  projectId: "fitflow-92448",
  storageBucket: "fitflow-92448.firebasestorage.app",
  messagingSenderId: "1080535839808",
  appId: "1:1080535839808:web:dd6d0e73ea4a4b89c15ba5",
  measurementId: "G-RZTWJWC0BD"
};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Déclarer les variables globales pour les services Firebase
let app;
let auth;
let db;

let currentUserId = null;
let isFirebaseReady = false;

        async function signInWithToken() {
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                } catch (error) {
                    console.error("Erreur de connexion avec le jeton personnalisé :", error);
                }
            }
        }

        const CLAN_ICONS = [
    { id: 'ico01', icon: 'fa-skull-crossbones' },
    { id: 'ico02', icon: 'fa-crown' },
    { id: 'ico03', icon: 'fa-shield-halved' },
    { id: 'ico04', icon: 'fa-bolt-lightning' },
    { id: 'ico05', icon: 'fa-dragon' },
    { id: 'ico06', icon: 'fa-fist-raised' },
    { id: 'ico07', icon: 'fa-meteor' },
    { id: 'ico08', icon: 'fa-atom' },
    { id: 'ico09', icon: 'fa-volcano' },
    { id: 'ico10', icon: 'fa-wolf-pack-battalion' }, // Vous devrez peut-être ajouter Font Awesome Pro ou une autre lib pour cette icône
    { id: 'ico11', icon: 'fa-anchor' },
    { id: 'ico12', icon: 'fa-chess-rook' },
];

const ASSETS_URLS = {
    image1: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/Pochette-album-nuit-VKNG.png',
    image2: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/create-a-hardstyle-rawstyle-hardcore-cover-artwork-for-your-track.png',
    image3: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/i-will-create-your-rock-metal-album-cover-for-120-no-ai-v0-uo2qmcltx9re1.png',
     // <-- COLLEZ ICI LE LIEN DE VOTRE POCHETTE
    musique1: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/Ariel%20Shalom%20-%20Vibrant.mp3', // <-- COLLEZ ICI LE LIEN DE VOTRE 1ÈRE MUSIQUE
    musique2: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/Flint%20-%20Fooling%20Myself.mp3',
    musique3: 'https://raw.githubusercontent.com/Lilianrvi/clan-musiques-fitflow/refs/heads/main/Ziskoe%20-%20Late%20Night%20Pie.mp3', // <-- COLLEZ ICI LE LIEN DE VOTRE 2ÈME MUSIQUE
    // Ajoutez autant de lignes que nécessaire pour vos autres musiques
};


// --- FIN DU NOUVEAU BLOC ---

const CLAN_MUSIC_DATABASE = [
    { id: 'music_none', name: 'Aucune', url: null, image: null },
    {
        id: 'musique_epique',
        name: 'Thème Héroïque',
        url: ASSETS_URLS.musique1,
        image: ASSETS_URLS.image1
    },
    {
        id: 'ambiance_lofi',
        name: 'Concentration Lo-Fi',
        url: ASSETS_URLS.musique2,
        image: ASSETS_URLS.image2
    },
    {
        id: 'hardstyle',
        name: 'rave',
        url: ASSETS_URLS.musique3,
        image: ASSETS_URLS.image3
    },
];

        // --- SYSTÈME DE RANGS ---
        
        const RANK_NAMES = ['Novice', 'Rookie', 'Disciple', 'Forgeron', 'Vétéran', 'Prodige', 'Colosse', 'Demi-Dieu'];
        const RANK_POINTS_MAP = {
            'Novice III': 1, 'Novice II': 2, 'Novice I': 3,
            'Rookie III': 4, 'Rookie II': 5, 'Rookie I': 6,
            'Disciple III': 7, 'Disciple II': 8, 'Disciple I': 9,
            'Forgeron III': 10, 'Forgeron II': 11, 'Forgeron I': 12,
            'Vétéran III': 13, 'Vétéran II': 14, 'Vétéran I': 15,
            'Prodige III': 16, 'Prodige II': 17, 'Prodige I': 18,
            'Colosse III': 19, 'Colosse II': 20, 'Colosse I': 21,
            'Demi-Dieu III': 22, 'Demi-Dieu II': 23, 'Demi-Dieu I': 24
        };

        const PRESTIGE_TIER_COLORS = [
    // Tier 0 (Gamme Acier)
    '#A1A1AA',
    // Tier 1 (Gamme Bronze)
    '#D97706',
    // Tier 2 (Gamme Saphir)
    '#3B82F6',
    // Tier 3 (Gamme Émeraude)
    '#10B981',
    // Tier 4 (Gamme Rubis)
    '#EF4444',
    // Tier 5 (Gamme Améthyste)
    '#8B5CF6',
    // Tier 6 (Gamme Nébuleuse)
    '#EC4899',
    // Tier 7 (Gamme Solaire)
    '#FACC15',
    // Tier 8 (Gamme Platine)
    '#E5E7EB',
    // Tier 9 (Gamme Divine)
    '#FDE047'
];

// --- SYSTÈME DE NIVEAUX ET QUÊTES ---

        const xpLevelCache = { 1: 100 };
        const xpTotalCache = { 1: 0 }; // <-- AJOUTE CETTE LIGNE ICI
        
        function calculateXPForLevel(level) {
            if (level <= 0) return 0;
            if (xpLevelCache[level]) {
                return xpLevelCache[level];
            }

            // Comme la formule est récurrente, nous devons calculer depuis la dernière valeur connue.
            let lastCalculatedLevel = Math.max(...Object.keys(xpLevelCache).map(Number));

            for (let n = lastCalculatedLevel; n < level; n++) {
                // On utilise 'n' dans la formule pour calculer le terme u_{n+1}.
                const u_n = xpLevelCache[n];
                const u_n_plus_1 = Math.round(u_n + 10 + Math.sin(0.1 * n));
                xpLevelCache[n + 1] = u_n_plus_1;
            }

            return xpLevelCache[level];
        }

        function calculateTotalXPToReachLevel(level) {
    if (level <= 1) return 0;
    // Si la valeur est déjà dans notre cache, on la retourne instantanément.
    if (xpTotalCache[level]) {
        return xpTotalCache[level];
    }

    // Sinon, on calcule à partir de la dernière valeur connue pour ne pas tout refaire.
    let lastCalculatedLevel = Math.max(...Object.keys(xpTotalCache).map(Number));
    let currentTotal = xpTotalCache[lastCalculatedLevel];

    for (let i = lastCalculatedLevel; i < level; i++) {
        // Pour obtenir le total pour i+1, on ajoute l'XP nécessaire pour le niveau i.
        currentTotal += calculateXPForLevel(i);
        // On stocke le nouveau total dans le cache pour les futurs calculs.
        xpTotalCache[i + 1] = currentTotal;
    }

    return xpTotalCache[level];
}

        const LEVEL_TIERS_COLORS = {
            'Niveau 1': { color: '#F87171', shadow: '#DC2626' }, // Rose saumon
            'Niveau 10': { color: '#FBBF24', shadow: '#D97706' }, // Jaune ambre
            'Niveau 20': { color: '#60A5FA', shadow: '#2563EB' }, // Bleu clair
            'Niveau 30': { color: '#A78BFA', shadow: '#7C3AED' }, // Violet
            'Niveau 40': { color: '#34D399', shadow: '#059669' }, // Vert menthe
            'Niveau 50': { color: '#F472B6', shadow: '#EC4899' }, // Rose fuchsia
            'Niveau 60': { color: '#EAB308', shadow: '#D97706' }, // Jaune d'or
            'Niveau 70': { color: '#BFDBFE', shadow: '#60A5FA' }, // Bleu ciel
            'Niveau 80': { color: '#8d62f0', shadow: '#6B21A8' }, // Violet profond
            'Niveau 90': { color: '#A3E635', shadow: '#84CC16' }, // Vert citron
            'Niveau 100': { color: '#FFFFFF', shadow: '#FFFFFF' } // Blanc (pour le niveau max)
        };

        // Base de données de toutes les quêtes possibles
        const DAILY_QUEST_REWARDS = { xp: 150, coins: 25 };
const WEEKLY_QUEST_REWARDS = { xp: 750, coins: 125 };

const QUEST_DATABASE = {
    workout: {
        daily: [
            { id: 'wd01', icon: 'fa-check-double', description: "Terminer 1 séance d'entraînement.", type: 'complete_sessions', goal: 1, rewards: DAILY_QUEST_REWARDS },
            { id: 'wd02', icon: 'fa-weight-hanging', description: "Soulever un total de 5,000 kg.", type: 'total_volume', goal: 5000, rewards: DAILY_QUEST_REWARDS },
            { id: 'wd03', icon: 'fa-repeat', description: "Effectuer 100 répétitions au total.", type: 'total_reps', goal: 100, rewards: DAILY_QUEST_REWARDS },
            { id: 'wd04', icon: 'fa-clock', description: "S'entraîner au moins pendant 30 minutes.", type: 'total_training_time', goal: 30, rewards: DAILY_QUEST_REWARDS },
            { id: 'wd05', icon: 'fa-layer-group', description: "Terminer un total de 10 séries.", type: 'total_sets', goal: 10, rewards: DAILY_QUEST_REWARDS },
            { id: 'wd06', icon: 'fa-dumbbell', description: "Effectuer 5 exercices différents dans une séance.", type: 'distinct_exercises', goal: 5, rewards: DAILY_QUEST_REWARDS }
        ],
        weekly: [
            { id: 'ww01', icon: 'fa-calendar-check', description: "Terminer 4 séances d'entraînement.", type: 'complete_sessions', goal: 4, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'ww02', icon: 'fa-mountain', description: "Soulever un total de 25,000 kg.", type: 'total_volume', goal: 25000, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'ww03', icon: 'fa-star', description: "Battre 3 records personnels (PR).", type: 'break_prs', goal: 3, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'ww04', icon: 'fa-infinity', description: "Effectuer 500 répétitions au total.", type: 'total_reps', goal: 500, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'ww05', icon: 'fa-universal-access', description: "Entraîner Pectoraux, Dos et Jambes.", type: 'train_all_muscle_groups', goal: 3, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'ww06', icon: 'fa-hourglass-half', description: "S'entraîner pendant 3 heures au total.", type: 'total_training_time_weekly', goal: 180, rewards: WEEKLY_QUEST_REWARDS }
        ]
    },
    nutrition: {
        daily: [
            { id: 'nd01', icon: 'fa-bullseye', description: "Atteindre son objectif de calories.", type: 'reach_calorie_goal', goal: 1, rewards: DAILY_QUEST_REWARDS },
            { id: 'nd02', icon: 'fa-drumstick-bite', description: "Atteindre son objectif de protéines.", type: 'reach_protein_goal', goal: 1, rewards: DAILY_QUEST_REWARDS },
            { id: 'nd03', icon: 'fa-shield-halved', description: "Valider un repas avec un FitScore de 75+.", type: 'high_fitscore_meal', goal: 1, rewards: DAILY_QUEST_REWARDS },
            { id: 'nd04', icon: 'fa-barcode', description: "Scanner un code-barres.", type: 'scan_barcode', goal: 1, rewards: DAILY_QUEST_REWARDS },
            { id: 'nd05', icon: 'fa-utensils', description: "Valider 3 repas dans la journée.", type: 'log_meals_count', goal: 3, rewards: DAILY_QUEST_REWARDS },
            { id: 'nd06', icon: 'fa-bolt', description: "Valider un repas avec plus de 40g de protéines.", type: 'high_protein_meal', goal: 1, rewards: DAILY_QUEST_REWARDS }
        ],
        weekly: [
            { id: 'nw01', icon: 'fa-calculator', description: "Enregistrer un total de 10,000 calories.", type: 'total_calories_logged', goal: 10000, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'nw02', icon: 'fa-calendar-days', description: "Atteindre ses objectifs nutritionnels 3 jours.", type: 'reach_nutrition_goals_days', goal: 3, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'nw03', icon: 'fa-fire-flame-curved', description: "Maintenir une série nutrition de 3 jours.", type: 'nutrition_streak', goal: 3, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'nw04', icon: 'fa-person-running', description: "Atteindre son objectif de protéines 4 jours.", type: 'reach_protein_goal_days', goal: 4, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'nw05', icon: 'fa-plus', description: "Créer un nouveau repas.", type: 'create_new_meal', goal: 1, rewards: WEEKLY_QUEST_REWARDS },
            { id: 'nw06', icon: 'fa-book-bookmark', description: "Valider un total de 15 repas.", type: 'log_meals_count_weekly', goal: 15, rewards: WEEKLY_QUEST_REWARDS }
        ]
    }
};

        const REVERSE_RANK_POINTS_MAP = Object.fromEntries(Object.entries(RANK_POINTS_MAP).map(([name, points]) => [points, name]));
        const RANK_DESCRIPTIONS = {
            'Novice': "Chaque légende a un point de départ. Le vôtre est ici.",
            'Rookie': "La détermination porte ses fruits. Vous n'êtes plus un débutant.",
            'Disciple': "La discipline est votre alliée. La technique s'affine, la force grandit.",
            'Forgeron': "Vous ne subissez plus l'entraînement, vous le forgez. Chaque série est un coup de marteau.",
            'Vétéran': "Les poids vous connaissent et vous respectent. Votre expérience parle sur le terrain.",
            'Prodige': "Votre potentiel dépassait les attentes. Un talent rare est né.",
            'Colosse': "Votre présence impose le silence. Une force de la nature, sculptée par la fonte.",
            'Demi-Dieu': "Vous marchez parmi les mortels, mais votre force appartient à l'Olympe."
        };
        const EXERCISE_DATABASE = [];
        const MUSCLE_GROUPS = {
            pecs: 'Pectoraux', dos: 'Dos', epaules: 'Épaules', biceps: 'Biceps',
            triceps: 'Triceps', jambes: 'Jambes', abdos: 'Abdos'
        };
        
        const COUNTRY_LIST = [
    { name: 'Afghanistan', code: 'af' },
    { name: 'Afrique du Sud', code: 'za' },
    { name: 'Albanie', code: 'al' },
    { name: 'Algérie', code: 'dz' },
    { name: 'Allemagne', code: 'de' },
    { name: 'Andorre', code: 'ad' },
    { name: 'Angola', code: 'ao' },
    { name: 'Anguilla', code: 'ai' },
    { name: 'Antigua-et-Barbuda', code: 'ag' },
    { name: 'Arabie saoudite', code: 'sa' },
    { name: 'Argentine', code: 'ar' },
    { name: 'Arménie', code: 'am' },
    { name: 'Aruba', code: 'aw' },
    { name: 'Australie', code: 'au' },
    { name: 'Autriche', code: 'at' },
    { name: 'Azerbaïdjan', code: 'az' },
    { name: 'Bahamas', code: 'bs' },
    { name: 'Bahreïn', code: 'bh' },
    { name: 'Bangladesh', code: 'bd' },
    { name: 'Barbade', code: 'bb' },
    { name: 'Belgique', code: 'be' },
    { name: 'Belize', code: 'bz' },
    { name: 'Bénin', code: 'bj' },
    { name: 'Bermudes', code: 'bm' },
    { name: 'Bhoutan', code: 'bt' },
    { name: 'Biélorussie', code: 'by' },
    { name: 'Bolivie', code: 'bo' },
    { name: 'Bosnie-Herzégovine', code: 'ba' },
    { name: 'Botswana', code: 'bw' },
    { name: 'Brésil', code: 'br' },
    { name: 'Brunei Darussalam', code: 'bn' },
    { name: 'Bulgarie', code: 'bg' },
    { name: 'Burkina Faso', code: 'bf' },
    { name: 'Burundi', code: 'bi' },
    { name: 'Cambodge', code: 'kh' },
    { name: 'Cameroun', code: 'cm' },
    { name: 'Canada', code: 'ca' },
    { name: 'Cap-Vert', code: 'cv' },
    { name: 'République centrafricaine', code: 'cf' },
    { name: 'Chili', code: 'cl' },
    { name: 'Chine', code: 'cn' },
    { name: 'Chypre', code: 'cy' },
    { name: 'Colombie', code: 'co' },
    { name: 'Comores', code: 'km' },
    { name: 'Congo', code: 'cg' },
    { name: 'Congo, République démocratique du', code: 'cd' },
    { name: 'Corée, République de', code: 'kr' },
    { name: "Corée, République populaire démocratique de", code: 'kp' },
    { name: 'Costa Rica', code: 'cr' },
    { name: "Côte d'Ivoire", code: 'ci' },
    { name: 'Croatie', code: 'hr' },
    { name: 'Cuba', code: 'cu' },
    { name: 'Curaçao', code: 'cw' },
    { name: 'Danemark', code: 'dk' },
    { name: 'Djibouti', code: 'dj' },
    { name: 'Dominique', code: 'dm' },
    { name: 'Égypte', code: 'eg' },
    { name: 'El Salvador', code: 'sv' },
    { name: 'Émirats arabes unis', code: 'ae' },
    { name: 'Équateur', code: 'ec' },
    { name: 'Érythrée', code: 'er' },
    { name: 'Espagne', code: 'es' },
    { name: 'Estonie', code: 'ee' },
    { name: 'États-Unis', code: 'us' },
    { name: 'Éthiopie', code: 'et' },
    { name: 'Fidji', code: 'fj' },
    { name: 'Finlande', code: 'fi' },
    { name: 'France', code: 'fr' },
    { name: 'Gabon', code: 'ga' },
    { name: 'Gambie', code: 'gm' },
    { name: 'Géorgie', code: 'ge' },
    { name: 'Ghana', code: 'gh' },
    { name: 'Gibraltar', code: 'gi' },
    { name: 'Grèce', code: 'gr' },
    { name: 'Grenade', code: 'gd' },
    { name: 'Groenland', code: 'gl' },
    { name: 'Guam', code: 'gu' },
    { name: 'Guatemala', code: 'gt' },
    { name: 'Guinée', code: 'gn' },
    { name: 'Guinée équatoriale', code: 'gq' },
    { name: 'Guinée-Bissau', code: 'gw' },
    { name: 'Guyana', code: 'gy' },
    { name: 'Haïti', code: 'ht' },
    { name: 'Honduras', code: 'hn' },
    { name: 'Hongrie', code: 'hu' },
    { name: 'Îles Caïmans', code: 'ky' },
    { name: 'Îles Cook', code: 'ck' },
    { name: 'Îles Féroé', code: 'fo' },
    { name: 'Îles Marshall', code: 'mh' },
    { name: 'Îles Salomon', code: 'sb' },
    { name: 'Îles Turques et Caïques', code: 'tc' },
    { name: 'Îles Vierges britanniques', code: 'vg' },
    { name: 'Îles Vierges des États-Unis', code: 'vi' },
    { name: 'Inde', code: 'in' },
    { name: 'Indonésie', code: 'id' },
    { name: 'Iran', code: 'ir' },
    { name: 'Iraq', code: 'iq' },
    { name: 'Irlande', code: 'ie' },
    { name: 'Islande', code: 'is' },
    { name: 'Israël', code: 'il' },
    { name: 'Italie', code: 'it' },
    { name: 'Jamaïque', code: 'jm' },
    { name: 'Japon', code: 'jp' },
    { name: 'Jordanie', code: 'jo' },
    { name: 'Kazakhstan', code: 'kz' },
    { name: 'Kenya', code: 'ke' },
    { name: 'Kirghizistan', code: 'kg' },
    { name: 'Kiribati', code: 'ki' },
    { name: 'Koweït', code: 'kw' },
    { name: 'Laos', code: 'la' },
    { name: 'Lesotho', code: 'ls' },
    { name: 'Lettonie', code: 'lv' },
    { name: 'Liban', code: 'lb' },
    { name: 'Libéria', code: 'lr' },
    { name: 'Libye', code: 'ly' },
    { name: 'Liechtenstein', code: 'li' },
    { name: 'Lituanie', code: 'lt' },
    { name: 'Luxembourg', code: 'lu' },
    { name: 'Macédoine du Nord', code: 'mk' },
    { name: 'Madagascar', code: 'mg' },
    { name: 'Malaisie', code: 'my' },
    { name: 'Malawi', code: 'mw' },
    { name: 'Maldives', code: 'mv' },
    { name: 'Mali', code: 'ml' },
    { name: 'Malte', code: 'mt' },
    { name: 'Maroc', code: 'ma' },
    { name: 'Martinique', code: 'mq' },
    { name: 'Maurice', code: 'mu' },
    { name: 'Mauritanie', code: 'mr' },
    { name: 'Mayotte', code: 'yt' },
    { name: 'Mexique', code: 'mx' },
    { name: 'Micronésie', code: 'fm' },
    { name: 'Moldavie', code: 'md' },
    { name: 'Monaco', code: 'mc' },
    { name: 'Mongolie', code: 'mn' },
    { name: 'Monténégro', code: 'me' },
    { name: 'Montserrat', code: 'ms' },
    { name: 'Mozambique', code: 'mz' },
    { name: 'Myanmar', code: 'mm' },
    { name: 'Namibie', code: 'na' },
    { name: 'Nauru', code: 'nr' },
    { name: 'Népal', code: 'np' },
    { name: 'Nicaragua', code: 'ni' },
    { name: 'Niger', code: 'ne' },
    { name: 'Nigéria', code: 'ng' },
    { name: 'Niue', code: 'nu' },
    { name: 'Norvège', code: 'no' },
    { name: 'Nouvelle-Calédonie', code: 'nc' },
    { name: 'Nouvelle-Zélande', code: 'nz' },
    { name: 'Oman', code: 'om' },
    { name: 'Ouganda', code: 'ug' },
    { name: 'Ouzbékistan', code: 'uz' },
    { name: 'Pakistan', code: 'pk' },
    { name: 'Palaos', code: 'pw' },
    { name: 'Palestine, État de', code: 'ps' },
    { name: 'Panama', code: 'pa' },
    { name: 'Papouasie-Nouvelle-Guinée', code: 'pg' },
    { name: 'Paraguay', code: 'py' },
    { name: 'Pays-Bas', code: 'nl' },
    { name: 'Pérou', code: 'pe' },
    { name: 'Philippines', code: 'ph' },
    { name: 'Pologne', code: 'pl' },
    { name: 'Polynésie française', code: 'pf' },
    { name: 'Porto Rico', code: 'pr' },
    { name: 'Portugal', code: 'pt' },
    { name: 'Qatar', code: 'qa' },
    { name: 'Réunion', code: 're' },
    { name: 'Roumanie', code: 'ro' },
    { name: 'Royaume-Uni', code: 'gb' },
    { name: 'Russie', code: 'ru' },
    { name: 'Rwanda', code: 'rw' },
    { name: 'Saint-Kitts-et-Nevis', code: 'kn' },
    { name: 'Saint-Marin', code: 'sm' },
    { name: 'Saint-Vincent-et-les-Grenadines', code: 'vc' },
    { name: 'Sainte-Hélène', code: 'sh' },
    { name: 'Sainte-Lucie', code: 'lc' },
    { name: 'Samoa', code: 'ws' },
    { name: 'Samoa américaines', code: 'as' },
    { name: 'Sao Tomé-et-Principe', code: 'st' },
    { name: 'Sénégal', code: 'sn' },
    { name: 'Serbie', code: 'rs' },
    { name: 'Seychelles', code: 'sc' },
    { name: 'Sierra Leone', code: 'sl' },
    { name: 'Singapour', code: 'sg' },
    { name: 'Slovaquie', code: 'sk' },
    { name: 'Slovénie', code: 'si' },
    { name: 'Somalie', code: 'so' },
    { name: 'Soudan', code: 'sd' },
    { name: 'Soudan du Sud', code: 'ss' },
    { name: 'Sri Lanka', code: 'lk' },
    { name: 'Suède', code: 'se' },
    { name: 'Suisse', code: 'ch' },
    { name: 'Suriname', code: 'sr' },
    { name: 'Syrie', code: 'sy' },
    { name: 'Tadjikistan', code: 'tj' },
    { name: 'Tanzanie', code: 'tz' },
    { name: 'Tchad', code: 'td' },
    { name: 'Tchéquie', code: 'cz' },
    { name: 'Thaïlande', code: 'th' },
    { name: 'Timor-Leste', code: 'tl' },
    { name: 'Togo', code: 'tg' },
    { name: 'Tonga', code: 'to' },
    { name: 'Trinité-et-Tobago', code: 'tt' },
    { name: 'Tunisie', code: 'tn' },
    { name: 'Turkménistan', code: 'tm' },
    { name: 'Turquie', code: 'tr' },
    { name: 'Tuvalu', code: 'tv' },
    { name: 'Ukraine', code: 'ua' },
    { name: 'Uruguay', code: 'uy' },
    { name: 'Vanuatu', code: 'vu' },
    { name: 'Venezuela', code: 've' },
    { name: 'Vietnam', code: 'vn' },
    { name: 'Yémen', code: 'ye' },
    { name: 'Zambie', code: 'zm' },
    { name: 'Zimbabwe', code: 'zw' }
];

// DANS VOTRE SCRIPT, TROUVEZ CETTE LIGNE ET AJOUTEZ 'Créateur'
const RARITY_ORDER = { 'Commun': 1, 'Rare': 2, 'Épique': 3, 'Légendaire': 4, 'Mythique': 5, 'Divin': 6, 'Créateur': 7 };

const RARITY_INFO_DATA = [
    { name: 'Commun', color: '#9CA3AF', description: 'Les bases. Obtenu couramment.' },
    { name: 'Rare', color: '#60A5FA', description: 'Uniques et distingués. Commencent à se démarquer.' },
    { name: 'Épique', color: '#8d62f0', description: 'Rarement vus. Offrent des effets spéciaux subtils.' },
    { name: 'Légendaire', color: '#FBBF24', description: 'Objet de prestige. Effets et animations plus marqués.' },
    { name: 'Mythique', color: '#f0d133', description: 'Extrêmement rares. Un prestige inégalé.' },
    { name: 'Divin', color: '#42fdfd', description: 'Le summum. L\'ultime preuve de votre statut.' },
    { name: 'Créateur', color: '#B91C1C', description: 'Une rareté secrète, réservée au développeur.' }
];

// --- UTILITY FUNCTIONS ---
const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const getExerciseById = (id) => EXERCISE_DATABASE.find(ex => ex.id === id) || { id: null, name: 'Exercice Inconnu', type: 'weighted', coefficient: 0, targetScore: 1, groups: [] };

const formatDateToYYYYMMDD = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
};
const truncateText = (text, maxLength) => (!text || text.length <= maxLength) ? text : text.substring(0, maxLength) + '...';

        function initializeDatabase() {
            // Liste complète avec objectifs de performance rééquilibrés
            const exerciseList = [
    // PUSH
    { name: "Développé couché à la barre", type: 'weighted', coefficient: 1.0, targetPerf: { load: 2.1, reps: 5 }, groups: { pecs: 0.6, epaules: 0.25, triceps: 0.15 } },
    { name: "Développé incliné à la barre", type: 'weighted', coefficient: 0.9, targetPerf: { load: 1.75, reps: 5 }, groups: { pecs: 0.7, epaules: 0.3 } },
    { name: "Développé décliné à la barre", type: 'weighted', coefficient: 1.05, targetPerf: { load: 2.2, reps: 5 }, groups: { pecs: 0.8, triceps: 0.2 } },
    { name: "Développé couché aux haltères", type: 'weighted', bilateral: true, coefficient: 0.9, targetPerf: { load: 0.9, reps: 6 }, groups: { pecs: 0.6, epaules: 0.25, triceps: 0.15 } },
    { name: "Développé incliné aux haltères", type: 'weighted', bilateral: true, coefficient: 0.8, targetPerf: { load: 0.8, reps: 6 }, groups: { pecs: 0.7, epaules: 0.3 } },
    { name: "Développé décliné aux haltères", type: 'weighted', bilateral: true, coefficient: 0.95, targetPerf: { load: 0.95, reps: 6 }, groups: { pecs: 0.8, triceps: 0.2 } },
    { name: "Développé militaire à la barre", type: 'weighted', coefficient: 0.7, targetPerf: { load: 1.4, reps: 5 }, groups: { epaules: 0.8, triceps: 0.2 } },
    { name: "Développé militaire aux haltères", type: 'weighted', bilateral: true, coefficient: 0.65, targetPerf: { load: 0.7, reps: 6 }, groups: { epaules: 1.0 } },
    { name: "Développé militaire à la machine", type: 'weighted', coefficient: 0.65, targetPerf: { load: 1.55, reps: 8 }, groups: { epaules: 1.0 } },
    { name: "Développé Arnold", type: 'weighted', bilateral: true, coefficient: 0.6, targetPerf: { load: 0.65, reps: 8 }, groups: { epaules: 1.0 } },
    { name: "Dips", type: 'bodyweight', pdcPercent: 0.9, coefficient: 1.1, targetPerf: { load: 1.0, reps: 25 }, groups: { pecs: 0.4, triceps: 0.5, epaules: 0.1 } },
    { name: "Pompes", type: 'bodyweight', pdcPercent: 0.65, coefficient: 0.8, targetPerf: { load: 0.8, reps: 50 }, groups: { pecs: 0.6, triceps: 0.3, epaules: 0.1 } },
    { name: "Pompes déclinées", type: 'bodyweight', pdcPercent: 0.7, coefficient: 0.7, targetPerf: { load: 0.5, reps: 40 }, groups: { pecs: 0.7, triceps: 0.2, epaules: 0.1 } },
    { name: "Pompes inclinées", type: 'bodyweight', pdcPercent: 0.6, coefficient: 0.6, targetPerf: { load: 0.4, reps: 60 }, groups: { pecs: 0.8, triceps: 0.2 } },
    { name: "Pompes diamant", type: 'bodyweight', pdcPercent: 0.6, coefficient: 0.75, targetPerf: { load: 0.6, reps: 35 }, groups: { triceps: 0.7, pecs: 0.3 } },
    { name: "Skull crusher", type: 'weighted', bilateral: true, coefficient: 0.5, targetPerf: { load: 0.8, reps: 8 }, groups: { triceps: 1.0 } },
    { name: "Extension triceps poulie haute", type: 'weighted', coefficient: 0.4, targetPerf: { load: 0.75, reps: 10 }, groups: { triceps: 1.0 } },
    { name: "Écarté couché aux haltères", type: 'weighted', bilateral: true, coefficient: 0.45, targetPerf: { load: 0.42, reps: 12 }, groups: { pecs: 1.0 } },
    { name: "Papillon (Peck-deck)", type: 'weighted', coefficient: 0.6, targetPerf: { load: 1.4, reps: 10 }, groups: { pecs: 1.0 } },
    { name: "Élévation latérale aux haltères", type: 'weighted', bilateral: true, coefficient: 0.4, targetPerf: { load: 0.36, reps: 12 }, groups: { epaules: 1.0 } },
    // PULL
    { name: "Soulevé de terre", type: 'weighted', coefficient: 1.25, targetPerf: { load: 3.2, reps: 3 }, groups: { dos: 0.6, jambes: 0.4 } },
    { name: "Tractions pronation", type: 'bodyweight', pdcPercent: 0.95, coefficient: 1.2, targetPerf: { load: 0.7, reps: 25 }, groups: { dos: 0.8, biceps: 0.2 } },
    { name: "Tractions supination", type: 'bodyweight', pdcPercent: 0.95, coefficient: 1.2, targetPerf: { load: 0.8, reps: 25 }, groups: { dos: 0.6, biceps: 0.4 } },
    { name: "Muscle Up", type: 'bodyweight', pdcPercent: 1.1, coefficient: 1.5, targetPerf: { load: 0.45, reps: 15 }, groups: { dos: 0.5, epaules: 0.2, triceps: 0.2, pecs: 0.1 } },
    { name: "Rowing barre buste penché", type: 'weighted', coefficient: 0.9, targetPerf: { load: 2.1, reps: 8 }, groups: { dos: 0.85, biceps: 0.15 } },
    { name: "Rowing T-bar", type: 'weighted', coefficient: 0.95, targetPerf: { load: 2.0, reps: 8 }, groups: { dos: 0.9, biceps: 0.1 } },
    { name: "Rowing haltères unilatéral", type: 'weighted', coefficient: 0.85, targetPerf: { load: 1.1, reps: 8 }, groups: { dos: 0.9, biceps: 0.1 } },
    { name: "Tirage vertical", type: 'weighted', coefficient: 0.8, targetPerf: { load: 1.7, reps: 8 }, groups: { dos: 0.8, biceps: 0.2 } },
    { name: "Tirage horizontal", type: 'weighted', coefficient: 0.75, targetPerf: { load: 1.6, reps: 10 }, groups: { dos: 0.8, biceps: 0.2 } },
    { name: "Curl barre EZ", type: 'weighted', coefficient: 0.4, targetPerf: { load: 0.9, reps: 8 }, groups: { biceps: 1.0 } },
    { name: "Curl haltères", type: 'weighted', bilateral: true, coefficient: 0.45, targetPerf: { load: 0.42, reps: 8 }, groups: { biceps: 1.0 } },
    { name: "Face pull", type: 'weighted', coefficient: 0.3, targetPerf: { load: 0.7, reps: 15 }, groups: { epaules: 0.7, dos: 0.3 } },
    { name: "Shrug", type: 'weighted', bilateral: true, coefficient: 1.1, targetPerf: { load: 2.7, reps: 12 }, groups: { dos: 1.0 } },
    // LEGS
    { name: "Soulevé de terre jambes tendues aux haltères", type: 'weighted', bilateral: true, coefficient: 0.9, targetPerf: { load: 0.9, reps: 6 }, groups: { jambes: 0.7, dos: 0.3 } },
    { name: "Soulevé de terre jambes tendues", type: 'weighted', coefficient: 0.9, targetPerf: { load: 2.0, reps: 8 }, groups: { jambes: 0.7, dos: 0.3 } },
    { name: "Squat à la barre", type: 'weighted', coefficient: 1.2, targetPerf: { load: 2.6, reps: 5 }, groups: { jambes: 1.0 } },
    { name: "Squat au poids du corps", type: 'bodyweight', pdcPercent: 1.0, coefficient: 0.8, targetPerf: { load: 0.8, reps: 60 }, groups: { jambes: 1.0 } },
    { name: "Front squat", type: 'weighted', coefficient: 1.0, targetPerf: { load: 2.3, reps: 5 }, groups: { jambes: 1.0 } },
    { name: "Presse à cuisse", type: 'weighted', coefficient: 1.8, targetPerf: { load: 5.7, reps: 10 }, groups: { jambes: 1.0 } },
    { name: "Hack squat", type: 'weighted', coefficient: 1.6, targetPerf: { load: 3.4, reps: 8 }, groups: { jambes: 1.0 } },
    { name: "Fentes", type: 'bodyweight', bilateral: true, pdcPercent: 0.8, coefficient: 0.7, targetPerf: { load: 0.9, reps: 25 }, groups: { jambes: 1.0 } },
    { name: "Leg extension", type: 'weighted', coefficient: 0.6, targetPerf: { load: 1.55, reps: 12 }, groups: { jambes: 1.0 } },
    { name: "Hip thrust à la barre", type: 'weighted', coefficient: 1.5, targetPerf: { load: 3.5, reps: 10 }, groups: { jambes: 1.0 } },
    { name: "Extension mollets", type: 'weighted', coefficient: 0.8, targetPerf: { load: 2.8, reps: 15 }, groups: { jambes: 1.0 } },
    // CORE & OTHER
    { name: "Crunch à la poulie", type: 'weighted', coefficient: 0.4, targetPerf: { load: 1.2, reps: 15 }, groups: { abdos: 1.0 } },
    { name: "Relevé de jambes suspendu", type: 'bodyweight', pdcPercent: 0.15, coefficient: 0.7, targetPerf: { load: 0.25, reps: 30 }, groups: { abdos: 1.0 } },
    { name: "Gainage", type: 'timed', pdcPercent: 1.0, coefficient: 1.0, targetPerf: { reps: 480 }, groups: { abdos: 0.8, dos: 0.2 } },
    { name: "Farmer’s walk", type: 'timed', bilateral: true, coefficient: 1.1, targetPerf: { load: 1.45, reps: 90 }, groups: { dos: 0.5, jambes: 0.3, epaules: 0.2 } },
];

            EXERCISE_DATABASE.length = 0;

            const bodyweightForTargetCalc = 80;

            exerciseList.forEach((exo, index) => {
                const targetCharge = (exo.targetPerf.load || 0) * (exo.type.includes('bodyweight') ? 1 : bodyweightForTargetCalc);
                const targetScore = calculatePerformanceScore({
                    type: exo.type, charge: targetCharge, reps: exo.targetPerf.reps,
                    poidsDuCorps: bodyweightForTargetCalc, coefficient: exo.coefficient,
                    pdcPercent: exo.pdcPercent || 0,
                });
                EXERCISE_DATABASE.push({
                    id: `ex${String(index + 1).padStart(3, '0')}`, name: exo.name, type: exo.type,
                    coefficient: exo.coefficient, pdcPercent: exo.pdcPercent || 0,
                    targetScore: targetScore, groups: exo.groups || [],
                    bilateral: exo.bilateral || false
                });
            });
        }

        function animateCounter(element, start, end, duration) {
    if (!element) return;
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        const currentValue = Math.floor(progress * (end - start) + start);
        element.textContent = currentValue.toLocaleString('fr-FR'); // Ajoute les séparateurs de milliers
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    };
    window.requestAnimationFrame(step);
}

        function initializeTags() {
    // Tags par défaut pour les séances
    if (state.workoutTags.length === 0) {
        state.workoutTags = [
            { id: generateId(), name: 'Push', color: '#F87171' },
            { id: generateId(), name: 'Pull', color: '#60A5FA' },
            { id: generateId(), name: 'Legs', color: '#34D399' },
            { id: generateId(), name: 'Upper', color: '#FBBF24' },
            { id: generateId(), name: 'Lower', color: '#A78BFA' },
            { id: generateId(), name: 'Full Body', color: '#EC4899' },
        ];
    }
    // Tags par défaut pour les repas
    if (state.mealTags.length === 0) {
        state.mealTags = [
            { id: generateId(), name: 'Petit-Déjeuner', color: '#FBBF24' },
            { id: generateId(), name: 'Déjeuner', color: '#34D399' },
            { id: generateId(), name: 'Dîner', color: '#60A5FA' },
            { id: generateId(), name: 'Collation', color: '#A78BFA' },
        ];
    }
}

function getClaimableRewardsCount(achievementId = null) {
    let claimableCount = 0;
    const achievementsToScan = achievementId 
        ? [ACHIEVEMENTS_DATABASE.find(a => a.id === achievementId)] 
        : ACHIEVEMENTS_DATABASE;

    for (const ach of achievementsToScan) {
        if (!ach) continue;
        
        const achData = state.userProfile.achievements[ach.id] || { progress: 0, claimedTiers: [] };
        const currentValue = achData.progress;
        const claimedTiers = achData.claimedTiers;

        ach.tiers.forEach((tier, index) => {
            const isUnlocked = currentValue >= tier.goal;
            const isClaimed = claimedTiers.includes(index);

            if (isUnlocked && !isClaimed) {
                claimableCount++;
            }
        });
    }
    return claimableCount;
}

function getBodyweightBracket(bodyweight, standardsDb) {
    const brackets = Object.keys(standardsDb).map(Number).sort((a, b) => a - b);
    if (brackets.length === 0) return null;

    let selectedBracket = brackets[0];
    for (const bracket of brackets) {
        if (bodyweight >= bracket) {
            selectedBracket = bracket;
        } else {
            break;
        }
    }
    return standardsDb[selectedBracket];
}

/**
 * Le Moteur de Validation. Analyse une performance SBD et retourne son statut.
 * @param {object} performance - L'objet de la performance (ex: { liftType: 'bench', weight: 140 }).
 * @param {object} user - L'objet de l'utilisateur (ex: { sex: 'Homme', bodyweight: 85 }).
 * @returns {object} Un objet avec le statut et la méthode de validation (ex: { status: 'pending_sponsor', method: 'sponsor' }).
 */
function validateSBDPerformance(performance, user) {
    const { liftType, weight } = performance;
    const { sex, bodyweight } = user;

    // Étape 1 : Définir le seuil "Impossible" (basé sur les records + 5%)
    const eliteStandardsForSex = POWERLIFTING_STANDARDS[sex] || POWERLIFTING_STANDARDS['Homme'];
    const eliteBracket = getBodyweightBracket(bodyweight, eliteStandardsForSex);
    const impossibleThreshold = (eliteBracket?.[liftType]?.impossible || 999) * 1.05;

    // Étape 2 : Définir le seuil de "Confiance" (basé sur la communauté)
    // Pour l'instant, on utilise la base de données de démarrage. Plus tard, on pourra la remplacer
    // par les données calculées par la Cloud Function.
    const communityStandardsForSex = INITIAL_COMMUNITY_STANDARDS[sex] || INITIAL_COMMUNITY_STANDARDS['Homme'];
    const communityBracket = getBodyweightBracket(bodyweight, communityStandardsForSex);
    const trustThreshold = communityBracket?.[liftType] || 999;

    // Étape 3 : Appliquer la logique de triage à 3 niveaux
    if (weight > impossibleThreshold) {
        return { status: 'rejected', method: 'automatic' }; // Zone de l'Impossible
    } else if (weight > trustThreshold) {
        return { status: 'pending_tribunal', method: 'tribunal' }; // Zone d'Excellence
    } else {
        return { status: 'verified', method: 'automatic' }; // Zone de Confiance
    }
}

function getAchievementProgressPercent(achievement) {
    if (!achievement || !achievement.tiers || achievement.tiers.length === 0) return 0;

    const achData = state.userProfile.achievements[achievement.id] || { progress: 0 };
    const currentValue = achData.progress;

    // Trouve le prochain palier que l'utilisateur n'a pas encore atteint
    const nextTier = achievement.tiers.find(tier => currentValue < tier.goal);

    // Si aucun prochain palier n'est trouvé, cela signifie que tout est terminé.
    if (!nextTier) {
        return 100;
    }

    // Trouve l'index du prochain palier pour déterminer le palier précédent.
    const nextTierIndex = achievement.tiers.indexOf(nextTier);
    const previousTierGoal = nextTierIndex > 0 ? achievement.tiers[nextTierIndex - 1].goal : 0;

    // Calcule la "tranche" de progression pour le palier actuel.
    const tierGoalRange = nextTier.goal - previousTierGoal;
    const progressInTier = currentValue - previousTierGoal;

    // Évite la division par zéro si un palier est mal configuré.
    if (tierGoalRange <= 0) return 0;

    const percentage = (progressInTier / tierGoalRange) * 100;

    return Math.min(100, Math.max(0, percentage)); // On s'assure que le résultat est entre 0 et 100.
}

function lightenColor(hex, percent) {
    let f = parseInt(hex.slice(1), 16),
        t = percent < 0 ? 0 : 255,
        p = percent < 0 ? percent * -1 : percent,
        R = f >> 16,
        G = f >> 8 & 0x00FF,
        B = f & 0x0000FF;
    return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}

function calculateGlobalRank(profileData = null) {
            if (typeof profileData === 'string') {
                const rankInfo = RANKS_DATABASE.find(r => r.name === profileData.split(' ')[0]);
                return {
                    globalRank: profileData,
                    globalRankColor: rankInfo ? rankInfo.color : RANK_COLORS['Novice'],
                    totalSr: 0 // On ne peut pas calculer le SR à partir d'une chaîne
                };
            }
            const userToEvaluate = profileData || state.userProfile;
            const practicedExercises = EXERCISE_DATABASE.filter(exo => state.exerciseStats[exo.id]);
            
            if (practicedExercises.length === 0) {
                // On retourne aussi le SR total dans le cas par défaut
                return { globalRank: 'N/A', globalRankColor: getRankColor('Novice'), totalSr: 0 };
            }

            // --- MODIFICATION APPLIQUÉE ICI ---
            // On utilise .reduce sur un objet pour calculer les points ET le sr en une seule passe
            const { totalPoints, totalSr } = practicedExercises.reduce((acc, exo) => {
                const score = state.exerciseStats[exo.id]?.rankPr?.score || 0;
                const rankInfo = getRankFromScore(score, exo.id);
                acc.totalPoints += rankInfo.points;
                acc.totalSr += rankInfo.sr; // On additionne le SR de chaque exercice
                return acc;
            }, { totalPoints: 0, totalSr: 0 }); // On initialise l'accumulateur avec les deux propriétés

            const avgPoints = Math.round(totalPoints / practicedExercises.length);
            const finalRankInfo = getRankFromPoints(avgPoints);
            
            // On ajoute totalSr à l'objet retourné
            return {
                globalRank: finalRankInfo.name,
                globalRankColor: getRankColor(finalRankInfo.baseName),
                totalSr: totalSr 
            };
            // --- FIN DE LA MODIFICATION ---
        }

function calculateAverageRank(membersList) {
    if (!membersList || membersList.length === 0) {
        return { averageRank: 'N/A', color: getRankColor('Novice').main };
    }

    const totalPoints = membersList.reduce((sum, member) => {
        // On récupère les points du rang de chaque membre.
        // Si le rang n'est pas valide, on utilise 0 points.
        return sum + (RANK_POINTS_MAP[member.globalRank] || 0);
    }, 0);

    const averagePoints = totalPoints / membersList.length;
    const { name: rankName, baseName: rankBaseName } = getRankFromPoints(Math.round(averagePoints));
    
    return {
        averageRank: rankName,
        color: getRankColor(rankBaseName).main
    };
}

function calculateComprehensiveAchievementScore(achievement) {
    if (!achievement || !achievement.tiers || achievement.tiers.length === 0) return 0;

    const achData = state.userProfile.achievements[achievement.id] || { progress: 0 };
    const currentValue = achData.progress;

    // 1. Compter combien de paliers sont entièrement complétés
    let tiersCompleted = 0;
    for (const tier of achievement.tiers) {
        if (currentValue >= tier.goal) {
            tiersCompleted++;
        } else {
            break; // On arrête dès qu'un palier n'est pas atteint
        }
    }

    // 2. Calculer le pourcentage de progression dans le palier actuel (similaire à votre ancienne fonction)
    let progressPercentInCurrentTier = 0;
    if (tiersCompleted < achievement.tiers.length) { // S'il reste des paliers à atteindre
        const nextTier = achievement.tiers[tiersCompleted];
        const previousTierGoal = tiersCompleted > 0 ? achievement.tiers[tiersCompleted - 1].goal : 0;
        
        const tierGoalRange = nextTier.goal - previousTierGoal;
        const progressInTier = currentValue - previousTierGoal;

        if (tierGoalRange > 0) {
            progressPercentInCurrentTier = (progressInTier / tierGoalRange) * 100;
        }
    } else {
        progressPercentInCurrentTier = 100; // Tous les paliers sont finis
    }

    // 3. Combiner les deux pour un score final
    // Chaque palier complété vaut 100 points, plus le pourcentage du palier en cours.
    const finalScore = (tiersCompleted * 100) + progressPercentInCurrentTier;
    
    return finalScore;
}

function getRewardText(reward) {
    if (!reward) return "Aucune récompense";

    switch(reward.type) {
        case 'coins':
            return `+ ${reward.amount} Pièces`;
        case 'title':
        case 'border':
        case 'collectible':
            // Pour tous les cosmétiques, on affiche un bouton de prévisualisation
            return `
                <span class="flex items-center gap-2">
                    <span>Cosmétique</span>
                    <button data-action="preview-reward" data-reward-type="${reward.type}" data-reward-id="${reward.id}" class="text-gray-400 hover:text-white transition-colors">
                        <i class="fa-solid fa-eye"></i>
                    </button>
                </span>
            `;
        default:
            return "Aucune récompense"; // Cas par défaut sécurisé
    }
}

function getEventsForDate(dateStr) {
    // 1. Priorité aux événements manuels
    const manualEvents = state.calendarEvents.filter(e => e.date === dateStr && e.type === state.activeSide);
    if (manualEvents.length > 0) {
        return manualEvents;
    }

    // 2. Sinon, on vérifie si la récurrence est active
    const settings = state.recurrence[state.activeSide];
    if (!settings.enabled || Object.keys(settings.template).length === 0) {
        return []; // Pas de récurrence active ou template vide
    }

    // 3. On calcule le jour correspondant dans le template
    const date = new Date(dateStr + 'T00:00:00');
    let dayKey;
    if (settings.period === 'week') {
        const dayOfWeek = date.getDay() === 0 ? 6 : date.getDay() - 1; // Lundi=0, Dimanche=6
        dayKey = `day_${dayOfWeek}`;
    } else { // 'month'
        // Calcul un peu plus complexe pour le mois de 28 jours
        const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
        const dayOfMonth = date.getDate() -1; // 0-indexed
        const dayIndexInTemplate = dayOfMonth % 28;
        dayKey = `day_${dayIndexInTemplate}`;
    }

    const templateItems = settings.template[dayKey] || [];
    if (templateItems.length === 0) {
        return [];
    }

    // 4. On crée des événements "virtuels" à partir du template
    return templateItems.map(item => {
        const originalItem = (item.type === 'workout' ? state.workouts : state.meals).find(i => i.id === item.refId);
        if (!originalItem) return null;

        return {
            id: `recur_${dateStr}_${item.refId}`, // ID unique pour l'événement virtuel
            date: dateStr,
            refId: item.refId,
            title: originalItem.name,
            type: item.type,
            time: '00:00', // On pourrait rendre ça configurable plus tard
            isFromRecurrence: true // Drapeau pour identifier ces événements
        };
    }).filter(Boolean); // On retire les éléments "null" si l'original a été supprimé
}

const WEIGHT_CLASSES = {
    Homme: [
        { name: 'Open (Tous poids)', key: 'open', range: [0, 999] },
        { name: '-59 kg', key: '59', range: [0, 59] },
        { name: '59-66 kg', key: '66', range: [59.01, 66] },
        { name: '66-74 kg', key: '74', range: [66.01, 74] },
        { name: '74-83 kg', key: '83', range: [74.01, 83] },
        { name: '83-93 kg', key: '93', range: [83.01, 93] },
        { name: '93-105 kg', key: '105', range: [93.01, 105] },
        { name: '105-120 kg', key: '120', range: [105.01, 120] },
        { name: '+120 kg', key: '120+', range: [120.01, 999] }
    ],
    Femme: [
        { name: 'Open (Tous poids)', key: 'open', range: [0, 999] },
        { name: '-47 kg', key: '47', range: [0, 47] },
        { name: '47-52 kg', key: '52', range: [47.01, 52] },
        { name: '52-57 kg', key: '57', range: [52.01, 57] },
        { name: '57-63 kg', key: '63', range: [57.01, 63] },
        { name: '63-69 kg', key: '69', range: [63.01, 69] },
        { name: '69-76 kg', key: '76', range: [69.01, 76] },
        { name: '76-84 kg', key: '84', range: [76.01, 84] },
        { name: '+84 kg', key: '84+', range: [84.01, 999] }
    ]
};

const POWERLIFTING_STANDARDS = {
    Homme: {
        // Catégorie -53 kg
        '1':   { squat: { impossible: 190 }, bench: { impossible: 140 }, deadlift: { impossible: 220 } },
        // Catégorie 53-59 kg
        '53':  { squat: { impossible: 210 }, bench: { impossible: 155 }, deadlift: { impossible: 240 } },
        // Catégorie 59-66 kg
        '59':  { squat: { impossible: 240 }, bench: { impossible: 300 }, deadlift: { impossible: 270 } },
        // Catégorie 66-74 kg
        '66':  { squat: { impossible: 270 }, bench: { impossible: 190 }, deadlift: { impossible: 300 } },
        // Catégorie 74-83 kg
        '74':  { squat: { impossible: 300 }, bench: { impossible: 210 }, deadlift: { impossible: 330 } },
        // Catégorie 83-93 kg
        '83':  { squat: { impossible: 330 }, bench: { impossible: 230 }, deadlift: { impossible: 360 } },
        // Catégorie 93-105 kg
        '93':  { squat: { impossible: 360 }, bench: { impossible: 250 }, deadlift: { impossible: 385 } },
        // Catégorie 105-120 kg
        '105': { squat: { impossible: 380 }, bench: { impossible: 260 }, deadlift: { impossible: 400 } },
        // Catégorie +120 kg
        '120': { squat: { impossible: 400 }, bench: { impossible: 270 }, deadlift: { impossible: 420 } }
    },
    Femme: {
        // Catégorie -43 kg
        '1':   { squat: { impossible: 100 }, bench: { impossible: 65 }, deadlift: { impossible: 130 } },
        // Catégorie 43-47 kg
        '43':  { squat: { impossible: 115 }, bench: { impossible: 75 }, deadlift: { impossible: 145 } },
        // Catégorie 47-52 kg
        '47':  { squat: { impossible: 130 }, bench: { impossible: 85 }, deadlift: { impossible: 160 } },
        // Catégorie 52-57 kg
        '52':  { squat: { impossible: 145 }, bench: { impossible: 95 }, deadlift: { impossible: 175 } },
        // Catégorie 57-63 kg
        '57':  { squat: { impossible: 160 }, bench: { impossible: 105 }, deadlift: { impossible: 190 } },
        // Catégorie 63-69 kg
        '63':  { squat: { impossible: 170 }, bench: { impossible: 110 }, deadlift: { impossible: 200 } },
        // Catégorie 69-76 kg
        '69':  { squat: { impossible: 180 }, bench: { impossible: 115 }, deadlift: { impossible: 210 } },
        // Catégorie 76-84 kg
        '76':  { squat: { impossible: 190 }, bench: { impossible: 120 }, deadlift: { impossible: 220 } },
        // Catégorie +84 kg
        '84':  { squat: { impossible: 200 }, bench: { impossible: 125 }, deadlift: { impossible: 230 } }
    }
};

const INITIAL_COMMUNITY_STANDARDS = {
    Homme: {
        '60': { bench: 90, squat: 120, deadlift: 150 },
        '70': { bench: 105, squat: 140, deadlift: 170 },
        '80': { bench: 120, squat: 160, deadlift: 200 },
        '90': { bench: 130, squat: 175, deadlift: 220 },
        '100': { bench: 140, squat: 185, deadlift: 235 },
        '110': { bench: 150, squat: 195, deadlift: 250 }
    },
    Femme: {
        '50': { bench: 50, squat: 70, deadlift: 90 },
        '60': { bench: 60, squat: 85, deadlift: 110 },
        '70': { bench: 70, squat: 95, deadlift: 125 },
        '80': { bench: 75, squat: 105, deadlift: 135 }
    }
};

const Phase_Schema = {
    id: "string", // ID unique pour la phase (ex: "phase_123")
    title: "string", // Ex: "Phase 1: Fondation Musculaire"
    goal: "string", // Description de l'objectif de cette phase
    weeks: [ /* Array of Week_Schema Objects */ ]
};

// --- Semaine (Ex: Semaine d'introduction) ---
const Week_Schema = {
    id: "string", // ID unique pour la semaine (ex: "week_456")
    title: "string", // Ex: "Semaine 1: Volume d'Accumulation"
    notes: "string", // Notes spécifiques pour la semaine (HTML supporté)
    days: [ /* Array of 7 Day_Schema Objects, un pour chaque jour */ ]
};

// --- Jour (Ex: Jour 1: Push) ---
const Day_Schema = {
    id: "string", // ID unique pour le jour (ex: "day_789")
    title: "string", // Ex: "Jour 1: Push" ou "Jour de Repos Actif"
    blocks: [ /* Array of ContentBlock_Schema Objects */ ]
};

// --- Le Bloc de Contenu : La brique fondamentale de votre éditeur ---
const ContentBlock_Schema = {
    id: "string", // ID unique pour le bloc (ex: "block_abc")
    
    // Le type de bloc détermine le contenu et l'affichage
    type: "workout" | "meal" | "text" | "video" | "image_gallery" | "table" |
          "exercise_focus" | "pr_challenge" | "sbd_validation" | 
          "checkpoint" | "quiz" | "poll",

    // Le contenu du bloc, qui varie selon son type
    content: {
        /* Exemples de contenu en fonction du type :
        
        // --- Blocs Actifs FitFlow ---
        case "workout":         { refId: "workoutId_123" } // Fait référence à un workout de la bibliothèque du créateur (utilise NEW_WORKOUT_SCHEMA)
        case "meal":            { refId: "mealId_456" } // Fait référence à un repas de la bibliothèque du créateur
        case "exercise_focus":  { exerciseId: "ex001", text: "Votre focus du jour sur le Développé Couché." }
        case "pr_challenge":    { exerciseId: "ex036", goal: { reps: 5, weight: 80 }, xpReward: 250 }
        case "sbd_validation":  { liftType: "squat", text: "Validez votre 1RM au Squat aujourd'hui." }

        // --- Blocs Pédagogiques ---
        case "text":            { html: "<p>Ceci est un <strong>texte riche</strong>.</p>" }
        case "video":           { url: "https://youtube.com/watch?v=...", caption: "Vidéo de démonstration." }
        case "image_gallery":   { images: [{url: "...", caption: "..."}, {url: "...", caption: "..."}] }
        case "table":           { headers: ['Jour', 'RPE Cible'], rows: [['Lundi', '7-8'], ['Mardi', '8-9']] }

        // --- Blocs Interactifs ---
        case "checkpoint":      { text: "Vous avez terminé la journée, bravo !", xpReward: 50 }
        case "quiz":            { question: "...", options: ["A", "B", "C"], correctIndex: 1, explanation: "..." }
        case "poll":            { question: "Comment vous sentez-vous ?", options: ["Fatigué", "En forme", "Énergisé"] }
        */
    }
};

const ProgramBlueprint_Schema = {
    // --- Informations Générales & Vente ---
    creatorId: "string",        // UID de l'utilisateur créateur
    creatorName: "string",      // Pseudo du créateur au moment de la publication
    version: "2.0",             // Version du schéma pour gérer les futures migrations
    status: "draft" | "published" | "archived", // Statut du programme sur la marketplace

    // --- Branding & Apparence ---
    title: "string",            // Titre marketing du programme
    description: "string",      // Description détaillée (supporte le HTML simple)
    bannerImageUrl: "string",   // URL de la bannière du programme
    themeColor: "string",       // Couleur hexadécimale (ex: "#A78BFA") pour l'ambiance
    
    // --- Métadonnées & Social ---
    price: "number",            // Prix en "pièces"
    type: "workout" | "nutrition" | "hybrid", // Type de programme
    ratingAverage: "number",    // Note moyenne (calculée)
    ratingCount: "number",      // Nombre de notes
    salesCount: "number",       // Nombre de ventes
    createdAt: "timestamp",
    updatedAt: "timestamp",

    // --- Le Cœur du Programme : Le Contenu Structuré ---
    // Remplace l'ancien 'programContent'. C'est un tableau de phases (mésocycles).
    content: [ /* Array of Phase_Schema Objects */ ] 
};

const NEW_WORKOUT_SCHEMA = {
    id: "string",
    name: "string",
    tags: ["tagId1"],
    isFavorite: false,
    // La propriété 'exercises' devient 'groups'
    groups: [
        {
            id: "groupId1",
            type: 'superset', // 'single', 'superset', 'triset', 'circuit'
            restBetweenExercises: 10, // Repos entre les exos A et B du superset (en secondes)
            restAfterGroup: 120,      // Repos après avoir terminé le groupe complet
            sets: 3,                  // Nombre de fois où l'on répète le groupe
            exercises: [
                {
                    exerciseId: 'ex001', // Développé couché
                    reps: '8-12',        // Fourchette de répétitions
                    load: 'RPE 8',       // Charge basée sur l'effort perçu
                    notes: "Contrôlez bien la descente."
                },
                {
                    exerciseId: 'ex012', // Pompes
                    reps: 'max',         // Répétitions jusqu'à l'échec
                    load: null,          // Pas de charge spécifiée (poids du corps)
                    notes: "Allez chercher la brûlure !"
                }
            ]
        },
        {
            id: "groupId2",
            type: 'single',
            restAfterGroup: 90,
            exercises: [
                {
                    exerciseId: 'ex017', // Extension triceps
                    notes: "Gardez les coudes serrés.",
                    // Les séries sont maintenant un tableau pour gérer les techniques avancées
                    sets: [
                        { type: 'normal', reps: 12, load: '20kg' },
                        { type: 'normal', reps: 10, load: '22.5kg' },
                        { 
                            type: 'dropset', 
                            reps: 'max', 
                            load: '25kg', 
                            drops: [
                                { load: '17.5kg', reps: 'max' },
                                { load: '12.5kg', reps: 'max' }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
};

/*
 * Sous-collection: `marketplace_programs/{programId}/reviews`
 * Description: Les avis pour un programme spécifique.
 */
const PROGRAM_REVIEW_SCHEMA = {
    userId: "string",
    userName: "string",
    userProfilePicUrl: "string",
    rating: "number",           // de 1 à 5
    comment: "string",
    createdAt: "timestamp"
};

/*
 * Sous-collection: `users/{userId}/purchases`
 * Description: Enregistre les programmes achetés par un utilisateur.
 * Le nom du document est l'ID du programme acheté pour une recherche facile.
 */
const USER_PURCHASE_SCHEMA = {
    programId: "string",
    programTitle: "string",
    purchaseDate: "timestamp",
    pricePaid: "number"
};

        const BORDERS_DATABASE = [
    /*================================*
     * 💎 COMMUNS 💎
     * (Styles simples, matériaux pleins et bruts)
     *================================*/
    { id: 'b001', name: 'Néant', rarity: 'Commun', cost: 0, style: 'border: 3px solid transparent;' },
    { id: 'b101', name: 'Acier', rarity: 'Commun', cost: 50, style: 'border: 3px solid #9CA3AF;' },
    { id: 'b103', name: 'Cuir', rarity: 'Commun', cost: 75, style: 'border: 4px solid #78350F;' },
    { id: 'b104', name: 'Béton', rarity: 'Commun', cost: 80, style: 'border: 4px solid #71717A;' },
    { id: 'b105', name: 'Chêne', rarity: 'Commun', cost: 70, style: 'border: 3px solid #A16207;' },
    { id: 'b107', name: 'Marbre', rarity: 'Commun', cost: 80, style: 'border: 3px solid #E5E7EB;' },
    { id: 'b108', name: 'Caoutchouc', rarity: 'Commun', cost: 50, style: 'border: 4px solid #3F3F46;' },
    { id: 'b110', name: 'Argile Rouge', rarity: 'Commun', cost: 55, style: 'border: 4px solid #B45309;' },
    { id: 'b112', name: 'Verre Fumé', rarity: 'Commun', cost: 90, style: 'border: 3px solid rgba(255,255,255,0.1);' },
    { id: 'b113', name: 'Brique', rarity: 'Commun', cost: 60, style: 'border: 4px solid #B91C1C;' },
    { id: 'b115', name: 'Grès Poli', rarity: 'Commun', cost: 85, style: 'border: 4px solid #F59E0B;' },
    { id: 'b116', name: 'Plastique Noir', rarity: 'Commun', cost: 40, style: 'border: 3px solid #1F2937;' },

    /*================================*
     * ✨ RARES ✨
     * (Couleurs vives et lueurs simples)
     *================================*/
    { id: 'b201', name: 'Lueur Électrique', rarity: 'Rare', cost: 300, style: 'border: 3px solid #60A5FA; box-shadow: 0 0 12px #3B82F6;' },
    { id: 'b202', name: 'Lueur de Circuit', rarity: 'Rare', cost: 350, style: 'border: 3px solid #10B981; box-shadow: 0 0 10px #10B981;' },
    { id: 'b207', name: 'Bronze Ancien', rarity: 'Rare', cost: 600, style: 'border: 3px solid #D97706; box-shadow: 0 0 8px #92400E;' },
    { id: 'b210', name: 'Néon Rose', rarity: 'Rare', cost: 580, style: 'border: 3px solid #EC4899; box-shadow: 0 0 12px #EC4899;' },
    { id: 'b212', name: 'Titane', rarity: 'Rare', cost: 650, style: 'border: 3px solid #D1D5DB; box-shadow: 0 0 8px #fff;' },
    { id: 'b213', name: 'Ambre Poli', rarity: 'Rare', cost: 620, style: 'border: 3px solid #F59E0B; box-shadow: 0 0 10px #F59E0B;' },
    { id: 'b214', name: 'Jade Impérial', rarity: 'Rare', cost: 680, style: 'border: 3px solid #34D399; box-shadow: 0 0 10px #10B981;' },
    { id: 'b216', name: 'Obsidienne', rarity: 'Rare', cost: 700, style: 'border: 3px solid #1E1B4B; box-shadow: 0 0 8px #4C1D95;' },
    { id: 'b217', name: 'Éclat de Rubis', rarity: 'Rare', cost: 720, style: 'border: 3px solid #E11D48; box-shadow: 0 0 12px #E11D48;' },
    { id: 'b218', name: 'Éclat de Saphir', rarity: 'Rare', cost: 720, style: 'border: 3px solid #2563EB; box-shadow: 0 0 12px #2563EB;' },
    { id: 'b220', name: 'Or Rose', rarity: 'Rare', cost: 680, style: 'border: 3px solid #F472B6; box-shadow: 0 0 10px #F9A8D4;' },
    { id: 'b222', name: 'Néon Toxique', rarity: 'Rare', cost: 580, style: 'border: 3px solid #84CC16; box-shadow: 0 0 12px #A3E635;' },
    { id: 'b225', name: 'Argent Massif', rarity: 'Rare', cost: 630, style: 'border: 3px solid #D1D5DB; box-shadow: 0 0 10px #9CA3AF;' },
    { id: 'b226', name: 'Cuivre Poli', rarity: 'Rare', cost: 610, style: 'border: 3px solid #F59E0B; box-shadow: 0 0 10px #D97706;' },

    /*================================*
     * 🔥 ÉPIQUES 🔥
     * (Animations de pulsation, dégradés simples, lueurs plus fortes)
     *================================*/
    { id: 'b301', name: 'Faille Numérique', rarity: 'Épique', cost: 800, style: 'border: 3px solid #A78BFA; animation: epic-glitch-aura 3s infinite steps(1);' },
    { id: 'b302', name: 'Cristal d\'Améthyste', rarity: 'Épique', cost: 900, style: 'border: 3px solid #C4B5FD; box-shadow: 0 0 20px 5px #A78BFA, inset 0 0 8px #A78BFA;' },
    { id: 'b305', name: 'Cœur de Magma', rarity: 'Épique', cost: 1400, style: 'border: 3px solid #F87171; animation: fiery-pulse 2s infinite;' },
    { id: 'b307', name: 'Aura Glaciale', rarity: 'Épique', cost: 1350, style: 'border: 3px solid #BFDBFE; box-shadow: 0 0 20px #60A5FA; animation: fiery-pulse 2.5s infinite;' },
    { id: 'b308', name: 'Scarabée Doré', rarity: 'Épique', cost: 1450, style: 'border: 4px solid #FACC15; box-shadow: 0 0 15px #F59E0B;' },
    { id: 'b315', name: 'Ectoplasme', rarity: 'Épique', cost: 1650, style: 'border: 3px solid #A3E635; box-shadow: 0 0 20px #A3E635, inset 0 0 8px #A3E635; animation: fiery-pulse 1.8s infinite;' },
    { id: 'b316', name: 'Impulsion Sonar', rarity: 'Épique', cost: 1100, style: 'border: 3px solid #06B6D4; box-shadow: 0 0 18px #06B6D4; animation: fiery-pulse 1.5s infinite;' },
    { id: 'b318', name: 'Vortex Binaire', rarity: 'Épique', cost: 1550, style: 'padding: 3px; border: none; background: conic-gradient(from 0deg, #10B981, #E5E7EB, #10B981); animation: spin 4s linear infinite;' },
    { id: 'b320', name: 'Aura Sacrée', rarity: 'Épique', cost: 1400, style: 'border: 3px solid #FBBF24; box-shadow: 0 0 20px #FBBF24; animation: fiery-pulse 2.2s infinite;' },
    { id: 'b322', name: 'Crépuscule', rarity: 'Épique', cost: 1200, style: 'padding: 3px; border: none; background: linear-gradient(135deg, #EC4899, #8B5CF6);' },
    // CORRIGÉ : Utilise une animation de dégradé qui reste pleine
    { id: 'b323', name: 'Aurore Boréale', rarity: 'Épique', cost: 1600, style: 'padding: 3px; border: none; background: linear-gradient(135deg, #10B981, #3B82F6, #8B5CF6); background-size: 300% 300%; animation: mythic-nebula-border 6s ease-in-out infinite;' },
    { id: 'b324', name: 'Flamme Froide', rarity: 'Épique', cost: 1500, style: 'border: 3px solid #60A5FA; box-shadow: 0 0 20px #60A5FA, inset 0 0 8px #1E3A8A;' },

    /*================================*
     * 🌟 LÉGENDAIRES 🌟
     * (Animations complexes, doubles lueurs, dégradés animés)
     *================================*/
    { id: 'b401', name: 'Aura Solaire', rarity: 'Légendaire', cost: 2000, style: 'border: 3px solid #FBBF24; animation: solar-flare-border 3s infinite ease-in-out;' },
    { id: 'b402', name: 'Rune Enflammée', rarity: 'Légendaire', cost: 2200, style: 'border: 3px solid #F59E0B; box-shadow: 0 0 15px #F59E0B, 0 0 25px #FBBF24, inset 0 0 5px #FBBF24; animation: fiery-pulse 1.5s infinite;' },
    { id: 'b404', name: 'Éclat de Titan', rarity: 'Légendaire', cost: 2400, style: 'border: 3px solid #FDE047; animation: solar-flare-border 2s infinite ease-in-out; filter: drop-shadow(0 0 12px #FDE047);' },
    { id: 'b405', name: 'Fureur d\'Arès', rarity: 'Légendaire', cost: 2600, style: 'border: 4px solid #DC2626; box-shadow: 0 0 25px #EF4444, inset 0 0 10px #991B1B; animation: fiery-pulse 0.8s infinite;' },
    { id: 'b407', name: 'Rempart du Valhalla', rarity: 'Légendaire', cost: 3500, style: 'border: 5px solid #ca8a04; box-shadow: 0 0 25px #facc15, inset 0 0 10px #facc15;' },
    // CORRIGÉ : Utilise une animation de dégradé qui reste pleine
    { id: 'b408', name: 'Sarcophage Doré', rarity: 'Légendaire', cost: 3800, style: 'padding: 4px; border: none; background: linear-gradient(160deg, #1E1B4B, #FDE047, #D97706, #1E1B4B); background-size: 400% 400%; animation: mythic-nebula-border 5s ease-in-out infinite; box-shadow: 0 0 15px #FDE047;' },
    { id: 'b410', name: 'Barrière Cybernétique', rarity: 'Légendaire', cost: 4200, style: 'border: 4px solid #3B82F6; box-shadow: 0 0 15px #fff, inset 0 0 12px #3B82F6, 0 0 25px #3B82F6; animation: epic-glitch-aura 5s infinite steps(1);' },
    { id: 'b412', name: 'Renaissance du Phoenix', rarity: 'Légendaire', cost: 3200, style: 'padding: 4px; border: none; background: linear-gradient(-45deg, #F87171, #F59E0B, #DC2626, #F87171); background-size: 400% 400%; animation: mythic-nebula-border 8s ease infinite; box-shadow: 0 0 20px #F97316;' },
    // CORRIGÉ : Rendu plus fiable avec un fond animé plutôt qu'une `border-image`
    { id: 'b413', name: 'Cœur de la Forge', rarity: 'Légendaire', cost: 3600, style: 'padding: 4px; border: none; background: linear-gradient(0deg, #DC2626, #F59E0B, #F87171, #DC2626); background-size: 100% 400%; animation: mythic-nebula-border 4s ease-in-out infinite; box-shadow: 0 0 20px #F87171;' },
    { id: 'b414', name: 'Tempête Arcanique', rarity: 'Légendaire', cost: 3900, style: 'border: 3px solid #A78BFA; box-shadow: 0 0 25px #A78BFA, 0 0 40px #6366F1; animation: spin 5s linear infinite, fiery-pulse 2s infinite;' },
    { id: 'b418', name: 'Givre Infernal', rarity: 'Légendaire', cost: 3700, style: 'border: 3px solid #60A5FA; box-shadow: 0 0 25px #DC2626, inset 0 0 10px #1E1B4B; animation: fiery-pulse 1.2s infinite;' },
    { id: 'b419', name: 'Rage Écarlate', rarity: 'Légendaire', cost: 4500, style: 'border: 4px solid #ff0000; box-shadow: 0 0 30px #ff0000, 0 0 15px #ff4d4d; animation: fiery-pulse 0.7s infinite;' },
    
    /*================================*
     * 🌌 MYTHIQUES 🌌
     * (Effets cosmiques, dégradés multicolores, animations puissantes)
     *================================*/
    { id: 'b501', name: 'Nébuleuse Astrale', rarity: 'Mythique', cost: 5000, style: 'padding: 4px; border: none; background: linear-gradient(60deg, #6366F1, #EC4899, #8B5CF6, #06B6D4); background-size: 300% 300%; animation: mythic-nebula-border 6s ease-in-out infinite;' },
    { id: 'b503', name: 'Couronne de Titan', rarity: 'Mythique', cost: 8000, style: 'padding: 4px; border: none; background: linear-gradient(120deg, #FDE047, #FBBF24, #D97706, #FDE047); background-size: 300% 300%; animation: mythic-nebula-border 5s ease-in-out infinite; box-shadow: 0 0 25px #FDE047;' },
    { id: 'b504', name: 'Sceau Olympien', rarity: 'Mythique', cost: 8500, style: 'border: 4px solid #FDE047; box-shadow: 0 0 30px #FDE047, 0 0 45px #fff; animation: solar-flare-border 3s infinite;' },
    { id: 'b505', name: 'Fissure du Néant', rarity: 'Mythique', cost: 9000, style: 'border: 4px solid #4C1D95; box-shadow: 0 0 35px #A78BFA, inset 0 0 18px #000, 0 0 55px #000; animation: fiery-pulse 3s infinite;' },
    { id: 'b507', name: 'Pont du Bifrost', rarity: 'Mythique', cost: 12000, style: 'padding: 4px; border: none; background: linear-gradient(90deg, #EF4444, #F97316, #EAB308, #84CC16, #22C55E, #14B8A6, #06B6D4, #3B82F6, #8B5CF6, #D946EF); background-size: 2000% 2000%; animation: mythic-nebula-border 15s ease infinite;' },
    { id: 'b511', name: 'Cœur de Supernova', rarity: 'Mythique', cost: 13500, style: 'border: 4px solid #fff; box-shadow: 0 0 20px #fff, 0 0 35px #FDE047, 0 0 55px #F59E0B; animation: solar-flare-border 1.5s infinite;' },
    { id: 'b512', name: 'Singularité', rarity: 'Mythique', cost: 9500, style: 'border: 4px solid #111827; box-shadow: 0 0 25px #A78BFA, inset 0 0 20px #4C1D95; animation: spin 20s linear infinite reverse, fiery-pulse 2.8s infinite;' },
    { id: 'b513', name: 'Rage Solaire', rarity: 'Mythique', cost: 12500, style: 'border: 3px solid #F59E0B; box-shadow: 0 0 35px #F59E0B, 0 0 55px #FBBF24, 0 0 80px #ff0000; animation: solar-flare-border 1.5s infinite;' },
    { id: 'b514', name: 'Faille Infernale', rarity: 'Mythique', cost: 14000, style: 'padding: 4px; border:none; background: linear-gradient(0deg, #991B1B, #DC2626, #F87171, #FCA5A5); background-size: 100% 400%; animation: flame-border-animation 2s linear infinite; box-shadow: 0 0 30px #ff0000;' },
    // CORRIGÉ : Remplacé par une bordure pleine et animée
    { id: 'b515', name: 'Hyperdrive', rarity: 'Mythique', cost: 16000, style: 'padding: 4px; border: none; background: conic-gradient(from 0deg, #fff, #60A5FA, #A78BFA, #fff); animation: spin 0.8s linear infinite; box-shadow: 0 0 30px #fff;' },
    { id: 'b508', name: 'Volonté du Primordial', rarity: 'Mythique', cost: 15000, style: 'border: 4px solid #111; box-shadow: 0 0 20px #f00, 0 0 30px #ff0, 0 0 40px #0f0, 0 0 50px #0ff, 0 0 60px #00f, 0 0 70px #f0f; animation: primordial-will-border 5s linear infinite;' },

    /*================================*
     * 🔱 DIVINS 🔱
     * (Le summum : animations et lueurs combinées, prestige ultime)
     *================================*/
    { id: 'b601', name: 'Aura Céleste', rarity: 'Divin', cost: 20000, style: 'border: 3px solid #fff; animation: celestial-aura-border 3s ease-in-out infinite;' },
    { id: 'b603', name: 'Trône Divin', rarity: 'Divin', cost: 50000, style: 'border: 4px solid #FDE047; box-shadow: 0 0 35px #fff, 0 0 55px #FDE047, inset 0 0 25px #FBBF24; animation: solar-flare-border 2s infinite;' },
    { id: 'b604', name: 'Manifestation de l\'Aether', rarity: 'Divin', cost: 30000, style: 'border: 4px solid rgba(255,255,255,0.8); box-shadow: 0 0 40px #fff, inset 0 0 25px #E0F2FE; animation: celestial-aura-border 2s ease-in-out infinite;' },
    { id: 'b605', name: 'Apocalypse', rarity: 'Divin', cost: 60000, style: 'padding: 4px; border: none; background: linear-gradient(45deg, #111827, #ff0000, #F59E0B, #ff0000, #111827); background-size: 400%; animation: mythic-nebula-border 5s ease-in-out infinite; box-shadow: 0 0 50px #ff0000; ' },
    { id: 'b606', name: 'Réalité Fracturée', rarity: 'Divin', cost: 75000, style: 'border: 3px solid #EC4899; animation: epic-glitch-aura 1s infinite steps(1), spin 30s linear infinite; box-shadow: 0 0 40px #EC4899;' },
    { id: 'b608', name: 'Panthéon', rarity: 'Divin', cost: 25000, style: 'border: 5px solid #FDE047; background: #111827; box-shadow: inset 0 0 15px #FBBF24, 0 0 25px #FDE047; animation: solar-flare-border 3s infinite;' },
    { id: 'b610', name: 'Création', rarity: 'Divin', cost: 100000, style: 'padding: 4px; border: none; background: white; animation: primordial-will-border 2s linear infinite;' },
    { id: 'b611', name: 'Aura Spectrale', rarity: 'Divin', cost: 85000, style: 'padding: 4px; border:none; background: linear-gradient(90deg, #EF4444, #F97316, #EAB308, #84CC16, #22C55E, #14B8A6, #06B6D4, #3B82F6, #8B5CF6, #D946EF); background-size: 2000% 2000%; animation: mythic-nebula-border 10s ease infinite; box-shadow: 0 0 30px #fff;' },

    // ... (après les bordures Divines existantes)
    // --- Bordures de Succès Secrètes ---
    { id: 'b_titan', name: 'Force de Titan', rarity: 'Épique', source: 'achievement', style: 'border: 4px solid #F59E0B; box-shadow: 0 0 15px #F59E0B;' },
    { id: 'b_flamme', name: 'Flamme de la Détermination', rarity: 'Rare', source: 'achievement', style: 'border: 3px solid #F97316; box-shadow: 0 0 12px #F97316;' },
    { id: 'b_eternelle', name: 'Flamme Éternelle', rarity: 'Légendaire', source: 'achievement', style: 'padding: 4px; border: none; background: linear-gradient(-45deg, #F87171, #F59E0B, #DC2626, #F87171); background-size: 400% 400%; animation: mythic-nebula-border 8s ease infinite; box-shadow: 0 0 20px #F97316;' },
    { id: 'b_heavy', name: 'Rempart des Titans', rarity: 'Légendaire', source: 'achievement', style: 'border: 5px solid #ca8a04; box-shadow: 0 0 25px #facc15, inset 0 0 10px #facc15;' },
    { id: 'b_collector_ultimate', name: 'Cadre du Collectionneur', rarity: 'Mythique', source: 'achievement', style: 'padding: 4px; border: none; background: linear-gradient(90deg, #EF4444, #F97316, #EAB308, #84CC16, #22C55E, #14B8A6, #06B6D4, #3B82F6, #8B5CF6, #D946EF); background-size: 2000% 2000%; animation: mythic-nebula-border 15s ease infinite;' },
    { id: 'b_infinity', name: 'Bordure de l\'Infini', rarity: 'Divin', source: 'achievement', style: 'border: 3px solid #fff; animation: celestial-aura-border 3s ease-in-out infinite;' }

];
        
        // La liste TITLES_DATABASE n'a pas besoin de changer.

        const COLLECTIBLES_DATABASE = [
    // Communs
    { id: 'c001', name: 'Haltère Standard', rarity: 'Commun', icon: 'fa-dumbbell', color: 'text-gray-400' },
    { id: 'c002', name: 'Shaker de Protéine', rarity: 'Commun', icon: 'fa-bottle-water', color: 'text-gray-400' },
    { id: 'c101', name: 'Corde à Sauter', rarity: 'Commun', icon: 'fa-infinity', color: 'text-gray-400' },
    { id: 'c102', name: 'Disque de Fonte', rarity: 'Commun', icon: 'fa-compact-disc', color: 'text-gray-400' },
    { id: 'c103', name: 'Chronomètre', rarity: 'Commun', icon: 'fa-stopwatch', color: 'text-gray-400' },
    { id: 'c104', name: 'Bandeau de Sueur', rarity: 'Commun', icon: 'fa-head-side-virus', color: 'text-gray-400' },
    { id: 'c105', name: 'Pomme', rarity: 'Commun', icon: 'fa-apple-whole', color: 'text-gray-400' },
    { id: 'c106', name: 'Bouteille d\'Eau', rarity: 'Commun', icon: 'fa-glass-water', color: 'text-gray-400' },
    { id: 'c107', name: 'Cadenas', rarity: 'Commun', icon: 'fa-lock', color: 'text-gray-400' },
    { id: 'c108', name: 'T-Shirt', rarity: 'Commun', icon: 'fa-shirt', color: 'text-gray-400' },
    { id: 'c109', name: 'Magnésie', rarity: 'Commun', icon: 'fa-hand-sparkles', color: 'text-gray-400' },
    { id: 'c111', name: 'Casquette', rarity: 'Commun', icon: 'fa-hat-cowboy', color: 'text-gray-400' },
    { id: 'c112', name: 'Gourde', rarity: 'Commun', icon: 'fa-flask', color: 'text-gray-400' },
    { id: 'c113', name: 'Mètre Ruban', rarity: 'Commun', icon: 'fa-ruler-horizontal', color: 'text-gray-400' },
    // == NOUVEAUX AJOUTS ==
    { id: 'c114', name: 'Écouteurs', rarity: 'Commun', icon: 'fa-headphones', color: 'text-gray-400' },
    { id: 'c115', name: 'Carnet', rarity: 'Commun', icon: 'fa-book', color: 'text-gray-400' },
    { id: 'c117', name: 'Poignée de main', rarity: 'Commun', icon: 'fa-handshake', color: 'text-gray-400' },
    { id: 'c118', name: 'Pouce levé', rarity: 'Commun', icon: 'fa-thumbs-up', color: 'text-gray-400' },
    { id: 'c119', name: 'Cible d\'entraînement', rarity: 'Commun', icon: 'fa-bullseye', color: 'text-gray-400' },
    { id: 'c120', name: 'Banc de Musculation', rarity: 'Commun', icon: 'fa-chair', color: 'text-gray-400' },
    { id: 'c121', name: 'Barre Protéinée', rarity: 'Commun', icon: 'fa-candy-cane', color: 'text-gray-400' },
    { id: 'c122', name: 'Rouleau de Massage', rarity: 'Commun', icon: 'fa-grip-lines', color: 'text-gray-400' },
    { id: 'c123', name: 'Café', rarity: 'Commun', icon: 'fa-coffee', color: 'text-gray-400' },
    { id: 'c124', name: 'Sac de Sport', rarity: 'Commun', icon: 'fa-briefcase', color: 'text-gray-400' },
    { id: 'c125', name: 'Podomètre', rarity: 'Commun', icon: 'fa-shoe-prints', color: 'text-gray-400' },
    { id: 'c126', name: 'Calendrier', rarity: 'Commun', icon: 'fa-calendar-alt', color: 'text-gray-400' },
    { id: 'c127', name: 'Échelle', rarity: 'Commun', icon: 'fa-stairs', color: 'text-gray-400' },
    { id: 'c128', name: 'Brocoli', rarity: 'Commun', icon: 'fa-carrot', color: 'text-gray-400' },

    // Rares
    { id: 'c003', name: 'Kettlebell en Feu', rarity: 'Rare', icon: 'fa-fire', color: 'text-orange-500', effect: 'icon-glow-rare' },
    { id: 'c201', name: 'Haltère Doré', rarity: 'Rare', icon: 'fa-dumbbell', color: 'text-yellow-500', effect: 'icon-glow-rare' },
    { id: 'c202', name: 'Barres en Diamant', rarity: 'Rare', icon: 'fa-gem', color: 'text-sky-400', effect: 'icon-glow-rare' },
    { id: 'c203', name: 'Toison d\'Or', rarity: 'Rare', icon: 'fa-award', color: 'text-amber-400', effect: 'icon-glow-rare' },
    { id: 'c204', name: 'Hache de Viking', rarity: 'Rare', icon: 'fa-gavel', color: 'text-stone-400', effect: 'icon-glow-rare' },
    { id: 'c205', name: 'Heaume de Spartiate', rarity: 'Rare', icon: 'fa-shield-halved', color: 'text-amber-600', effect: 'icon-glow-rare' },
    { id: 'c206', name: 'Gant de Boxe', rarity: 'Rare', icon: 'fa-hand-fist', color: 'text-red-600', effect: 'icon-glow-rare' },
    // == NOUVEAUX AJOUTS ==
    { id: 'c207', name: 'Casque de Centurion', rarity: 'Rare', icon: 'fa-helmet-safety', color: 'text-amber-500', effect: 'icon-glow-rare' },
    { id: 'c208', name: 'Sandales d\'Hermès', rarity: 'Rare', icon: 'fa-shoe-prints', color: 'text-sky-400', effect: 'icon-glow-rare' },
    { id: 'c209', name: 'Ancre Marine', rarity: 'Rare', icon: 'fa-anchor', color: 'text-blue-500', effect: 'icon-glow-rare' },
    { id: 'c210', name: 'Empreinte Bestiale', rarity: 'Rare', icon: 'fa-paw', color: 'text-yellow-600', effect: 'icon-glow-rare' },
    { id: 'c211', name: 'Flamme', rarity: 'Rare', icon: 'fa-fire-flame-simple', color: 'text-red-500', effect: 'icon-glow-rare' },
    { id: 'c212', name: 'Flocon de Neige', rarity: 'Rare', icon: 'fa-snowflake', color: 'text-cyan-300', effect: 'icon-glow-rare' },
    { id: 'c213', name: 'Feuille d\'Érable', rarity: 'Rare', icon: 'fa-canadian-maple-leaf', color: 'text-red-600', effect: 'icon-glow-rare' },
    { id: 'c214', name: 'Steak', rarity: 'Rare', icon: 'fa-drumstick-bite', color: 'text-orange-700', effect: 'icon-glow-rare' },
    { id: 'c215', name: 'Yin Yang', rarity: 'Rare', icon: 'fa-yin-yang', color: 'text-white', effect: 'icon-glow-rare' },
    { id: 'c216', name: 'Cœur Musclé', rarity: 'Rare', icon: 'fa-heart-pulse', color: 'text-red-400', effect: 'icon-glow-rare' },
    { id: 'c217', name: 'Éclair', rarity: 'Rare', icon: 'fa-bolt', color: 'text-yellow-400', effect: 'icon-glow-rare' },
    { id: 'c218', name: 'Biohazard', rarity: 'Rare', icon: 'fa-biohazard', color: 'text-green-500', effect: 'icon-glow-rare' },
    { id: 'c219', name: 'Cerveau en Action', rarity: 'Rare', icon: 'fa-brain', color: 'text-pink-400', effect: 'icon-glow-rare' },
    { id: 'c220', name: 'Montagne', rarity: 'Rare', icon: 'fa-mountain', color: 'text-stone-400', effect: 'icon-glow-rare' },
    { id: 'c221', name: 'Trophée', rarity: 'Rare', icon: 'fa-trophy', color: 'text-yellow-400', effect: 'icon-glow-rare' },
    { id: 'c222', name: 'Fusée', rarity: 'Rare', icon: 'fa-rocket', color: 'text-orange-400', effect: 'icon-glow-rare' },
    { id: 'c223', name: 'Piment', rarity: 'Rare', icon: 'fa-pepper-hot', color: 'text-red-600', effect: 'icon-glow-rare' },
    { id: 'c224', name: 'Aimant', rarity: 'Rare', icon: 'fa-magnet', color: 'text-red-500', effect: 'icon-glow-rare' },
    { id: 'c225', name: 'Trèfle à 4 feuilles', rarity: 'Rare', icon: 'fa-clover', color: 'text-green-500', effect: 'icon-glow-rare' },
    { id: 'c226', name: 'Os', rarity: 'Rare', icon: 'fa-bone', color: 'text-stone-300', effect: 'icon-glow-rare' },
    { id: 'c228', name: 'Scarabée', rarity: 'Rare', icon: 'fa-bug', color: 'text-emerald-500', effect: 'icon-glow-rare' },
    { id: 'c229', name: 'Chapeau de Sorcier', rarity: 'Rare', icon: 'fa-hat-wizard', color: 'text-indigo-400', effect: 'icon-glow-rare' },
    
    // Épiques
    { id: 'c004', name: 'Couronne du Bench King', rarity: 'Épique', icon: 'fa-crown', color: 'text-yellow-400', effect: 'icon-glow-epique' },
    { id: 'c301', name: 'Plume du Phoenix', rarity: 'Épique', icon: 'fa-feather-pointed', color: 'text-red-500', effect: 'icon-glow-epique' },
    { id: 'c302', name: 'Marteau Divin', rarity: 'Épique', icon: 'fa-hammer', color: 'text-cyan-300', effect: 'icon-glow-epique' },
    { id: 'c303', name: 'Holocron', rarity: 'Épique', icon: 'fa-cube', color: 'text-blue-300', effect: 'icon-glow-epique' },
    { id: 'c304', name: 'Ailes Célestes', rarity: 'Épique', icon: 'fa-dove', color: 'text-stone-300', effect: 'icon-glow-epique' },
    { id: 'c305', name: 'Coeur de Golem', rarity: 'Épique', icon: 'fa-heart-crack', color: 'text-stone-500', effect: 'icon-glow-epique' },
    { id: 'c306', name: 'Orbe Instable', rarity: 'Épique', icon: 'fa-atom', color: 'text-purple-300', effect: 'icon-glow-epique' },
    { id: 'c307', name: 'Sablier du Temps', rarity: 'Épique', icon: 'fa-hourglass-half', color: 'text-indigo-400', effect: 'icon-glow-epique' },
    { id: 'c308', name: 'Parchemin Ancien', rarity: 'Épique', icon: 'fa-scroll', color: 'text-amber-300', effect: 'icon-glow-epique' },
    { id: 'c309', name: 'Clé Squelette', rarity: 'Épique', icon: 'fa-key', color: 'text-gray-300', effect: 'icon-glow-epique' },
    { id: 'c310', name: 'Potion de Mana', rarity: 'Épique', icon: 'fa-flask', color: 'text-blue-400', effect: 'icon-glow-epique' },
    { id: 'c311', name: 'Cristal d\'Énergie', rarity: 'Épique', icon: 'fa-bahai', color: 'text-fuchsia-400', effect: 'icon-glow-epique' },
    { id: 'c312', name: 'Katana', rarity: 'Épique', icon: 'fa-slash', color: 'text-gray-200', effect: 'icon-glow-epique' },
    { id: 'c313', name: 'Engrenage Doré', rarity: 'Épique', icon: 'fa-gear', color: 'text-yellow-500', effect: 'icon-glow-epique' },
    { id: 'c314', name: 'Oeil Qui Voit Tout', rarity: 'Épique', icon: 'fa-eye', color: 'text-cyan-300', effect: 'icon-glow-epique' },
    { id: 'c315', name: 'Tête de Mort', rarity: 'Épique', icon: 'fa-skull', color: 'text-stone-300', effect: 'icon-glow-epique' },
    { id: 'c316', name: 'Symbole Atomique', rarity: 'Épique', icon: 'fa-atom', color: 'text-green-400', effect: 'icon-glow-epique' },
    { id: 'c317', name: 'Météorite', rarity: 'Épique', icon: 'fa-meteor', color: 'text-orange-500', effect: 'icon-glow-epique' },
    { id: 'c318', name: 'Masque d\'Oni', rarity: 'Épique', icon: 'fa-masks-theater', color: 'text-red-600', effect: 'icon-glow-epique' },
    { id: 'c319', name: 'Boussole', rarity: 'Épique', icon: 'fa-compass', color: 'text-sky-300', effect: 'icon-glow-epique' },
    { id: 'c320', name: 'Griffe de Monstre', rarity: 'Épique', icon: 'fa-hand-back-fist', color: 'text-gray-300', effect: 'icon-glow-epique' },
    { id: 'c321', name: 'Masque à Gaz', rarity: 'Épique', icon: 'fa-mask-ventilator', color: 'text-lime-400', effect: 'icon-glow-epique' },
    { id: 'c323', name: 'Parapluie', rarity: 'Épique', icon: 'fa-umbrella', color: 'text-blue-300', effect: 'icon-glow-epique' },
    
    // Légendaires
    { id: 'c005', name: 'Potion "Pre-Workout"', rarity: 'Légendaire', icon: 'fa-flask-vial', color: 'text-fuchsia-500', effect: 'icon-glow-legendaire' },
    { id: 'c401', name: 'Sceptre de Puissance', rarity: 'Légendaire', icon: 'fa-wand-magic-sparkles', color: 'text-purple-400', effect: 'icon-glow-legendaire' },
    { id: 'c402', name: 'Trident des Abysses', rarity: 'Légendaire', icon: 'fa-staff-snake', color: 'text-cyan-400', effect: 'icon-glow-legendaire' },
    { id: 'c403', name: 'Fragment de Supernova', rarity: 'Légendaire', icon: 'fa-star-of-life', color: 'text-orange-400', effect: 'icon-glow-legendaire' },
    { id: 'c404', name: 'Gungnir, Lance d\'Odin', rarity: 'Légendaire', icon: 'fa-up-long', color: 'text-violet-300', effect: 'icon-glow-legendaire' },
    { id: 'c405', name: 'Vortex Arcanique', rarity: 'Légendaire', icon: 'fa-hurricane', color: 'text-yellow-400', effect: 'icon-glow-legendaire' },
    { id: 'c406', name: 'Bouclier Égide', rarity: 'Légendaire', icon: 'fa-shield-virus', color: 'text-yellow-400', effect: 'icon-glow-legendaire' },
    { id: 'c407', name: 'Mjolnir', rarity: 'Légendaire', icon: 'fa-hammer', color: 'text-sky-300', effect: 'icon-glow-legendaire' },
    { id: 'c408', name: 'Lyre d\'Apollon', rarity: 'Légendaire', icon: 'fa-guitar', color: 'text-amber-300', effect: 'icon-glow-legendaire' },
    { id: 'c409', name: 'Orbe de Glace', rarity: 'Légendaire', icon: 'fa-icicles', color: 'text-cyan-200', effect: 'icon-glow-legendaire' },
    { id: 'c410', name: 'Épée Excalibur', rarity: 'Légendaire', icon: 'fa-gavel', color: 'text-gray-200', effect: 'icon-glow-legendaire' },
    { id: 'c411', name: 'Cœur de Dragon', rarity: 'Légendaire', icon: 'fa-dragon', color: 'text-red-500', effect: 'icon-glow-legendaire' },
    { id: 'c412', name: 'Casque de la Valkyrie', rarity: 'Légendaire', icon: 'fa-feather-pointed', color: 'text-white', effect: 'icon-glow-legendaire' },
    { id: 'c413', name: 'Ouroboros', rarity: 'Légendaire', icon: 'fa-circle-notch', color: 'text-green-400', effect: 'icon-glow-legendaire' },
    { id: 'c414', name: 'Grimoire Ancien', rarity: 'Légendaire', icon: 'fa-book-journal-whills', color: 'text-purple-300', effect: 'icon-glow-legendaire' },
    { id: 'c415', name: 'Vaisseau Spatial', rarity: 'Légendaire', icon: 'fa-space-shuttle', color: 'text-gray-200', effect: 'icon-glow-legendaire' },

    // Mythiques
    { id: 'c006', name: 'Éclair de Zeus', rarity: 'Mythique', icon: 'fa-bolt-lightning', color: 'text-yellow-300', effect: 'icon-glow-mythique' },
    { id: 'c501', name: 'Coeur de Titan', rarity: 'Mythique', icon: 'fa-heart-pulse', color: 'text-red-500', effect: 'icon-glow-mythique' },
    { id: 'c502', name: 'Fardeau d\'Atlas', rarity: 'Mythique', icon: 'fa-earth-europe', color: 'text-cyan-200', effect: 'icon-glow-mythique' },
    { id: 'c503', name: 'Haltère du Big Bang', rarity: 'Mythique', icon: 'fa-atom', color: 'text-purple-300', effect: 'icon-glow-mythique' },
    { id: 'c504', name: 'Fragment d\'Étoile', rarity: 'Mythique', icon: 'fa-burst', color: 'text-white', effect: 'icon-glow-mythique' },
    { id: 'c505', name: 'Pierre Philosophale', rarity: 'Mythique', icon: 'fa-gem', color: 'text-red-500', effect: 'icon-glow-mythique' },
    { id: 'c506', name: 'Livre des Ombres', rarity: 'Mythique', icon: 'fa-book-skull', color: 'text-purple-400', effect: 'icon-glow-mythique' },
    { id: 'c507', name: 'Ankh de Vie Éternelle', rarity: 'Mythique', icon: 'fa-ankh', color: 'text-yellow-300', effect: 'icon-glow-mythique' },
    { id: 'c508', name: 'Tesseract', rarity: 'Mythique', icon: 'fa-cubes-stacked', color: 'text-blue-300', effect: 'icon-glow-mythique' },
    { id: 'c509', name: 'Noyau de Singularité', rarity: 'Mythique', icon: 'fa-bahai', color: 'text-white', effect: 'icon-glow-mythique' },
    { id: 'c510', name: 'Flamme de Prométhée', rarity: 'Mythique', icon: 'fa-torii-gate', color: 'text-orange-400', effect: 'icon-glow-mythique' },
    { id: 'c511', name: 'Ragnarok', rarity: 'Mythique', icon: 'fa-volcano', color: 'text-red-500', effect: 'icon-glow-mythique' },
    { id: 'c512', name: 'Voiture de Sport', rarity: 'Mythique', icon: 'fa-car-side', color: 'text-red-500', effect: 'icon-glow-mythique' },
    
    // VERSION FINALE À UTILISER

// Divins
{ id: 'c601', name: 'Oeil de la Création', rarity: 'Divin', icon: 'fa-eye', color: 'animated-icon-divin', effect: 'icon-glow-divin' },
{ id: 'c602', name: 'Balance Cosmique', rarity: 'Divin', icon: 'fa-scale-balanced', color: 'animated-icon-divin', effect: 'icon-glow-divin' },
{ id: 'c603', name: 'Sablier Infini', rarity: 'Divin', icon: 'fa-infinity', color: 'animated-icon-divin', effect: 'icon-glow-divin' },
{ id: 'c604', name: 'Main du Créateur', rarity: 'Divin', icon: 'fa-hand-sparkles', color: 'animated-icon-divin', effect: 'icon-glow-divin' },
{ id: 'c605', name: 'Le Saint Graal', rarity: 'Divin', icon: 'fa-trophy', color: 'animated-icon-divin', effect: 'icon-glow-divin' },

// --- Objets Secrets du Créateur ---
{ id: 'c701', name: 'Clavier du Développeur', rarity: 'Créateur', icon: 'fa-keyboard', color: 'animated-icon-createur', effect: 'icon-glow-createur' },
{ id: 'c702', name: 'Le Poulet de la Masse', rarity: 'Créateur', icon: 'fa-drumstick-bite', color: 'animated-icon-createur', effect: 'icon-glow-createur' },
{ id: 'c703', name: 'Code Source Originel', rarity: 'Créateur', icon: 'fa-code', color: 'animated-icon-createur', effect: 'icon-glow-createur' }
];

        const TITLES_DATABASE = [
    // Communs
    { id: 't001', name: 'Débutant', rarity: 'Commun', cost: 0, source: 'default' },
    { id: 't101', name: 'Régulier', rarity: 'Commun', cost: 100, source: 'shop' },
    { id: 't102', name: 'Passionné', rarity: 'Commun', cost: 120, source: 'shop' },
    // == NOUVEAUX AJOUTS ==
    { id: 't103', name: 'Apprenti', rarity: 'Commun', cost: 150, source: 'shop' },
    { id: 't104', name: 'Visiteur du Gym', rarity: 'Commun', cost: 150, source: 'shop' },
    { id: 't105', name: 'Déterminé', rarity: 'Commun', cost: 180, source: 'shop' },
    { id: 't106', name: 'Nouveau Souffle', rarity: 'Commun', cost: 200, source: 'shop' },
    { id: 't107', name: 'Matinal', rarity: 'Commun', cost: 220, source: 'shop' },
    { id: 't108', name: 'Noctambule', rarity: 'Commun', cost: 220, source: 'shop' },
    { id: 't109', name: 'En Progression', rarity: 'Commun', cost: 250, source: 'shop' },
    { id: 't110', name: 'Curieux', rarity: 'Commun', cost: 130, source: 'shop' },
    { id: 't111', name: 'Motivé', rarity: 'Commun', cost: 160, source: 'shop' },
    { id: 't112', name: 'Fidèle au Poste', rarity: 'Commun', cost: 190, source: 'shop' },
    { id: 't113', name: 'Sueur & Volonté', rarity: 'Commun', cost: 230, source: 'shop' },
    { id: 't114', name: 'Calorie-Conscient', rarity: 'Commun', cost: 210, source: 'shop' },
    { id: 't115', name: 'Adepte des Shakes', rarity: 'Commun', cost: 170, source: 'shop' },

    // Rares
    { id: 't201', name: 'Athlète Solide', rarity: 'Rare', cost: 400, source: 'shop' },
    { id: 't202', name: 'Guerrier du Fer', rarity: 'Rare', cost: 450, source: 'shop' },
    { id: 't203', name: 'Maître des Séries', rarity: 'Rare', cost: 500, source: 'shop' },
    { id: 't204', name: 'Dévoreur de Protéines', rarity: 'Rare', cost: 400, source: 'shop' },
    // == NOUVEAUX AJOUTS ==
    { id: 't205', name: 'Force Tranquille', rarity: 'Rare', cost: 550, source: 'shop' },
    { id: 't206', name: 'Haltérophile', rarity: 'Rare', cost: 580, source: 'shop' },
    { id: 't207', name: 'Sprinter', rarity: 'Rare', cost: 600, source: 'shop' },
    { id: 't208', name: 'Architecte Corporel', rarity: 'Rare', cost: 620, source: 'shop' },
    { id: 't209', name: 'Insatiable', rarity: 'Rare', cost: 650, source: 'shop' },
    { id: 't210', name: 'Prédateur Alpha', rarity: 'Rare', cost: 700, source: 'shop' },
    { id: 't211', name: 'Ronin', rarity: 'Rare', cost: 720, source: 'shop' },
    { id: 't212', name: 'Centurion', rarity: 'Rare', cost: 750, source: 'shop' },
    { id: 't213', name: 'Fou de Fonte', rarity: 'Rare', cost: 780, source: 'shop' },
    { id: 't214', name: 'Marathonien', rarity: 'Rare', cost: 680, source: 'shop' },
    { id: 't215', name: 'Viking Moderne', rarity: 'Rare', cost: 730, source: 'shop' },
    { id: 't216', name: 'Chasseur de PR', rarity: 'Rare', cost: 800, source: 'shop' },
    { id: 't217', name: 'Pyramide Inversée', rarity: 'Rare', cost: 660, source: 'shop' },
    { id: 't218', name: 'Accro au Leg Day', rarity: 'Rare', cost: 790, source: 'shop' },
    { id: 't219', name: 'Surcharge Progressive', rarity: 'Rare', cost: 820, source: 'shop' },
    { id: 't220', name: 'Gladiateur', rarity: 'Rare', cost: 850, source: 'shop' },

    // Épiques
    { id: 't301', name: 'Titan en Devenir', rarity: 'Épique', cost: 1000, source: 'shop' },
    { id: 't302', name: 'Forgeur de Muscles', rarity: 'Épique', cost: 1100, source: 'shop' },
    { id: 't303', name: 'Légende du Bench', rarity: 'Épique', cost: 1200, source: 'shop' },
    { id: 't304', name: 'Alchimiste Nutritionnel', rarity: 'Épique', cost: 1000, source: 'shop' },
    { id: 't305', name: 'Force Imprévisible', rarity: 'Épique', cost: 1500, source: 'shop' },
    // == NOUVEAUX AJOUTS ==
    { id: 't306', name: 'Spectre de la Salle', rarity: 'Épique', cost: 1300, source: 'shop' },
    { id: 't307', name: 'Virtuose de la Fonte', rarity: 'Épique', cost: 1350, source: 'shop' },
    { id: 't308', name: 'Cyclone de Cardio', rarity: 'Épique', cost: 1400, source: 'shop' },
    { id: 't309', name: 'Né dans le Fer', rarity: 'Épique', cost: 1500, source: 'shop' },
    { id: 't310', name: 'Écho de Sparte', rarity: 'Épique', cost: 1600, source: 'shop' },
    { id: 't311', name: 'Briseur de Plateaux', rarity: 'Épique', cost: 1700, source: 'shop' },
    { id: 't312', name: 'Berserker', rarity: 'Épique', cost: 1800, source: 'shop' },
    { id: 't313', name: 'Cyber-Athlète', rarity: 'Épique', cost: 1650, source: 'shop' },
    { id: 't314', name: 'Hoplite', rarity: 'Épique', cost: 1750, source: 'shop' },
    { id: 't315', name: 'Roi de la Salle', rarity: 'Épique', cost: 1900, source: 'shop' },
    { id: 't316', name: 'Marcheur de Feu', rarity: 'Épique', cost: 1850, source: 'shop' },
    { id: 't317', name: 'Samouraï de la Fonte', rarity: 'Épique', cost: 1950, source: 'shop' },
    { id: 't318', name: 'Fantôme des Racks', rarity: 'Épique', cost: 1980, source: 'shop' },

    // Légendaires
    { id: 't401', name: 'Colosse des Gyms', rarity: 'Légendaire', cost: 2500, source: 'shop' },
    { id: 't402', name: 'Machine Humaine', rarity: 'Légendaire', cost: 2700, source: 'shop' },
    { id: 't403', name: 'Vétéran Indomptable', rarity: 'Légendaire', cost: 2800, source: 'shop' },
    { id: 't404', name: 'Volonté Ardente', rarity: 'Légendaire', cost: 3000, source: 'shop' },
    // == NOUVEAUX AJOUTS ==
    { id: 't405', name: 'Descendant d\'Hercule', rarity: 'Légendaire', cost: 2900, source: 'shop' },
    { id: 't406', name: 'Avatar de la Force', rarity: 'Légendaire', cost: 3100, source: 'shop' },
    { id: 't407', name: 'Moteur Inarrêtable', rarity: 'Légendaire', cost: 3300, source: 'shop' },
    { id: 't408', name: 'Monarque Musculaire', rarity: 'Légendaire', cost: 3500, source: 'shop' },
    { id: 't409', name: 'L\'Ombre et la Masse', rarity: 'Légendaire', cost: 3800, source: 'shop' },
    { id: 't410', name: 'Phénomène Physique', rarity: 'Légendaire', cost: 4000, source: 'shop' },
    { id: 't411', name: 'Einherjar', rarity: 'Légendaire', cost: 4200, source: 'shop' },
    { id: 't412', name: 'Champion d\'Arès', rarity: 'Légendaire', cost: 4500, source: 'shop' },
    { id: 't413', name: 'Netrunner Anabolique', rarity: 'Légendaire', cost: 4800, source: 'shop' },
    { id: 't414', name: 'Dieu du Pré-Workout', rarity: 'Légendaire', cost: 5000, source: 'shop' },

    // Mythiques
    { id: 't501', name: 'Olympe en Marche', rarity: 'Mythique', cost: 6000, source: 'shop' },
    { id: 't502', name: 'Hercule Renforcé', rarity: 'Mythique', cost: 7000, source: 'shop' },
    { id: 't503', name: 'Entité Cosmique', rarity: 'Mythique', cost: 8000, source: 'shop' },
    // == NOUVEAUX AJOUTS ==
    { id: 't504', name: 'Relique Vivante', rarity: 'Mythique', cost: 8200, source: 'shop' },
    { id: 't505', name: 'Anomalie Génétique', rarity: 'Mythique', cost: 8800, source: 'shop' },
    { id: 't506', name: 'Le Dernier Spartiate', rarity: 'Mythique', cost: 9200, source: 'shop' },
    { id: 't507', name: 'Mythe Incarné', rarity: 'Mythique', cost: 9500, source: 'shop' },
    { id: 't508', name: 'Gravité Zéro', rarity: 'Mythique', cost: 10000, source: 'shop' },
    { id: 't509', name: 'Écho du Big Bang', rarity: 'Mythique', cost: 12000, source: 'shop' },
    { id: 't510', name: 'Juggernaut', rarity: 'Mythique', cost: 15000, source: 'shop' },

    // Divins
    { id: 't601', name: 'Ascensionné', rarity: 'Divin', cost: 25000, source: 'shop' },
    { id: 't602', name: 'Architecte du Cosmos', rarity: 'Divin', cost: 30000, source: 'shop' },
    { id: 't603', name: 'Volonté des Dieux', rarity: 'Divin', cost: 40000, source: 'shop' },
    { id: 't604', name: 'Alpha & Oméga', rarity: 'Divin', cost: 50000, source: 'shop' },
    { id: 't-gymbro-originel', name: 'Gymbro Originel', rarity: 'Divin', cost: 0, color: 'title-gymbro-originel', source: 'secret' },
    { id: 't-pompier-muscle', name: 'Pompier Musclé', rarity: 'Divin', cost: 0, color: 'title-pompier-muscle', source: 'secret' },
    { id: 't-the-bench-monster', name: 'The Bench Monster', rarity: 'Divin', cost: 0, color: 'title-the-bench-monster', source: 'secret' },
    { id: 't-createur-supreme', name: 'The Gym Dev', rarity: 'Divin', cost: 0, color: 'title-createur-supreme', source: 'secret' },

    // --- Titres de Succès Secrets ---
    { id: 't_forgeron', name: 'Forgeron de la Fonte', rarity: 'Rare', source: 'achievement' },
    { id: 't_intense', name: 'Ouragan Musculaire', rarity: 'Rare', source: 'achievement' },
    { id: 't_repetiteur', name: 'Le Répétiteur', rarity: 'Épique', source: 'achievement' },
    { id: 't_set_master', name: 'Maître des Séries', rarity: 'Épique', source: 'achievement' },
    { id: 't_pr_hunter', name: 'Chasseur de Records', rarity: 'Légendaire', source: 'achievement' },
    { id: 't_imparable', name: 'Imparable', rarity: 'Épique', source: 'achievement' },
    { id: 't_veteran', name: 'Vétéran de la Salle', rarity: 'Légendaire', source: 'achievement' },
    { id: 't_parfait', name: 'Le Perfectionniste', rarity: 'Légendaire', source: 'achievement' },
    { id: 't_devoue', name: 'Dévoué', rarity: 'Mythique', source: 'achievement' },
    { id: 't_leve_tot', name: 'Le Matinal', rarity: 'Rare', source: 'achievement' },
    { id: 't_oiseau_de_nuit', name: 'Oiseau de Nuit', rarity: 'Rare', source: 'achievement' },
    { id: 't_chef', name: 'Chef Étoilé', rarity: 'Épique', source: 'achievement' },
    { id: 't_nutritionniste', name: 'Nutritionniste Rigoureux', rarity: 'Légendaire', source: 'achievement' },
    { id: 't_millionnaire', name: 'Calorie Millionnaire', rarity: 'Épique', source: 'achievement' },
    { id: 't_bench_club', name: 'Club des 100kg', rarity: 'Rare', source: 'achievement' },
    { id: 't_squat_king', name: 'Le Trône', rarity: 'Rare', source: 'achievement' },
    { id: 't_deadlift_sovereign', name: 'Le Souverain', rarity: 'Rare', source: 'achievement' },
    { id: 't_plank_god', name: 'Dieu du Gainage', rarity: 'Épique', source: 'achievement' },
    { id: 't_bodyweight_beast', name: 'Bête au Poids du Corps', rarity: 'Légendaire', source: 'achievement' },
    { id: 't_collector', name: 'Le Collectionneur', rarity: 'Épique', source: 'achievement' },
    { id: 't_spendthrift', name: 'Le Dépensier', rarity: 'Rare', source: 'achievement' },
    { id: 't_wealthy', name: 'Fortuné', rarity: 'Épique', source: 'achievement' },
    { id: 't_minimalist', name: 'Le Minimaliste', rarity: 'Rare', source: 'achievement' },
    { id: 't_over9000', name: "C'est plus de 9000 !", rarity: 'Légendaire', source: 'achievement' }
];

const ACHIEVEMENTS_DATABASE = [
    // === VOLUME & FORCE ===
    { id: 'total_volume', name: "Forgeron de la Fonte", description: (goal) => `Soulever un total de ${formatVolume(goal)}.`, icon: 'fa-weight-hanging', color: '#FBBF24', tiers: [ { goal: 10000, reward: { xp: 100, type: 'coins', amount: 50 } }, { goal: 100000, reward: { xp: 500, type: 'coins', amount: 150 } }, { goal: 500000, reward: { xp: 1000, type: 'coins', amount: 300 } }, { goal: 1000000, reward: { xp: 2000, type: 'title', id: 't_forgeron' } }, { goal: 10000000, reward: { xp: 10000, type: 'coins', amount: 1000 } }, { goal: 100000000, reward: { xp: 50000, type: 'border', id: 'b_titan' } } ] },
    { id: 'single_session_volume', name: "Session Intense", description: (goal) => `Soulever ${formatVolume(goal)} en une seule séance.`, icon: 'fa-bolt', color: '#F87171', tiers: [ { goal: 5000, reward: { xp: 75, type: 'coins', amount: 25 } }, { goal: 10000, reward: { xp: 150, type: 'coins', amount: 75 } }, { goal: 20000, reward: { xp: 300, type: 'title', id: 't_intense' } } ] },
    { id: 'total_reps', name: "Le Répétiteur", description: (goal) => `Effectuer ${goal.toLocaleString('fr-FR')} répétitions.`, icon: 'fa-repeat', color: '#60A5FA', tiers: [ { goal: 1000, reward: { xp: 50, type: 'coins', amount: 20 } }, { goal: 10000, reward: { xp: 250, type: 'coins', amount: 100 } }, { goal: 50000, reward: { xp: 750, type: 'coins', amount: 250 } }, { goal: 100000, reward: { xp: 1500, type: 'title', id: 't_repetiteur' } } ] },
    { id: 'total_sets', name: "Maître des Séries", description: (goal) => `Terminer ${goal.toLocaleString('fr-FR')} séries.`, icon: 'fa-layer-group', color: '#CA8A04', tiers: [{ goal: 500, reward: { xp: 100, type: 'coins', amount: 50} }, { goal: 2500, reward: { xp: 500, type: 'coins', amount: 200} }, { goal: 10000, reward: { xp: 2000, type: 'title', id: 't_set_master'} }] },
    { id: 'pr_breaker', name: "Chasseur de Records", description: (goal) => `Battre ${goal} record(s) personnel(s).`, icon: 'fa-star', color: '#FDE047', tiers: [ { goal: 1, reward: { xp: 100, type: 'coins', amount: 50 } }, { goal: 10, reward: { xp: 300, type: 'coins', amount: 100 } }, { goal: 50, reward: { xp: 1000, type: 'coins', amount: 250 } }, { goal: 100, reward: { xp: 2500, type: 'title', id: 't_pr_hunter' } } ] },
    
    // === CONSISTANCE & HABITUDES ===
    { id: 'workout_streak', name: "Imparable", description: (goal) => `Atteindre une série de ${goal} jours d'entraînement.`, icon: 'fa-fire-flame-curved', color: '#F97316', tiers: [ { goal: 7, reward: { xp: 200, type: 'coins', amount: 50 } }, { goal: 30, reward: { xp: 1000, type: 'title', id: 't_imparable' } }, { goal: 100, reward: { xp: 5000, type: 'border', id: 'b_flamme' } }, { goal: 365, reward: { xp: 20000, type: 'border', id: 'b_eternelle' } } ] },
    { id: 'total_sessions_completed', name: "Vétéran de la Salle", description: (goal) => `Terminer ${goal} séances.`, icon: 'fa-calendar-check', color: '#10B981', tiers: [ { goal: 10, reward: { xp: 100, type: 'coins', amount: 25 } }, { goal: 50, reward: { xp: 500, type: 'coins', amount: 150 } }, { goal: 100, reward: { xp: 1000, type: 'coins', amount: 250 } }, { goal: 500, reward: { xp: 5000, type: 'title', id: 't_veteran' } } ] },
    { id: 'perfect_week', name: "Semaine Parfaite", description: (goal) => `Terminer toutes les séances planifiées sur ${goal} semaine(s).`, icon: 'fa-circle-check', color: '#14B8A6', tiers: [ { goal: 1, reward: { xp: 250, type: 'coins', amount: 100 } }, { goal: 4, reward: { xp: 750, type: 'coins', amount: 200 } }, { goal: 12, reward: { xp: 2000, type: 'title', id: 't_parfait' } } ] },
    { id: 'total_training_time', name: "Dévoué", description: (goal) => `Passer ${goal} heures à s'entraîner.`, icon: 'fa-clock', color: '#6366F1', tiers: [ { goal: 10, reward: { xp: 150, type: 'coins', amount: 30 } }, { goal: 50, reward: { xp: 600, type: 'coins', amount: 200 } }, { goal: 200, reward: { xp: 1500, type: 'coins', amount: 400 } }, { goal: 1000, reward: { xp: 8000, type: 'title', id: 't_devoue' } } ] },
    { id: 'early_bird', name: "Lève-tôt", description: (goal) => `Commencer ${goal} séance(s) avant 7h.`, icon: 'fa-sun', color: '#F59E0B', tiers: [ { goal: 1, reward: { xp: 50, type: 'coins', amount: 30 } }, { goal: 10, reward: { xp: 250, type: 'coins', amount: 100 } }, { goal: 50, reward: { xp: 1000, type: 'title', id: 't_leve_tot' } } ] },
    { id: 'night_owl', name: "Oiseau de Nuit", description: (goal) => `Terminer ${goal} séance(s) après 22h.`, icon: 'fa-moon', color: '#8B5CF6', tiers: [ { goal: 1, reward: { xp: 50, type: 'coins', amount: 30 } }, { goal: 10, reward: { xp: 250, type: 'coins', amount: 100 } }, { goal: 50, reward: { xp: 1000, type: 'title', id: 't_oiseau_de_nuit' } } ] },

    // === NUTRITION ===
    { id: 'meals_created', name: "Chef Étoilé", description: (goal) => `Créer ${goal} repas.`, icon: 'fa-utensils', color: '#34D399', tiers: [ { goal: 10, reward: { xp: 80, type: 'coins', amount: 25 } }, { goal: 50, reward: { xp: 300, type: 'coins', amount: 100 } }, { goal: 200, reward: { xp: 1000, type: 'title', id: 't_chef' } } ] },
    { id: 'nutrition_streak', name: "Nutritionniste Rigoureux", description: (goal) => `Atteindre ses objectifs nutritionnels ${goal} jours de suite.`, icon: 'fa-carrot', color: '#84CC16', tiers: [ { goal: 7, reward: { xp: 250, type: 'coins', amount: 75 } }, { goal: 30, reward: { xp: 1200, type: 'coins', amount: 500 } }, { goal: 90, reward: { xp: 4000, type: 'title', id: 't_nutritionniste' } } ] },
    { id: 'scan_master', name: "Maître du Scan", description: (goal) => `Scanner ${goal} codes-barres différents.`, icon: 'fa-barcode', color: '#EAB308', tiers: [ { goal: 5, reward: { xp: 40, type: 'coins', amount: 15 } }, { goal: 25, reward: { xp: 150, type: 'coins', amount: 50 } }, { goal: 100, reward: { xp: 500, type: 'coins', amount: 200 } } ] },
    { id: 'million_calories', name: "Le Million de Calories", description: (goal) => `Suivre un million de calories.`, icon: 'fa-calculator', color: '#EF4444', tiers: [ { goal: 1000000, reward: { xp: 5000, type: 'title', id: 't_millionnaire' } } ] },

    // === JALONS & SPÉCIALISATION ===
    { id: 'heavy_lifter_club', name: "Club des Gros Souleveurs (SBD)", description: (goal) => `Atteindre un 1RM de 150kg sur les ${goal} mouvements du SBD (Squat, Bench, Deadlift).`, icon: 'fa-trophy', color: '#FBBF24', tiers: [{ goal: 3, reward: { xp: 10000, type: 'border', id: 'b_heavy'} }] },
    { id: 'bench_press_club', name: "Club des 100kg (Bench)", description: (goal) => `Soulever ${goal}kg au développé couché.`, icon: 'fa-dumbbell', color: '#DC2626', tiers: [ { goal: 100, reward: { xp: 1000, type: 'title', id: 't_bench_club' } } ] },
    { id: 'squat_club', name: "Le Trône (Squat)", description: (goal) => `Soulever ${goal}kg au squat à la barre.`, icon: 'fa-chess-king', color: '#2563EB', tiers: [ { goal: 140, reward: { xp: 1000, type: 'title', id: 't_squat_king' } } ] },
    { id: 'deadlift_club', name: "Le Souverain (Deadlift)", description: (goal) => `Soulever ${goal}kg au soulevé de terre.`, icon: 'fa-monument', color: '#4B5563', tiers: [ { goal: 180, reward: { xp: 1000, type: 'title', id: 't_deadlift_sovereign' } } ] },
    { id: 'pullup_master', name: "Maître des Tractions", description: (goal) => `Effectuer ${goal} tractions en une série.`, icon: 'fa-hands-clapping', color: '#059669', tiers: [ { goal: 20, reward: { xp: 1500, type: 'coins', amount: 300 } } ] },
    { id: 'plank_god', name: "Dieu du Gainage", description: (goal) => `Tenir ${goal / 60} minutes en gainage.`, icon: 'fa-stopwatch-20', color: '#D97706', tiers: [ { goal: 300, reward: { xp: 2000, type: 'title', id: 't_plank_god' } } ] },
    { id: 'bodyweight_beast', name: "Bête au Poids du Corps", description: (goal) => `Atteindre le rang Vétéran sur 3 exercices au poids du corps.`, icon: 'fa-user-astronaut', color: '#6B7280', tiers: [{ goal: 3, reward: { xp: 2500, type: 'title', id: 't_bodyweight_beast'} }] },
    { id: 'all_muscle_groups_in_week', name: "Le Conquérant", description: (goal) => `Entraîner tous les groupes musculaires en une semaine.`, icon: 'fa-universal-access', color: '#0D9488', tiers: [ { goal: 1, reward: { xp: 500, type: 'coins', amount: 150 } } ] },
    
    // === PERSONNALISATION & ÉCONOMIE ===
    { id: 'shop_first_purchase', name: "Premier Achat", description: (goal) => `Acheter votre premier article dans la boutique.`, icon: 'fa-store', color: '#A78BFA', tiers: [ { goal: 1, reward: { xp: 100, type: 'coins', amount: 50 } } ] },
    { id: 'collector_initiate', name: "Collectionneur", description: (goal) => `Obtenir ${goal} objets de collection différents.`, icon: 'fa-box', color: '#A16207', tiers: [ { goal: 10, reward: { xp: 150, type: 'coins', amount: 50 } }, { goal: 50, reward: { xp: 500, type: 'coins', amount: 200 } }, { goal: 100, reward: { xp: 1000, type: 'title', id: 't_collector'} } ] },
    { id: 'collection_complete', name: "Collectionneur Ultime", description: (goal) => `Débloquer tous les objets de collection (${goal}).`, icon: 'fa-boxes-stacked', color: '#A78BFA', tiers: [ { goal: COLLECTIBLES_DATABASE.length, reward: { xp: 15000, type: 'border', id: 'b_collector_ultimate' } } ] },
    { id: 'profile_complete', name: "Carte d'Identité", description: (goal) => `Remplir toutes les informations du profil.`, icon: 'fa-id-card', color: '#6B7280', tiers: [ { goal: 1, reward: { xp: 200, type: 'coins', amount: 100 } } ], checkCondition: (state) => (state.userProfile.name && state.userProfile.name !== 'User' && state.userProfile.dob && state.userProfile.sex && state.userProfile.country) ? 1 : 0 },
    { id: 'profile_pic_upload', name: "Photogénique", description: (goal) => `Ajouter une photo de profil.`, icon: 'fa-camera', color: '#9333EA', tiers: [{ goal: 1, reward: { xp: 200, type: 'coins', amount: 100} }], checkCondition: (state) => state.userProfile.profilePicUrl ? 1 : 0 },
    { id: 'spendthrift', name: "Dépensier", description: (goal) => `Dépenser ${goal.toLocaleString('fr-FR')} pièces.`, icon: 'fa-coins', color: '#F59E0B', tiers: [{ goal: 1000, reward: { xp: 100, type: 'coins', amount: 50} }, { goal: 5000, reward: { xp: 300, type: 'coins', amount: 200} }, { goal: 20000, reward: { xp: 1000, type: 'title', id: 't_spendthrift'} }] },
    { id: 'legendary_owner', name: "Possession Légendaire", description: (goal) => `Obtenir un objet de rareté Légendaire.`, icon: 'fa-star-of-david', color: '#FBBF24', tiers: [{ goal: 1, reward: { xp: 1500, type: 'collectible', id: 'c407'} }] },
    { id: 'wealthy', name: "Fortuné", description: (goal) => `Posséder ${goal.toLocaleString('fr-FR')} pièces en même temps.`, icon: 'fa-sack-dollar', color: '#FDE047', tiers: [{ goal: 10000, reward: { xp: 500, type: 'coins', amount: 100} }, { goal: 25000, reward: { xp: 1000, type: 'coins', amount: 500} }, { goal: 50000, reward: { xp: 2500, type: 'title', id: 't_wealthy'} }] },

    // === DRÔLES & SECRETS ===
    { id: 'failure_is_an_option', name: "L'échec est une option", description: (goal) => `Échouer à une série en faisant 0 répétition.`, icon: 'fa-face-dizzy', color: '#71717A', tiers: [ { goal: 1, reward: { xp: 25, type: 'coins', amount: 10 } } ] },
    { id: 'one_rep_max_and_out', name: "Un, et puis c'est tout", description: (goal) => `Faire une séance d'une seule répétition.`, icon: 'fa-hand-pointer', color: '#BE185D', tiers: [ { goal: 1, reward: { xp: 100, type: 'title', id: 't_minimalist' } } ] },
    { id: 'over_9000', name: "IT'S OVER 9000!", description: (goal) => `Atteindre un score de performance de plus de 9000.`, icon: 'fa-bolt-lightning', color: '#FBBF24', tiers: [ { goal: 9001, reward: { xp: 9001, type: 'title', id: 't_over9000' } } ] },
    { id: 'hello_world', name: "Hello, World!", description: (goal) => `Ouvrir l'application pour la première fois.`, icon: 'fa-hand-wave', color: '#60A5FA', tiers: [{ goal: 1, reward: { xp: 100, type: 'coins', amount: 100 } }] },
    { id: 'rewarded_curiosity', name: "Curiosité Récompensée", description: (goal) => `Consulter toutes les ${goal} pages d'aide (?).`, icon: 'fa-book-medical', color: '#6EE7B7', tiers: [ { goal: 3, reward: { xp: 300, type: 'coins', amount: 200 } } ] },

    // === SUCCÈS FINAL ===
    { id: 'completionist', name: "Le Complétionniste", description: (goal) => `Atteindre 100% de progression totale sur tous les succès.`, icon: 'fa-infinity', color: '#FFFFFF', isHidden: true, tiers: [{ goal: 1, reward: { xp: 100000, type: 'border', id: 'b_infinity'} }] },

    // === SUCCÈS SECRET ===
    { id: 'secret_dev_achievement', name: "Héritage du Créateur", description: (goal) => `Débloqué en tant que développeur de FitFlow.`, icon: 'fa-user-secret', color: '#DC2626', isHidden: true, tiers: [ { goal: 1, reward: { xp: 100000000, type: 'collectible', id: 'c701' } }, { goal: 1, reward: { xp: 0, type: 'collectible', id: 'c702' } }, { goal: 1, reward: { xp: 0, type: 'collectible', id: 'c703' } } ] }
];

        // --- DATABASE & STATE MANAGEMENT ---
        let state = getInitialState();

        initializeDatabase();
        initializeTags();

        let playerTimer = null;
        let sessionDurationTimer = null;
        let autocompleteTimeout = null;
        let html5QrCode = null;
        let currentSearchResults = [];
        let progressionChart = null;
        let lastItemObserver = null;
        let isStoryScrolling = false;
        let lastHumorousMessage = '';
        let lastWeightHumorMessage = '';
        let userProfileListener = null;
        let clanListener = null;
        let inboxListener = null;
        let fadeInInterval = null;
        let fadeOutInterval = null;
        let gymListener = null;
        let particleInterval = null;
        let isJuryVideoLoading = false;

        // --- UTILITY FUNCTIONS ---

        function checkRarityAchievement() {
    const ownedRarities = new Set();
    const allInventory = [
        ...state.userProfile.inventory.borders.map(id => BORDERS_DATABASE.find(i => i.id === id)),
        ...state.userProfile.inventory.titles.map(id => TITLES_DATABASE.find(i => i.id === id)),
        ...state.userProfile.inventory.collectibles.map(id => COLLECTIBLES_DATABASE.find(i => i.id === id))
    ];
    
    allInventory.filter(Boolean).forEach(item => ownedRarities.add(item.rarity));
    
    updateAchievementProgress('rarity_rainbow', ownedRarities.size, 'set');
}

        function updateAchievementProgress(achievementId, value, mode = 'increment') {
    const achievement = ACHIEVEMENTS_DATABASE.find(ach => ach.id === achievementId);
    if (!achievement) return;

    if (!state.userProfile.achievements[achievementId]) {
        state.userProfile.achievements[achievementId] = { progress: 0, claimedTiers: [], qualifyingData: new Set() };
    }
    
    const achData = state.userProfile.achievements[achievementId];

    switch(mode) {
        case 'increment': achData.progress += value; break;
        case 'set': achData.progress = value; break;
        case 'max': achData.progress = Math.max(achData.progress, value); break;
        case 'add_to_set':
            if (!(achData.qualifyingData instanceof Set)) {
                achData.qualifyingData = new Set(achData.qualifyingData);
            }
            achData.qualifyingData.add(value);
            achData.progress = achData.qualifyingData.size;
            break;
    }

    // Déclencheur pour "Le Complétionniste"
    const globalProgress = calculateGlobalAchievementProgress();
    if (parseFloat(globalProgress.percentage) >= 100) {
        if (state.userProfile.achievements['completionist']?.progress !== 1) {
             if (!state.userProfile.achievements['completionist']) {
                state.userProfile.achievements['completionist'] = { progress: 0, claimedTiers: [], qualifyingData: new Set() };
             }
             state.userProfile.achievements['completionist'].progress = 1;
        }
    }
    
    // La ligne "// saveState();" a été supprimée ici.
}

function updateSocialNotificationBadge() {
    const socialNavIcon = document.getElementById('nav-social');
    const inboxPageIcon = document.getElementById('social-inbox-btn');

    // --- CORRECTION : On ne compte QUE les messages non lus dans la boîte de réception ---
    const totalNotifications = state.inbox?.unreadMessages?.length || 0;

    const icons = [socialNavIcon, inboxPageIcon].filter(Boolean);

    if (totalNotifications > 0) {
        icons.forEach(icon => {
            icon.classList.add('has-notification');
            icon.style.setProperty('--notification-count', `'${totalNotifications}'`);
        });
    } else {
        icons.forEach(icon => {
            icon.classList.remove('has-notification');
            icon.style.removeProperty('--notification-count');
        });
    }
}

 function addXP(amount) {
    const leveling = state.userProfile.leveling;

    if (leveling.isMaxedOut || amount <= 0) return;

    const xpForMaxLevel = calculateTotalXPToReachLevel(4000);
    
    if (leveling.xp + amount > xpForMaxLevel) {
        amount = xpForMaxLevel - leveling.xp;
        if (amount <= 0) return;
    }

    leveling.xp += amount;

    let levelsGained = 0;
    let totalGoldGained = 0;
    let keepChecking = true;

    while (keepChecking) {
        if (leveling.isMaxedOut) {
            keepChecking = false;
            continue;
        }

        const xpNeededForCurrentLevel = calculateXPForLevel(leveling.realLevel);
        const totalXPForPreviousLevels = calculateTotalXPToReachLevel(leveling.realLevel);
        const xpIntoCurrentLevel = leveling.xp - totalXPForPreviousLevels;

        if (xpIntoCurrentLevel >= xpNeededForCurrentLevel) {
            const previousLevel = leveling.realLevel;
            const goldReward = Math.round(50 + (previousLevel * 2)); 
            totalGoldGained += goldReward;
            levelsGained++;
            leveling.realLevel++;

            if (leveling.realLevel >= 4000) {
                leveling.isMaxedOut = true;
                leveling.realLevel = 4000;
                leveling.xp = xpForMaxLevel; 
                showToast(`NIVEAU MAXIMUM ATTEINT ! Félicitations !`, 'info');
                keepChecking = false;
            }
        } else {
            keepChecking = false;
        }
    }

    if (levelsGained > 0) {
        state.userProfile.coins += totalGoldGained;
        if (levelsGained === 1) {
            showToast(`Niveau ${leveling.realLevel} ! +${totalGoldGained} pièces`, 'success');
        } else {
            showToast(`+${levelsGained} Niveaux ! (Niv. ${leveling.realLevel}) +${totalGoldGained} pièces`, 'success');
        }
    }
    
    // --- CORRECTION CLÉ : On empêche la mise à jour si la modale des quêtes est ouverte ---
    const isOnQuestsPage = !!document.getElementById('quests-page-content');
    if (isOnQuestsPage) {
        // Si on est sur la page des quêtes, on met juste à jour le badge au cas où
        // un level up donnerait une quête (ne s'applique pas pour le moment mais c'est une bonne pratique).
        updateQuestBadge();
        return; // On arrête la fonction ici pour ne pas appeler render().
    }
    // --- FIN DE LA CORRECTION ---

    if (levelsGained > 0) {
        render();
    } else if (amount > 0) {
        if (state.activePage === 'Accueil' || state.activePage === 'Profil') {
            render();
        }
    }
}

function getQuestInfo(questId) {
    for (const category of ['workout', 'nutrition']) {
        for (const period of ['daily', 'weekly']) {
            const found = QUEST_DATABASE[category][period].find(q => q.id === questId);
            if (found) return found;
        }
    }
    return null;
}

function deepMerge(target, source) {
    const output = { ...target };
    
    for (const key of Object.keys(source)) {
        if (source[key] instanceof Object && key in target && target[key] instanceof Object && !(source[key] instanceof Array) && !(source[key] instanceof Set)) {
            output[key] = deepMerge(target[key], source[key]);
        } else {
            output[key] = source[key];
        }
    }
    
    return output;
}

function loadState() {
    const savedState = localStorage.getItem('fitflow_state');
    if (savedState) {
        try {
            const parsedState = JSON.parse(savedState);
            
            // Reconvertit les tableaux en Sets après le chargement pour les succès
            if (parsedState.userProfile && parsedState.userProfile.achievements) {
                Object.values(parsedState.userProfile.achievements).forEach(ach => {
                    if (ach.qualifyingData && Array.isArray(ach.qualifyingData)) {
                        ach.qualifyingData = new Set(ach.qualifyingData);
                    }
                });
            }
            
            // --- AJOUT CLÉ ICI : On s'assure que toutes les propriétés sont des tableaux ---
            parsedState.workouts = parsedState.workouts || [];
            parsedState.meals = parsedState.meals || [];
            parsedState.workoutTags = parsedState.workoutTags || [];
            parsedState.mealTags = parsedState.mealTags || [];
            parsedState.calendarEvents = parsedState.calendarEvents || [];
            parsedState.sessionHistory = parsedState.sessionHistory || [];
            // Assurez-vous que les objets imbriqués ont également des valeurs par défaut
            if (parsedState.userProfile) {
                if (parsedState.userProfile.inventory) {
                    parsedState.userProfile.inventory.borders = parsedState.userProfile.inventory.borders || [];
                    parsedState.userProfile.inventory.titles = parsedState.userProfile.inventory.titles || [];
                    parsedState.userProfile.inventory.collectibles = parsedState.userProfile.inventory.collectibles || [];
                }
                if (parsedState.userProfile.quests) {
                    parsedState.userProfile.quests.daily = parsedState.userProfile.quests.daily || [];
                    parsedState.userProfile.quests.weekly = parsedState.userProfile.quests.weekly || [];
                }
            }
            // --- FIN DE L'AJOUT CLÉ ---

            // On fusionne l'état sauvegardé avec l'état par défaut pour plus de sécurité.
            state = deepMerge(state, parsedState);
        } catch (error) {
            console.error("Échec du chargement de l'état sauvegardé :", error);
        }
    }
}

async function loadAndCacheUserGymData(gymId) {
    try {
        const gymRef = doc(db, 'gyms', gymId);
        const gymSnap = await getDoc(gymRef);
        if (!gymSnap.exists()) throw new Error("Gym document not found");

        const gymData = { id: gymSnap.id, ...gymSnap.data() };
        state.currentGymData = gymData;

        const memberPromises = gymData.members.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
        const memberDocs = await Promise.all(memberPromises);
        state.currentGymMembersData = memberDocs.map(d => d.exists() ? d.data() : null).filter(Boolean);

        if (state.activePage === 'Social') {
            render();
        }
    } catch (error) {
        console.error("Error loading gym data:", error);
        // En cas d'erreur, on retire l'ID de la salle du profil pour éviter les boucles
        state.userProfile.gymId = null;
        state.currentGymData = null;
        state.currentGymMembersData = null;
        await updateDoc(doc(db, 'users', currentUserId), { 'userProfile.gymId': null });
    }
}

let markers = [];

async function searchGymsInCity(query) {
    if (query.length < 3) return;

    if (!map) {
        console.warn("La carte n'est pas encore prête. Veuillez patienter.");
        return;
    }

    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ 'address': query }, async (results, status) => {
        if (status === 'OK' && results[0]) {
            const location = results[0].geometry.location;
            map.setCenter(location);
            map.setZoom(13);

            markers.forEach(m => m.setMap(null));
            markers = [];

            // Correction: Utilisez 'locationRestriction' et 'includedPrimaryTypes'
            // au lieu de 'query'
            const request = {
                locationRestriction: {
                    center: location,
                    radius: 5000,
                },
                includedPrimaryTypes: ['gym'],
            };
            
            try {
                // Utilisez la méthode promise-based searchNearby
                const { places } = await google.maps.places.Place.searchNearby(request);
                
                if (places && places.length > 0) {
                    for (let i = 0; i < places.length; i++) {
                        createMarker(places[i]);
                    }
                } else {
                    console.log("No places found.");
                }
            } catch (error) {
                console.error("Error during searchNearby call:", error);
            }
        } else {
            console.error("Geocode was not successful for the following reason: " + status);
        }
    });
}

function searchCityPredictions(query, resultsContainer) {
    if (query.length < 3 || !autocompleteService || !resultsContainer) {
        if(resultsContainer) resultsContainer.innerHTML = '';
        return;
    }

    const request = {
        input: query,
        types: ['(cities)'],
        componentRestrictions: { 'country': ['fr'] }
    };

    autocompleteService.getPlacePredictions(request, (predictions, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK) {
            // On appelle notre nouvelle fonction flexible
            renderCityPredictions(predictions, resultsContainer);
        } else {
            console.error("Autocomplete error:", status);
            resultsContainer.innerHTML = `<div class="p-3 text-red-400">Erreur lors de la recherche.</div>`;
        }
    });
}

function renderCityPredictions(predictions, container) {
    if (!container) return;

    if (!predictions || predictions.length === 0) {
        container.innerHTML = '';
        return;
    }

    container.innerHTML = predictions.map(p => `
        <button class="w-full text-left p-3 rounded-lg hover:bg-white/10" data-place-id="${p.place_id}" data-description="${p.description}">
            <i class="fa-solid fa-location-dot text-gray-500 mr-2"></i>
            <span>${p.description}</span>
        </button>
    `).join('');
}

function createMarker(place) {
    if (!place.geometry || !place.geometry.location) return;

    const marker = new google.maps.Marker({
        map,
        position: place.location,
        title: place.name
    });

    markers.push(marker);
}

function createMusicParticle() {
            // LIGNE AJOUTÉE : On récupère le bouton du vinyle, c'était l'oubli qui causait l'erreur.
            const vinylBtn = document.getElementById('toggle-clan-music-btn-vinyl');
            if (!vinylBtn) return; // Sécurité pour éviter les erreurs si le bouton n'est pas visible

            const particle = document.createElement('div');
            particle.className = 'particle';
            
            vinylBtn.parentElement.appendChild(particle);

            particle.style.filter = `saturate(2) hue-rotate(${Math.random() * 360}deg)`;

            particle.style.left = `${vinylBtn.offsetLeft + vinylBtn.offsetWidth / 2 - 5}px`;
            particle.style.top = `${vinylBtn.offsetTop + vinylBtn.offsetHeight / 2 - 5}px`;

            const angle = Math.random() * Math.PI * 2;
            const radius = 40 + Math.random() * 50;
            const tx = `${Math.cos(angle) * radius}px`;
            const ty = `${Math.sin(angle) * radius}px`;
            particle.style.setProperty('--tx', tx);
            particle.style.setProperty('--ty', ty);

            particle.addEventListener('animationend', () => {
                if (particle.parentElement) {
                    particle.parentElement.removeChild(particle);
                }
            });
        }

        function startParticleEffect() {
            // LIGNE AJOUTÉE : On ajoute la classe "playing" pour démarrer l'animation CSS.
            const vinyl = document.getElementById('toggle-clan-music-btn-vinyl');
            if(vinyl) vinyl.classList.add('playing');

            if (particleInterval) clearInterval(particleInterval);
            particleInterval = setInterval(createMusicParticle, 200);
        }

        function stopParticleEffect() {
            // LIGNE AJOUTÉE : On retire la classe "playing" pour mettre l'animation en pause.
            const vinyl = document.getElementById('toggle-clan-music-btn-vinyl');
            if(vinyl) vinyl.classList.remove('playing');
            
            // Correction : On nettoie bien l'intervalle.
            clearInterval(particleInterval);
            particleInterval = null;
        }

function renderGymList(places, isFromCache = false) {
    const listContainer = document.getElementById('gym-results-list');
    if (!listContainer) return;

    if (!places || places.length === 0) {
        listContainer.innerHTML = `<p class="text-center text-gray-500 pt-8">Aucune salle trouvée dans cette zone.</p>`;
        return;
    }

    listContainer.innerHTML = places.map(place => {
        // **CORRECTION: Handle both data structures**
        const lat = isFromCache ? place.location.lat : place.location.lat();
        const lng = isFromCache ? place.location.lng : place.location.lng();

        return `
        <button 
            class="w-full text-left glass-card p-3 rounded-xl hover:bg-white/10 transition-colors"
            data-action="view-gym-on-map"
            data-place-id="${place.id}"
            data-lat="${lat}"
            data-lng="${lng}"
            data-name="${place.displayName}"
            data-address="${place.formattedAddress}"
        >
            <p class="font-bold">${place.displayName}</p>
            <p class="text-sm text-gray-400">${place.formattedAddress || 'Adresse non disponible'}</p>
        </button>
        `
    }).join('');
}

async function joinGym(placeId, placeName, placeAddress) {
    if (!currentUserId) { showToast("Vous devez être connecté.", "error"); return false; }
    if (state.userProfile.gymId) { showToast("Vous êtes déjà dans une salle. Quittez-la d'abord.", "error"); return false; }

    const gymRef = doc(db, 'gyms', placeId);
    const userRef = doc(db, 'users', currentUserId);

    try {
        // NOUVELLE ÉTAPE : On géocode l'adresse AVANT la transaction
        const geocoder = new google.maps.Geocoder();
        const geocodeResult = await new Promise((resolve, reject) => {
            geocoder.geocode({ 'address': placeAddress }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    resolve(results[0].geometry.location);
                } else {
                    reject(new Error("Geocoding failed: " + status));
                }
            });
        });

        const location = { lat: geocodeResult.lat(), lng: geocodeResult.lng() };

        // Transaction Firestore
        await runTransaction(db, async (transaction) => {
            const gymDoc = await transaction.get(gymRef);
            if (!gymDoc.exists()) {
                // On inclut les coordonnées lors de la création
                transaction.set(gymRef, { name: placeName, address: placeAddress, members: [currentUserId], location: location });
            } else {
                // Si la salle existe mais n'a pas de coordonnées (ancienne donnée), on les ajoute.
                const gymData = gymDoc.data();
                const updates = { members: arrayUnion(currentUserId) };
                if (!gymData.location) {
                    updates.location = location;
                }
                transaction.update(gymRef, updates);
            }
            transaction.update(userRef, { 'userProfile.gymId': placeId });
        });

        const newGymDoc = await getDoc(gymRef);
        if (newGymDoc.exists()) {
            state.userProfile.gymId = placeId;
            state.currentGymData = { id: newGymDoc.id, ...newGymDoc.data() };
            await saveState(); 
        }

        showToast(`Bienvenue à ${placeName} !`, "success");
        return true;

    } catch (error) {
        console.error("Erreur pour rejoindre la salle :", error);
        showToast("Une erreur est survenue.", "error");
        return false;
    }
}

async function openPublicGymViewModal(placeId, placeName, placeAddress, isNested = false) {
    showToast("Chargement de la salle...", "info");

    let membersHtml = '<p class="text-center text-gray-500 py-4">Personne de FitFlow n\'est encore ici. Soyez le premier !</p>';
    const gymRef = doc(db, 'gyms', placeId);
    const gymSnap = await getDoc(gymRef);
    let membersData = [];
    let gymLocation = null; // Variable pour stocker la localisation

    if (gymSnap.exists()) {
        const gymData = gymSnap.data();
        gymLocation = gymData.location; // On récupère la localisation si elle a été sauvegardée
        const memberUids = gymData.members || [];
        if (memberUids.length > 0) {
            const memberPromises = memberUids.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
            const memberDocs = await Promise.all(memberPromises);
            membersData = memberDocs.map(doc => doc.exists() ? doc.data() : null).filter(Boolean);
            membersHtml = membersData.map(member => renderUnifiedUserCard(member, 'public-gym-member')).join('');
        }
    }

    const { averageRank, color: rankColor } = calculateAverageRank(membersData);

    let buttonHtml;
    if (state.userProfile.gymId === placeId) {
        buttonHtml = `<button class="w-full mt-6 btn-primary opacity-50 cursor-not-allowed" disabled>C'est votre salle</button>`;
    } else if (state.userProfile.gymId) {
        buttonHtml = `<button class="w-full mt-6 btn-primary opacity-50 cursor-not-allowed" disabled>Quittez votre salle actuelle d'abord</button>`;
    } else {
        buttonHtml = `<button id="join-gym-btn" class="w-full mt-6 btn-primary">Rejoindre cette salle</button>`;
    }

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col relative">
        <button class="close-modal absolute top-4 right-4 w-8 h-8 rounded-full bg-black/20 z-20 flex items-center justify-center text-xl hover:bg-white/10">&times;</button>
        <header class="text-center mb-4 flex-shrink-0">
            <i class="fa-solid fa-dumbbell text-4xl mb-2 text-violet-300"></i>
            <h1 class="text-2xl font-extrabold">${placeName}</h1>
            <p class="text-gray-400 text-sm">${placeAddress}</p>
            <p class="text-gray-400 font-semibold text-sm">
                Rang: 
                <span class="font-bold flex items-center justify-center gap-1.5" style="color: ${rankColor};">
                    ${getRankBadgeSVG(averageRank, '24px')}
                    <span>${averageRank}</span>
                </span>
            </p>
        </header>
        <div id="gym-modal-map" class="w-full h-48 rounded-xl my-4 bg-gray-800 flex-shrink-0"></div>
        <div class="flex-grow overflow-y-auto pr-2 space-y-2 scrollbar-hide min-h-0">
            <h2 class="font-bold text-lg text-center my-2">Membres FitFlow</h2>
            ${membersHtml}
        </div>
        ${buttonHtml}
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        const mapDiv = modalWrapper.querySelector('#gym-modal-map');
        
        const initializeMapWithLocation = (location) => {
             const modalMap = new google.maps.Map(mapDiv, {
                center: location, zoom: 15, disableDefaultUI: true
            });
            new google.maps.Marker({ position: location, map: modalMap, title: placeName });
        };
        
        // **OPTIMISATION**
        if (gymLocation) {
            // Si les coordonnées sont déjà dans Firestore, on les utilise. C'est rapide et gratuit.
            console.log("✅ Carte de la modale affichée depuis les données Firestore.");
            initializeMapWithLocation(gymLocation);
        } else {
            // Sinon, on fait l'appel Geocode de secours.
            console.warn("Coordonnées manquantes pour la modale, appel Geocode de secours.");
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ 'address': placeAddress }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    initializeMapWithLocation(results[0].geometry.location);
                } else {
                    console.error('Le Geocode a échoué pour l\'adresse :', placeAddress, 'Raison :', status);
                    mapDiv.innerHTML = '<p class="text-center text-red-400 p-4">Impossible de charger la carte.</p>';
                }
            });
        }

        modalWrapper.addEventListener('click', (e) => {
            const profileBtn = e.target.closest('[data-action="view-public-profile"]');
            if (profileBtn) {
                openPublicProfileModal(profileBtn.dataset.uid, true);
                e.stopPropagation(); 
            }
        });

        const joinBtn = modalWrapper.querySelector('#join-gym-btn');
        if (joinBtn) {
            joinBtn.onclick = async () => {
                const success = await joinGym(placeId, placeName, placeAddress);
                if (success) {
                    closeModal();
                    // On ne force plus la navigation ici, on laisse l'utilisateur où il est.
                    render();
                }
            };
        }
    }, null, isNested);
}

function openBlockEditorPanel() {
    if (!state.editingDay) return;

    const day = state.editingDay;

    const panelHtml = `
    <div id="block-editor-container">
        <div id="block-editor-backdrop"></div>
        <div id="block-editor-panel">
            <header class="p-4 border-b border-white/10 flex justify-between items-center flex-shrink-0">
                <input type="text" value="${day.title}" class="text-xl font-bold bg-transparent w-full focus:outline-none focus:bg-white/5 rounded-lg px-2 -mx-2">
                <button id="close-block-editor" class="text-gray-400 hover:text-white w-8 h-8 rounded-full bg-black/20"><i class="fa-solid fa-xmark"></i></button>
            </header>
            <div id="block-list-container" class="flex-grow p-4 overflow-y-auto">
                <div class="text-center text-gray-500 pt-16">
                    <i class="fa-solid fa-cube text-5xl mb-4"></i>
                    <p>Ce jour est vide.</p>
                    <p>Ajoutez votre premier bloc !</p>
                </div>
            </div>
            <footer class="p-4 border-t border-white/10 flex-shrink-0">
                <button id="add-block-btn" class="w-full btn-primary"><i class="fa-solid fa-plus mr-2"></i>Ajouter un bloc</button>
            </footer>
        </div>
    </div>
    `;
    
    document.getElementById('global-modal-container').innerHTML = panelHtml;
    const container = document.getElementById('block-editor-container');

    // AJOUT : On active les clics pour ce conteneur spécifique.
    container.style.pointerEvents = 'auto';

    setTimeout(() => container.classList.add('active'), 10);

    const closePanel = () => {
        container.classList.remove('active');
        container.addEventListener('transitionend', () => {
            // AJOUT : On désactive les clics sur le conteneur global une fois la modale retirée.
            document.getElementById('global-modal-container').style.pointerEvents = 'none';
            container.remove();
        }, { once: true });
        state.editingDay = null; 
    };
    
    container.querySelector('#block-editor-backdrop').onclick = closePanel;
    container.querySelector('#close-block-editor').onclick = closePanel;
    container.querySelector('#add-block-btn').onclick = () => {
        openBlockLibraryModal(); // AU LIEU de showToast(...)
    };
    container.querySelector('input').addEventListener('input', (e) => {
        if (state.editingDay) {
            state.editingDay.title = e.target.value;
            const mainDayCard = document.querySelector(`.day-card[data-day-id="${state.editingDay.id}"] .day-title`);
            if (mainDayCard) mainDayCard.textContent = e.target.value;
        }
    });
}

function addBlockToDay(blockType) {
    if (!state.editingDay) return;

    // 1. Créer le nouveau bloc avec du contenu par défaut
    const newBlock = {
        id: generateId(),
        type: blockType,
        content: {}
    };
    switch(blockType) {
        case 'text': newBlock.content.html = '<p>Votre texte ici...</p>'; break;
        case 'workout': newBlock.content.refId = state.workouts.length > 0 ? state.workouts[0].id : null; break;
        // Ajoutez d'autres cas par défaut pour les futurs blocs ici
    }

    // 2. L'ajouter à notre jour en cours d'édition
    state.editingDay.blocks.push(newBlock);

    // 3. Fermer la modale de la bibliothèque
    closeModal();
    
    // 4. Mettre à jour l'affichage du panneau d'édition
    renderDayEditorContent();
    
    // 5. Mettre à jour l'aperçu sur la page principale
    render();
}

// Cette fonction rafraîchit la liste des blocs dans le panneau latéral
function renderDayEditorContent() {
    if (!state.editingDay) return;
    
    const container = document.getElementById('block-list-container');
    if (!container) return;

    const day = state.editingDay;

    if (day.blocks.length === 0) {
        container.innerHTML = `
            <div class="text-center text-gray-500 pt-16">
                <i class="fa-solid fa-cube text-5xl mb-4"></i>
                <p>Ce jour est vide.</p><p>Ajoutez votre premier bloc !</p>
            </div>`;
    } else {
        container.innerHTML = day.blocks.map(block => `
            <div class="glass-card p-3 rounded-lg mb-3">
                <p class="font-bold text-sm">${block.type}</p>
            </div>
        `).join('');
    }
}

async function openPublicGymViewModalFromId(gymId, isNested = false) {
    if (!gymId) return;
    const gymRef = doc(db, 'gyms', gymId);
    const gymSnap = await getDoc(gymRef);

    if (!gymSnap.exists()) {
        showToast("Cette salle est introuvable.", "error");
        return;
    }
    const gymData = gymSnap.data();
    openPublicGymViewModal(gymId, gymData.name, gymData.address, isNested);
}

function checkDailyGoalQuests() {
    const today = new Date();
    const todayStr = formatDateToYYYYMMDD(today);
    
    // On filtre les repas validés pour le jour en cours
    const validatedMeals = state.calendarEvents.filter(e => e.type === 'meal' && e.validated && e.date === todayStr);

    const todayMacros = validatedMeals.reduce((acc, event) => {
        const meal = state.meals.find(m => m.id === event.refId);
        if (meal) {
            acc.calories += meal.nutrition.calories;
            acc.protein += meal.nutrition.protein;
        }
        return acc;
    }, { calories: 0, protein: 0 });

    // On utilise `updateQuestProgress` avec 'set' pour réinitialiser la progression
    const hasReachedCalories = todayMacros.calories >= state.userGoals.calories ? 1 : 0;
    updateQuestProgress('reach_calorie_goal', hasReachedCalories, { mode: 'set' });
    
    const hasReachedProtein = todayMacros.protein >= state.userGoals.protein ? 1 : 0;
    updateQuestProgress('reach_protein_goal', hasReachedProtein, { mode: 'set' });
    
    // On appelle `updateQuestProgress` pour la série nutritionnelle.
    updateQuestProgress('reach_nutrition_goals_days', hasReachedCalories, { date: todayStr });
    updateQuestProgress('reach_protein_goal_days', hasReachedProtein, { date: todayStr });
    
    // Si on est sur la page des quêtes, on rend l'affichage
    if (state.activePage === 'Quêtes') {
        render();
    }
}

        function checkAndResetQuests() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
    
    const dayOfWeek = now.getDay();
    const daysSinceLastSunday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    const lastSunday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - daysSinceLastSunday).toISOString();

    const quests = state.userProfile.quests;

    const pickRandomQuests = (source, count) => {
        const shuffled = [...source].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count).map(q => ({
            id: q.id,
            progress: 0,
            completed: false,
            claimed: false
        }));
    };

    // Réinitialisation journalière
    if (quests.lastDailyReset !== today) {
        quests.lastDailyReset = today;
        const workoutDaily = pickRandomQuests(QUEST_DATABASE.workout.daily, 2);
        const nutritionDaily = pickRandomQuests(QUEST_DATABASE.nutrition.daily, 2);
        quests.daily = [...workoutDaily, ...nutritionDaily];
        console.log("Nouvelles quêtes journalières générées.");
    }

    // Réinitialisation hebdomadaire
    if (quests.lastWeeklyReset !== lastSunday) {
        quests.lastWeeklyReset = lastSunday;
        const workoutWeekly = pickRandomQuests(QUEST_DATABASE.workout.weekly, 2);
        const nutritionWeekly = pickRandomQuests(QUEST_DATABASE.nutrition.weekly, 2);
        quests.weekly = [...workoutWeekly, ...nutritionWeekly];
        console.log("Nouvelles quêtes hebdomadaires générées.");
    }
}

function checkDailyMealQuests() {
    const todayStr = formatDateToYYYYMMDD(new Date());
    const validatedMeals = state.calendarEvents.filter(e => e.type === 'meal' && e.validated && e.date === todayStr);

    // Recalcul de la quête 'Valider un total de X repas'
    const mealsValidatedCount = validatedMeals.length;
    updateQuestProgress('log_meals_count', mealsValidatedCount, { mode: 'set' });

    // Recalcul des quêtes 'high_fitscore_meal' et 'high_protein_meal'
    let highFitscoreMealsCount = 0;
    let highProteinMealsCount = 0;

    validatedMeals.forEach(event => {
        const meal = state.meals.find(m => m.id === event.refId);
        if (meal) {
            // Incrémente le compteur de 1 pour chaque repas qui remplit la condition
            if (meal.fitScore >= 75) {
                highFitscoreMealsCount++;
            }
            if (meal.nutrition.protein >= 40) {
                highProteinMealsCount++;
            }
        }
    });

    // On met à jour les quêtes avec le nombre total de repas qui remplissent les conditions
    updateQuestProgress('high_fitscore_meal', highFitscoreMealsCount, { mode: 'set' });
    updateQuestProgress('high_protein_meal', highProteinMealsCount, { mode: 'set' });
}

function checkWeeklyNutritionQuests() {
    const now = new Date();
    const dayOfWeek = now.getDay() === 0 ? 6 : now.getDay() - 1; // Lundi = 0, Dimanche = 6
    const startOfWeek = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek);
    startOfWeek.setHours(0, 0, 0, 0);

    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 7);
    
    // Filtre les repas validés pour la semaine en cours
    const weeklyValidatedMeals = state.calendarEvents.filter(e => {
        const mealDate = new Date(e.date + 'T00:00:00');
        return e.type === 'meal' && e.validated && mealDate >= startOfWeek && mealDate < endOfWeek;
    });

    const totalWeeklyCalories = weeklyValidatedMeals.reduce((sum, event) => {
        const meal = state.meals.find(m => m.id === event.refId);
        if (meal) {
            return sum + (meal.nutrition.calories || 0);
        }
        return sum;
    }, 0);

    // Met à jour la quête avec le total des calories de la semaine
    updateQuestProgress('total_calories_logged', totalWeeklyCalories, { mode: 'set' });
    
    // Met à jour la quête de création de repas
    const newMealsCreated = state.meals.filter(m => m.creationDate >= startOfWeek && !m.isQuickAdd).length;
    updateQuestProgress('create_new_meal', newMealsCreated, { mode: 'set' });

    // Met à jour la quête de validation de repas
    const totalMealsValidated = weeklyValidatedMeals.length;
    updateQuestProgress('log_meals_count_weekly', totalMealsValidated, { mode: 'set' });
}

function updateQuestBadge() {
    const count = getClaimableQuestsCount();
    const questsButton = document.querySelector('#open-quests-modal');
    if (!questsButton) return;

    let badge = questsButton.querySelector('.notification-badge');

    if (count > 0) {
        if (!badge) {
            badge = document.createElement('span');
            badge.className = 'notification-badge';
            questsButton.appendChild(badge);
        }
        badge.textContent = count;
    } else if (badge) {
        badge.remove();
    }
}

        function updateQuestProgress(type, value, options = {}) {
    const { quests } = state.userProfile;
    // CORRECTION : On s'assure que les tableaux existent avant de les fusionner
    const allActiveQuests = [...(quests.daily || []), ...(quests.weekly || [])];

    allActiveQuests.forEach(activeQuest => {
        if (activeQuest.completed) return;

        const questInfo = getQuestInfo(activeQuest.id);
        if (!questInfo || questInfo.type !== type) return;

        switch (type) {
            case 'train_all_muscle_groups':
                // CORRECTION : S'assurer que qualifyingData est un tableau
                activeQuest.qualifyingData = activeQuest.qualifyingData || [];
                if (options.muscleGroup && !activeQuest.qualifyingData.includes(options.muscleGroup)) {
                    activeQuest.qualifyingData.push(options.muscleGroup);
                }
                activeQuest.progress = activeQuest.qualifyingData.length;
                break;
            case 'reach_nutrition_goals_days':
            case 'reach_protein_goal_days':
                // CORRECTION : S'assurer que qualifyingData est un tableau
                activeQuest.qualifyingData = activeQuest.qualifyingData || [];
                const todayStr = formatDateToYYYYMMDD(new Date());
                if (!activeQuest.qualifyingData.includes(todayStr)) {
                    activeQuest.qualifyingData.push(todayStr);
                }
                activeQuest.progress = activeQuest.qualifyingData.length;
                break;
            case 'nutrition_streak':
                activeQuest.progress = Math.max(activeQuest.progress, value);
                break;
            // --- NOUVEAU CAS : Gère les quêtes de protéines et FitScore ---
            case 'high_protein_meal':
            case 'high_fitscore_meal':
                if (options.mode !== 'set') {
                    activeQuest.progress += 1;
                } else {
                    activeQuest.progress = value;
                }
                break;
            // --- FIN DU NOUVEAU CAS ---
            default:
                if (options.mode === 'set') {
                    activeQuest.progress = value;
                } else {
                    activeQuest.progress += value;
                }
                break;
        }

        if (activeQuest.progress >= questInfo.goal && !activeQuest.completed) {
            activeQuest.completed = true;
            activeQuest.progress = questInfo.goal;
            showToast(`Quête "${questInfo.description}" accomplie !`, 'success');

            if (state.activePage === 'Quêtes') {
                render();
            } else {
                updateQuestBadge();
            }
        }
    });
}

function getClaimableQuestsCount() {
    const { daily, weekly } = state.userProfile.quests;
    let count = 0;
    if (daily) {
        count += daily.filter(q => q.completed && !q.claimed).length;
    }
    if (weekly) {
        count += weekly.filter(q => q.completed && !q.claimed).length;
    }
    return count;
}

async function claimQuestReward(questId) {
    const { daily, weekly } = state.userProfile.quests;
    const questToClaim = [...daily, ...weekly].find(q => q.id === questId);
    
    if (!questToClaim || !questToClaim.completed || questToClaim.claimed) {
        return;
    }

    const questInfo = getQuestInfo(questId);
    if (!questInfo) return;

    // 1. Mise à jour de l'état (données)
    questToClaim.claimed = true;
    const { xp, coins } = questInfo.rewards;
    addXP(xp);
    state.userProfile.coins += coins;
    showToast(`+${xp} XP & +${coins} pièces !`, 'success');

    // 2. Mise à jour "en direct" de l'interface (DOM)
    const questsPage = document.getElementById('quests-page-content');
    if (questsPage) {
        const questCard = questsPage.querySelector(`.quest-card-v2[data-quest-id="${questId}"]`);
        if (questCard) {
            const button = questCard.querySelector('[data-action="claim-quest"]');
            
            // Appliquer une animation de succès à la carte
            questCard.classList.add('is-claiming');
            questCard.classList.remove('claimable');

            // Mettre à jour le bouton après l'animation
            setTimeout(() => {
                if (button) {
                    button.disabled = true;
                    button.innerHTML = `<i class="fa-solid fa-check mr-1.5"></i>Récupéré`;
                    button.classList.remove('claim-btn');
                    button.classList.add('claimed-btn');
                    button.removeAttribute('data-action');
                }
            }, 200); // Délai pour la transition
        }
    }

    // 3. Mettre à jour le badge sur l'icône de l'accueil
    updateQuestBadge();
    await saveState();
}

function getFriendshipStatus(targetUserId) {
    const friends = state.friends || { accepted: [], pendingSent: [], pendingReceived: [] };
    
    // CORRECTION : On vérifie simplement l'inclusion de l'UID
    if (friends.accepted && friends.accepted.includes(targetUserId)) {
        return 'friends';
    }
    if (friends.pendingSent && friends.pendingSent.includes(targetUserId)) {
        return 'pending';
    }
    if (friends.pendingReceived && friends.pendingReceived.includes(targetUserId)) {
        return 'received';
    }
    return 'none';
}

async function sendFriendRequest(recipientId) {
    if (!currentUserId || recipientId === currentUserId) return false;

    const senderRef = doc(db, 'users', currentUserId);
    const recipientRef = doc(db, 'users', recipientId);

    try {
        await Promise.all([
            updateDoc(senderRef, { 'friends.pendingSent': arrayUnion(recipientId) }),
            updateDoc(recipientRef, { 'friends.pendingReceived': arrayUnion(currentUserId) })
        ]);

        await addDoc(collection(db, 'inboxMessages'), {
            recipientUid: recipientId,
            senderUid: currentUserId,
            senderName: state.userProfile.name,
            senderProfilePicUrl: state.userProfile.profilePicUrl,
            type: 'friendRequest',
            timestamp: serverTimestamp(),
            isRead: false
        });

        state.friends.pendingSent.push(recipientId);
        showToast("Demande d'ami envoyée !", "success");
        return true; // Indique le succès

    } catch (error) {
        console.error("Erreur lors de l'envoi de la demande d'ami:", error);
        showToast("Une erreur est survenue.", "error");
        return false; // Indique l'échec
    }
}

async function cancelFriendRequest(recipientId) {
    if (!currentUserId) return false;

    const senderRef = doc(db, 'users', currentUserId);
    const recipientRef = doc(db, 'users', recipientId);

    try {
        await Promise.all([
            updateDoc(senderRef, { 'friends.pendingSent': arrayRemove(recipientId) }),
            updateDoc(recipientRef, { 'friends.pendingReceived': arrayRemove(currentUserId) })
        ]);

        const q = query(collection(db, 'inboxMessages'), 
            where('recipientUid', '==', recipientId), 
            where('senderUid', '==', currentUserId),
            where('type', '==', 'friendRequest')
        );
        const snapshot = await getDocs(q);
        const deletePromises = [];
        snapshot.forEach(doc => {
            deletePromises.push(deleteDoc(doc.ref));
        });
        await Promise.all(deletePromises);

        state.friends.pendingSent = state.friends.pendingSent.filter(id => id !== recipientId);
        showToast("Demande annulée.", "info");
        return true; // Indique le succès

    } catch (error) {
        console.error("Erreur lors de l'annulation de la demande:", error);
        showToast("Une erreur est survenue.", "error");
        return false; // Indique l'échec
    }
}

async function respondToFriendRequest(senderId, messageId, accepted) {
    if (!currentUserId) return;
    
    const currentUserRef = doc(db, 'users', currentUserId);
    const senderRef = doc(db, 'users', senderId);
    const messageRef = doc(db, 'inboxMessages', messageId);

    try {
        await runTransaction(db, async (transaction) => {
            const currentUserDoc = await transaction.get(currentUserRef);
            if (!currentUserDoc.exists()) throw "Votre document n'existe pas.";
            
            const friends = currentUserDoc.data().friends || {};
            if (!friends.pendingReceived || !friends.pendingReceived.includes(senderId)) {
                throw "Cette demande d'ami n'est plus valide.";
            }

            transaction.update(currentUserRef, { 'friends.pendingReceived': arrayRemove(senderId) });
            transaction.update(senderRef, { 'friends.pendingSent': arrayRemove(currentUserId) });
            
            if (accepted) {
    transaction.update(currentUserRef, { 'friends.accepted': arrayUnion(senderId) });
    transaction.update(senderRef, { 'friends.accepted': arrayUnion(currentUserId) });

    const timestampKey = `friendshipTimestamps.${senderId}`;
    const timestampKeyForSender = `friendshipTimestamps.${currentUserId}`;

    transaction.update(currentUserRef, { [timestampKey]: serverTimestamp() });
    
    transaction.update(senderRef, { [timestampKeyForSender]: serverTimestamp() }); 
}

            transaction.delete(messageRef);
        });
        
        const senderProfile = await getDoc(doc(db, 'publicProfiles', currentUserId));
        await addDoc(collection(db, 'inboxMessages'), {
            recipientUid: senderId,
            senderUid: currentUserId,
            senderName: senderProfile.data().name,
            senderProfilePicUrl: senderProfile.data().profilePicUrl,
            type: accepted ? 'requestAccepted' : 'requestDeclined',
            timestamp: serverTimestamp(),
            isRead: false
        });

        // --- CORRECTION APPLIQUÉE ICI ---
        // Mise à jour de l'état local pour une réactivité instantanée
        state.friends.pendingReceived = state.friends.pendingReceived.filter(id => id !== senderId);
        if (accepted) { 
            if (!state.friends.accepted.includes(senderId)) {
                state.friends.accepted.push(senderId);
            }
            // On s'assure que l'objet existe avant d'y ajouter la date
            if (!state.friends.friendshipTimestamps) {
                state.friends.friendshipTimestamps = {};
            }
            // On ajoute la date actuelle à l'état local.
            // Elle sera remplacée par la date précise du serveur au prochain rafraîchissement,
            // mais l'utilisateur verra la date correcte immédiatement.
            state.friends.friendshipTimestamps[senderId] = new Date();
        }
        // --- FIN DE LA CORRECTION ---
        
        showToast(accepted ? "Ami ajouté !" : "Demande refusée.", "info");
        closeModal();
        renderInboxMessages();

    } catch (error) {
        console.error("Erreur lors de la réponse (transaction) :", error);
        showToast(String(error), "error");
        renderInboxMessages();
    }
}

async function removeFriend(friendId) {
    if (!currentUserId) return false;

    const currentUserRef = doc(db, 'users', currentUserId);
    const friendRef = doc(db, 'users', friendId);

    try {
        await runTransaction(db, async (transaction) => {
            const currentUserDoc = await transaction.get(currentUserRef);
            const friendDoc = await transaction.get(friendRef);

            if (!currentUserDoc.exists() || !friendDoc.exists()) {
                throw "Un des documents utilisateur est introuvable.";
            }

            // On retire l'UID du tableau d'amis
            transaction.update(currentUserRef, { 'friends.accepted': arrayRemove(friendId) });
            transaction.update(friendRef, { 'friends.accepted': arrayRemove(currentUserId) });
            
            // On supprime l'horodatage de l'objet de timestamps
            const timestampKey = `friendshipTimestamps.${friendId}`;
            const timestampKeyForFriend = `friendshipTimestamps.${currentUserId}`;

            transaction.update(currentUserRef, { [timestampKey]: deleteField() });
            transaction.update(friendRef, { [timestampKeyForFriend]: deleteField() });
        });
        
        // Mise à jour de l'état local
        state.friends.accepted = state.friends.accepted.filter(id => id !== friendId);
        if (state.friends.friendshipTimestamps) {
             delete state.friends.friendshipTimestamps[friendId];
        }

        showToast("Ami supprimé.", "info");
        return true;

    } catch (error) {
        console.error("Erreur lors de la suppression de l'ami:", error);
        showToast("Une erreur est survenue.", "error");
        return false;
    }
}

async function openRemoveFriendConfirmationModal(friendId) {
    const friendDoc = await getDoc(doc(db, 'publicProfiles', friendId));
    if (!friendDoc.exists()) {
        showToast("Utilisateur introuvable.", "error");
        return;
    }
    const friendName = friendDoc.data().name;

    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Supprimer cet ami ?</h2>
        <p class="text-gray-400 mb-6">Êtes-vous sûr de vouloir supprimer <strong class="text-white">${friendName}</strong> de votre liste d'amis ?</p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-delete-btn" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Supprimer</button>
        </div>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        // Logique du clic sur le bouton de confirmation
        modalWrapper.querySelector('#confirm-delete-btn').onclick = async () => {
            const success = await removeFriend(friendId);
            
            // On ferme la modale dans tous les cas
            closeModal();
        };

        // Le bouton "Annuler" ferme aussi la modale
        modalWrapper.querySelector('.cancel').onclick = () => {
            closeModal();
        };
    });
}

async function markNotificationsAsReadAndDelete() {
    if (!currentUserId) return;

    try {
        // --- CORRECTION APPLIQUÉE ICI ---
        // On ne cible que les messages qui sont purement informatifs (acceptation/refus)
        // et qui n'attendent pas d'action de l'utilisateur.
        const deletableTypes = ['requestAccepted', 'requestDeclined'];
        
        const q = query(collection(db, 'inboxMessages'),
            where('recipientUid', '==', currentUserId),
            where('type', 'in', deletableTypes)
        );
        const snapshot = await getDocs(q);

        if (snapshot.empty) return;

        const batch = writeBatch(db);
        snapshot.forEach(doc => {
            batch.delete(doc.ref);
        });
        await batch.commit();
        
        console.log(`${snapshot.size} notifications lues ont été supprimées.`);

    } catch (error) {
        console.error("Erreur lors du nettoyage de la boîte de réception:", error);
    }
}

async function renderInboxMessages() {
    const container = document.getElementById('inbox-messages-container');
    if (!container) return;

    const messages = state.inbox?.unreadMessages || [];

    if (messages.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-500 pt-16 flex flex-col items-center gap-4"><i class="fa-solid fa-envelope-open text-5xl"></i><p>Votre boîte de réception est vide.</p></div>';
        return;
    }

    container.innerHTML = messages.map(message => {
        const isActionable = ['friendRequest', 'clanInvite'].includes(message.type);
        const cardTag = isActionable ? 'div' : 'button';
        const cardAction = isActionable ? '' : `data-action="open-message-details" data-message-id="${message.id}"`;
        const cardCursor = isActionable ? 'cursor-default' : 'cursor-pointer hover:bg-white/5';
        
        let contentHtml = '';
        let senderProfileHtml = '';

        // Bloc pour le profil de l'expéditeur
        const timestampHtml = `<p class="text-xs text-gray-400 font-semibold flex-shrink-0">${formatTimestampForInbox(message.timestamp)}</p>`;
        const isSystemMessage = message.senderUid === 'fitflow_system_tribunal';

        const avatarHtml = isSystemMessage 
            ? `<div class="w-11 h-11 rounded-full bg-gray-700 flex items-center justify-center text-violet-400 flex-shrink-0"><i class="fa-solid ${message.systemIcon || 'fa-robot'} text-xl"></i></div>`
            : renderAvatar(message.senderProfilePicUrl, "w-11 h-11");
        
        const avatarWrapper = isSystemMessage 
            ? avatarHtml 
            : `<div data-action="view-public-profile" data-uid="${message.senderUid}" class="cursor-pointer">${avatarHtml}</div>`;

        senderProfileHtml = `
            <div class="flex items-start justify-between">
                <div class="flex items-center gap-3 min-w-0">
                    ${avatarWrapper}
                    <div class="min-w-0">
                        <p class="font-bold truncate">${message.senderName}</p>
                    </div>
                </div>
                ${timestampHtml}
            </div>`;

        // Bloc pour le contenu du message
        switch (message.type) {
            case 'friendRequest':
                contentHtml = `
                    <p class="text-sm text-gray-300">vous a envoyé une demande d'ami.</p>
                    <div class="flex gap-3 mt-3">
                        <button data-action="accept-request" data-sender-id="${message.senderUid}" data-message-id="${message.id}" class="btn-primary flex-1 text-sm py-2">Accepter</button>
                        <button data-action="decline-request" data-sender-id="${message.senderUid}" data-message-id="${message.id}" class="secondary-btn flex-1 text-sm py-2">Refuser</button>
                    </div>`;
                break;
            case 'clanInvite':
                 contentHtml = `
                    <p class="text-sm text-gray-300">vous invite à rejoindre <strong>${message.clanName}</strong>.</p>
                    <div class="flex gap-3 mt-3">
                        <button data-action="accept-clan-invite" data-clan-id="${message.clanId}" data-message-id="${message.id}" class="btn-primary flex-1 text-sm py-2">Accepter</button>
                        <button data-action="decline-clan-invite" data-clan-id="${message.clanId}" data-message-id="${message.id}" class="secondary-btn flex-1 text-sm py-2">Refuser</button>
                    </div>`;
                break;
            default: // Verdicts, avertissements, etc.
                contentHtml = `
                    <p class="font-bold">${message.subject || 'Notification'}</p>
                    <p class="text-sm text-gray-300 -mt-1 truncate-2-lines">${message.content || ''}</p>`;
                break;
        }

        // Assemblage final de la carte
        return `
        <${cardTag} ${cardAction} class="w-full text-left glass-card p-4 rounded-xl flex flex-col gap-2 transition-colors ${cardCursor}">
            ${senderProfileHtml}
            <div class="pl-14">
                ${contentHtml}
            </div>
        </${cardTag}>`;

    }).join('');
}

async function findGymsFromPlaceId(placeId, placeDescription) {
    if (!placeId) return;

    const cacheRef = doc(db, 'gymCache', placeId);
    
    try {
        const cacheSnap = await getDoc(cacheRef);

        // 1. VÉRIFIER LE CACHE
        if (cacheSnap.exists()) {
            const cacheData = cacheSnap.data();
            const lastUpdated = cacheData.lastUpdated.toDate();
            const ageInDays = (new Date() - lastUpdated) / (1000 * 60 * 60 * 24);

            // Si les données ont moins de 30 jours, on les utilise !
            if (ageInDays < 30) {
                console.log("✅ Résultats servis depuis le cache Firestore !");
                // CORRECTION : On passe 'true' pour indiquer que les données viennent du cache
                renderGymList(cacheData.gyms, true); 
                return; // On arrête la fonction ici, pas besoin d'appel API.
            }
        }

        // 2. SI LE CACHE EST VIDE OU PÉRIMÉ : APPEL À L'API GOOGLE
        console.log("Cache vide ou périmé. Appel à l'API Google Places...");
        
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({ 'placeId': placeId }, async (results, status) => {
            if (status === 'OK' && results[0]) {
                const location = results[0].geometry.location;
                const request = {
                    fields: ['displayName', 'location', 'formattedAddress', 'id'],
                    locationRestriction: { center: location, radius: 5000 },
                    includedPrimaryTypes: ['gym'],
                };

                const { places } = await google.maps.places.Place.searchNearby(request);
                
                // 3. FORMATER ET ÉCRIRE LES NOUVEAUX RÉSULTATS DANS LE CACHE
                const gymsToCache = places.map(place => ({
                    id: place.id,
                    displayName: place.displayName,
                    formattedAddress: place.formattedAddress,
                    // On stocke la localisation dans un format compatible avec Firestore
                    location: { 
                        lat: place.location.lat(), 
                        lng: place.location.lng() 
                    }
                }));

                const newCacheData = {
                    cityName: placeDescription,
                    gyms: gymsToCache,
                    lastUpdated: serverTimestamp()
                };
                
                // On crée ou on écrase le document dans notre cache.
                await setDoc(cacheRef, newCacheData);
                console.log(`Résultats pour "${placeDescription}" mis en cache.`);

                // On affiche les résultats frais à l'utilisateur.
                // CORRECTION : On passe 'false' car les données viennent de l'API live
                renderGymList(places, false);

            } else {
                console.error("Geocode a échoué: " + status);
                showToast("Impossible de trouver les coordonnées de ce lieu.", "error");
            }
        });

    } catch (error) {
        console.error("Erreur lors de la recherche de salles :", error);
        showToast("Une erreur est survenue lors de la recherche.", "error");
    }
}

function handleSocialEvents(e) {
    // Clic sur un bouton d'onglet (Ma Salle / Mon Équipe)
    const tabBtn = e.target.closest('.social-tab-btn');
    if (tabBtn) {
        const tab = tabBtn.dataset.tab;
        if (state.social.activeTab !== tab) {
            state.social.activeTab = tab;
            render(); // Le render s'occupera d'afficher le bon contenu
        }
        return;
    }

    // --- Actions communes ou générales sur la page Sociale ---
    const friendListBtn = e.target.closest('[data-action="open-friend-list"]');
    if (friendListBtn) {
        openFriendListModal();
        return;
    }

    const userCard = e.target.closest('[data-action="view-public-profile"]');
    if (userCard && userCard.dataset.uid) {
        openPublicProfileModal(userCard.dataset.uid);
        return;
    }
    
    // --- Actions spécifiques à la vue "Ma Salle" (My Gym) ---
    if (e.target.closest('#leave-gym-btn')) {
        openLeaveGymConfirmationModal();
        return;
    }
    if (e.target.closest('#open-gym-search-modal-btn')) {
        openGymSearchModal();
        return;
    }
    // Gère la recherche depuis la vue "découverte" (quand on n'a pas de salle)
    handleGymSearchEvents(e);

    // --- Actions spécifiques à la vue "Mon Équipe" (My Clan) ---
    if (e.target.closest('#leave-clan-btn')) {
        const clanData = state.currentClanData;
        if (clanData.chefUid === currentUserId && clanData.members.length > 1) {
            openPromoteNewChefModal();
        } else {
            openLeaveClanConfirmationModal();
        }
        return;
    }
    if (e.target.closest('#invite-to-clan-btn')) {
        openInviteFriendsToClanModal();
        return;
    }
     if (e.target.closest('#open-clan-settings-btn')) {
        openClanSettingsModal();
        return;
    }
    if (e.target.closest('#open-clan-search-modal-btn')) {
        openClanSearchModal();
        return;
    }
     if (e.target.closest('#toggle-clan-mute-btn')) {
        e.stopPropagation();
        state.clanMusicMuted = !state.clanMusicMuted;
        const icon = e.target.closest('#toggle-clan-mute-btn').querySelector('i');
        icon.className = `fa-solid ${state.clanMusicMuted ? 'fa-volume-xmark' : 'fa-volume-high'}`;
        if (state.clanAudioElement) {
            state.clanAudioElement.volume = state.clanMusicMuted ? 0 : 1;
        }
        return;
    }
    // Gère la recherche depuis la vue "sans équipe"
    handleClanEvents(e);
}

async function handleSearchUsersEvents(e) {
    const searchInput = document.getElementById('user-search-input');
    
    if (searchInput && e.type === 'input') {
        if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
        autocompleteTimeout = setTimeout(() => {
            searchUsersByName(searchInput.value);
        }, 300);
    }

    if (e.type === 'click') {
        const profileBtn = e.target.closest('[data-action="view-public-profile"]');
        if (profileBtn) {
            openPublicProfileModal(profileBtn.dataset.uid);
        }
    }
}

function handleInboxEvents(e) {
    // Gère les actions sur les boutons (inchangé)
    const acceptRequestBtn = e.target.closest('[data-action="accept-request"]');
    if (acceptRequestBtn) {
        const { senderId, messageId } = acceptRequestBtn.dataset;
        acceptRequestBtn.closest('.glass-card').style.opacity = '0.5';
        respondToFriendRequest(senderId, messageId, true);
        return;
    }
    const declineRequestBtn = e.target.closest('[data-action="decline-request"]');
    if (declineRequestBtn) {
        const { senderId, messageId } = declineRequestBtn.dataset;
        declineRequestBtn.closest('.glass-card').style.opacity = '0.5';
        respondToFriendRequest(senderId, messageId, false);
        return;
    }
    const acceptClanBtn = e.target.closest('[data-action="accept-clan-invite"]');
    if (acceptClanBtn) {
        const { clanId, messageId } = acceptClanBtn.dataset;
        acceptClanBtn.closest('.glass-card').style.opacity = '0.5';
        acceptClanInvite(clanId, messageId);
        return;
    }
    const declineClanBtn = e.target.closest('[data-action="decline-clan-invite"]');
    if (declineClanBtn) {
        const { clanId, messageId } = declineClanBtn.dataset;
        declineClanBtn.closest('.glass-card').style.opacity = '0.5';
        declineClanInvite(clanId, messageId);
        return;
    }

    // Gère le clic sur les cartes de message pour ouvrir la pop-up
    const messageDetailsBtn = e.target.closest('[data-action="open-message-details"]');
    if (messageDetailsBtn) {
        const messageId = messageDetailsBtn.dataset.messageId;
        const message = state.inbox.unreadMessages.find(m => m.id === messageId);
        if (message) {
            openSystemMessageModal(message);
        }
        return;
    }
}

async function openUnifiedUserOptionsMenu(userId, buttonElement, context) {
    closeAllPopovers(); // On ferme les autres menus

    // --- Étape 1 : Récupérer toutes les données nécessaires ---
    const targetUserDoc = await getDoc(doc(db, 'publicProfiles', userId));
    if (!targetUserDoc.exists()) return;
    const targetUserData = targetUserDoc.data();
    
    const friendshipStatus = getFriendshipStatus(userId);
    const iAmInAClan = !!state.userProfile.clanId;
    const iAmTheChef = iAmInAClan && state.currentClanData.chefUid === currentUserId;
    
    const optionsHtml = []; // On va construire notre liste de boutons ici

    // --- Étape 2 : Logique pour les options du CHEF D'ÉQUIPE ---
    // Ces options n'apparaissent que dans le contexte 'clan-member' ET si je suis le chef
    if (context === 'clan-member' && iAmTheChef) {
        optionsHtml.push(`
            <button data-action="promote-clan-member" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-yellow-400">
                <i class="fa-solid fa-crown w-4 text-center"></i> Promouvoir Chef
            </button>
            <button data-action="kick-clan-member" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-red-400">
                <i class="fa-solid fa-user-slash w-4 text-center"></i> Exclure
            </button>
        `);
    }

    // --- Étape 3 : Logique d'AMITIÉ (s'applique à tous les contextes) ---
    switch (friendshipStatus) {
        case 'none':
            optionsHtml.push(`
            <button data-action="send-friend-request" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-green-400">
                <i class="fa-solid fa-user-plus w-4 text-center"></i> Ajouter en ami
            </button>`);
            break;
        case 'pending':
            optionsHtml.push(`
            <button data-action="cancel-friend-request" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-yellow-400">
                <i class="fa-solid fa-user-clock w-4 text-center"></i> Annuler la demande
            </button>`);
            break;
        case 'friends':
            optionsHtml.push(`
            <button data-action="confirm-remove-friend" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-red-500/20 font-semibold flex items-center gap-3 text-red-400">
                <i class="fa-solid fa-user-minus w-4 text-center"></i> Supprimer l'ami
            </button>`);
            break;
    }

    // --- Étape 4 : Logique d'INVITATION D'ÉQUIPE (ne s'applique PAS au contexte 'clan-member') ---
    if (iAmInAClan && context !== 'clan-member') {
        const clanData = state.currentClanData;
        if (targetUserData.clanId) {
            optionsHtml.push(`<button class="w-full text-left p-2 rounded-md font-semibold flex items-center gap-3 text-gray-500 cursor-not-allowed" disabled><i class="fa-solid fa-users w-4 text-center"></i> Déjà dans une équipe</button>`);
        } else if (clanData.pendingInvites && clanData.pendingInvites[userId]) {
            optionsHtml.push(`<button class="w-full text-left p-2 rounded-md font-semibold flex items-center gap-3 text-gray-500 cursor-not-allowed" disabled><i class="fa-solid fa-paper-plane w-4 text-center"></i> Invitation envoyée</button>`);
        } else {
            optionsHtml.push(`
            <button data-action="invite-friend-to-clan" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-violet-400">
                <i class="fa-solid fa-users w-4 text-center"></i> Inviter dans l'équipe
            </button>`);
        }
    }

    // --- Étape 5 : Option de SIGNALEMENT (toujours présente) ---
    optionsHtml.push(`
    <button data-action="report-user" data-uid="${userId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3">
        <i class="fa-solid fa-flag w-4 text-center text-gray-400"></i> Signaler
    </button>`);

    // --- Étape 6 : Affichage du popover ---
    if (optionsHtml.length === 0) return; // Sécurité

    const popover = document.createElement('div');
    popover.id = 'friend-options-popover';
    popover.className = 'glass-card p-2 rounded-lg w-52 absolute z-30 animate-fadeIn';
    popover.innerHTML = optionsHtml.join('');
    
    // Le reste de la logique pour positionner et afficher le popover...
    const rect = buttonElement.getBoundingClientRect();
    popover.style.top = `${rect.bottom + 5}px`;
    popover.style.right = `${window.innerWidth - rect.right}px`;
    document.body.appendChild(popover);

    setTimeout(() => {
        const closeHandler = (e) => {
            if (!popover.contains(e.target) && !buttonElement.contains(e.target)) {
                popover.remove();
                document.removeEventListener('click', closeHandler, true);
            }
        };
        document.addEventListener('click', closeHandler, true);
    }, 0);
}

        function openQuestsModal() {
    const { daily, weekly } = state.userProfile.quests;
    
    const isWorkoutActive = state.activeSide === 'workout';
    const activeQuestCategory = isWorkoutActive ? 'workout' : 'nutrition';

    const dailyQuests = (daily || []).filter(q => {
        const info = getQuestInfo(q.id);
        return info && QUEST_DATABASE[activeQuestCategory].daily.some(dbq => dbq.id === q.id);
    });
    
    const weeklyQuests = (weekly || []).filter(q => {
        const info = getQuestInfo(q.id);
        return info && QUEST_DATABASE[activeQuestCategory].weekly.some(dbq => dbq.id === q.id);
    });

    const renderQuestCard = (quest) => {
    const questInfo = getQuestInfo(quest.id);
    if (!questInfo) return '';

    const progressPercent = Math.min(100, Math.max(0, (quest.progress / questInfo.goal) * 100));
    const isCompleted = quest.completed;
    const isClaimed = quest.claimed;
    
    let statusHtml = '';
    
    if (isCompleted && !isClaimed) {
        statusHtml = `<button data-action="claim-quest" data-quest-id="${quest.id}" class="quest-status-btn quest-claim-btn"><i class="fa-solid fa-gift mr-1"></i> Collecter</button>`;
    } else if (isCompleted && isClaimed) {
        statusHtml = `<button class="quest-status-btn claimed-btn" disabled><i class="fa-solid fa-check mr-1"></i>Récupéré</button>`;
    } else {
        statusHtml = `<div class="quest-status-btn locked-btn flex items-center justify-center">${Math.round(quest.progress)} / ${questInfo.goal}</div>`;
    }

    // Correction : Le background du cercle est maintenant un dégradé conique.
    const progressCircleBackground = isCompleted 
    ? `linear-gradient(135deg, #fde047, #facc15)` 
    : `conic-gradient(var(--theme-primary) ${progressPercent}%, rgba(var(--background-start-rgb), 0.7) ${progressPercent}%)`;

    const iconColor = isCompleted ? 'white' : 'var(--theme-primary)';
    
    const cardClass = isCompleted ? 'completed' : '';
    const claimableClass = isCompleted && !isClaimed ? 'claimable' : '';
    const opacityClass = isClaimed ? 'opacity-60' : '';

    return `
    <div class="quest-card-v2 ${cardClass} ${claimableClass} ${opacityClass}" data-quest-id="${quest.id}">
        <div class="quest-progress-circle-wrapper" style="background: ${progressCircleBackground};">
            <div class="quest-progress-inner-circle">
                <i class="fa-solid ${questInfo.icon} quest-icon" style="color: ${iconColor};"></i>
            </div>
        </div>
        <p class="font-bold text-sm leading-tight my-2 flex-grow flex items-center justify-center text-gray-300">
            ${questInfo.description}
        </p>
        <div class="flex-shrink-0">
            <div class="text-xs font-semibold text-gray-400 mb-2">
                <span>+${questInfo.rewards.xp} XP</span> / <span>+${questInfo.rewards.coins} <i class="fa-solid fa-coins text-yellow-400"></i></span>
            </div>
            <div class="quest-status-container flex items-center justify-center mt-3">
                 ${statusHtml}
            </div>
        </div>
    </div>
    `;
};

    const renderQuestSection = (quests, title) => {
        if (!quests || quests.length === 0) return '';
        return `
            <div class="mb-6">
                <h3 class="font-bold text-xl text-white mb-3">${title}</h3>
                <div class="quests-grid">
                    ${quests.map(renderQuestCard).join('')}
                </div>
            </div>`;
    };

    const modalContent = `
    <div id="quests-page-content" class="p-6 pb-6 h-full flex flex-col">
        <header class="flex items-center justify-between pt-2 mb-6">
            <button data-navigate="Accueil" class="text-gray-300 hover:text-white">
                <i class="fa-solid fa-arrow-left text-xl"></i>
            </button>
            <h1 class="text-3xl font-bold">Quêtes</h1>
            <div class="w-8"></div>
        </header>
        <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide">
            ${renderQuestSection(dailyQuests, 'Quotidiennes')}
            ${renderQuestSection(weeklyQuests, 'Hebdomadaires')}
        </div>
    </div>`;

    const pageContainer = document.getElementById('page-container');
    pageContainer.innerHTML = modalContent;

    pageContainer.addEventListener('click', e => {
        const claimButton = e.target.closest('[data-action="claim-quest"]');
        if (claimButton) {
            claimQuestReward(claimButton.dataset.questId);
        }
    });
}


function getExpValues() {
    const leveling = state.userProfile.leveling;

    if (leveling.isMaxedOut) {
        return { current: 1, required: 1, isMax: true };
    }

    // On utilise directement le niveau réel
    const totalXPRequiredForLevel = calculateTotalXPToReachLevel(leveling.realLevel);
    const xpNeededToCompleteLevel = calculateXPForLevel(leveling.realLevel);
    const xpInCurrentLevel = leveling.xp - totalXPRequiredForLevel;

    return {
        current: xpInCurrentLevel,
        required: xpNeededToCompleteLevel,
        isMax: false
    };
}
        
        // NOUVEAU : Fonction pour calculer le pourcentage de la barre.
        function getExpPercentage() {
            const exp = getExpValues();
            if (exp.required === 0) return 100;
            return (exp.current / exp.required) * 100;
        }

        function updateStreaks() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStr = formatDateToYYYYMMDD(today);

    // --- CALCUL DE LA SÉRIE D'ENTRAÎNEMENTS ---
    const completedWorkoutDates = [...new Set(
        (state.sessionHistory || []).map(session => formatDateToYYYYMMDD(new Date(session.date)))
    )].sort((a, b) => new Date(b) - new Date(a));

    let workoutStreak = 0;
    let lastChance = false;

    if (completedWorkoutDates.length > 0) {
        const lastWorkoutDate = new Date(completedWorkoutDates[0]);
        const daysSinceLastWorkout = Math.round((today - lastWorkoutDate) / (1000 * 60 * 60 * 24));

        if (daysSinceLastWorkout >= 3) {
            workoutStreak = 0;
        } else {
            workoutStreak = 1;
            for (let i = 0; i < completedWorkoutDates.length - 1; i++) {
                const currentDate = new Date(completedWorkoutDates[i]);
                const previousDate = new Date(completedWorkoutDates[i + 1]);
                const diff = Math.round((currentDate - previousDate) / (1000 * 60 * 60 * 24));
                if (diff < 3) {
                    workoutStreak++;
                } else {
                    break;
                }
            }
            if (daysSinceLastWorkout === 2) {
                lastChance = true;
            }
        }
    }
    state.streaks.workout = { count: workoutStreak, lastChance };
    // DÉCLENCHEUR SUCCÈS AJOUTÉ
    updateAchievementProgress('workout_streak', workoutStreak, 'max');

    // --- CALCUL DE LA SÉRIE NUTRITION ---
    const nutritionLog = {};
    state.calendarEvents
        .filter(e => e.type === 'meal' && e.validated)
        .forEach(event => {
            const meal = state.meals.find(m => m.id === event.refId);
            if (meal) {
                if (!nutritionLog[event.date]) {
                    nutritionLog[event.date] = { calories: 0, protein: 0 };
                }
                nutritionLog[event.date].calories += meal.nutrition.calories;
                nutritionLog[event.date].protein += meal.nutrition.protein;
            }
        });

    let historicalStreak = 0;
    let dateToCheck = new Date(today);
    dateToCheck.setDate(dateToCheck.getDate() - 1); 

    for (let i = 0; i < 365; i++) {
        const dateStr = formatDateToYYYYMMDD(dateToCheck);
        const log = nutritionLog[dateStr];
        if (!log || log.calories < state.userGoals.calories || log.protein < state.userGoals.protein) {
            break; 
        }
        historicalStreak++;
        dateToCheck.setDate(dateToCheck.getDate() - 1);
    }

    let finalNutritionStreak = historicalStreak;
    const todaysLog = nutritionLog[todayStr];
    if (todaysLog && todaysLog.calories >= state.userGoals.calories && todaysLog.protein >= state.userGoals.protein) {
        finalNutritionStreak = historicalStreak + 1;
    }
    
    state.streaks.nutrition = { count: finalNutritionStreak };
    // DÉCLENCHEUR SUCCÈS AJOUTÉ
    updateAchievementProgress('nutrition_streak', finalNutritionStreak, 'max');
}
        
        function formatDuration(ms) {
            if (!ms || ms < 0) return '00:00';

            const totalSeconds = Math.floor(ms / 1000);
            const totalMinutes = Math.floor(totalSeconds / 60);
            const totalHours = Math.floor(totalMinutes / 60);
            const totalDays = Math.floor(totalHours / 24);
            const totalMonths = Math.floor(totalDays / 30.44); // Moyenne pour plus de précision
            const totalYears = Math.floor(totalDays / 365.25);

            if (totalYears > 0) {
                const months = Math.floor(totalMonths % 12);
                return `${totalYears}a ${months}m`;
            }
            if (totalMonths > 0) {
                const days = Math.floor(totalDays % 30.44);
                return `${totalMonths}m ${days}j`;
            }
            if (totalDays > 0) {
                const hours = Math.floor(totalHours % 24);
                return `${totalDays}j ${hours}h`;
            }
            if (totalHours > 0) {
                const minutes = Math.floor(totalMinutes % 60);
                return `${totalHours}h ${String(minutes).padStart(2, '0')}min`;
            }
            if (totalMinutes > 0) {
                const seconds = totalSeconds % 60;
                return `${totalMinutes}min ${String(seconds).padStart(2, '0')}s`;
            }
            return `${totalSeconds}s`;
        }

        function formatVolume(kg) {
            if (kg < 1000) {
                // Moins de 1 000 kg -> affiche en kg
                return `${kg.toLocaleString('fr-FR', { maximumFractionDigits: 0 })} kg`;
            } else if (kg < 1000000) {
                // de 1 000 kg à 999 999 kg -> affiche en tonnes (t)
                return `${(kg / 1000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} t`;
            } else if (kg < 1000000000) {
                // de 1 million à 999 millions kg -> affiche en kilotonnes (kt)
                return `${(kg / 1000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} kt`;
            } else if (kg < 1000000000000) {
                // de 1 milliard à 999 milliards kg -> affiche en Mégatonnes (Mt)
                return `${(kg / 1000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Mt`;
            } else if (kg < 1000000000000000) {
                // Affiche en Gigatonnes (Gt)
                return `${(kg / 1000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Gt`;
            } else if (kg < 1000000000000000000) {
                // Affiche en Tératonnes (Tt)
                return `${(kg / 1000000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Tt`;
            } else if (kg < 1000000000000000000000) {
                // Affiche en Pétatonnes (Pt)
                return `${(kg / 1000000000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Pt`;
            } else if (kg < 1000000000000000000000000) {
                // Affiche en Exatonnes (Et)
                return `${(kg / 1000000000000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Et`;
            } else if (kg < 1000000000000000000000000000) {
                // Affiche en Zettatonnes (Zt)
                return `${(kg / 1000000000000000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Zt`;
            } else if (kg < 1000000000000000000000000000000) { 
                // Affiche en Yottatonnes (Yt)
                return `${(kg / 1000000000000000000000000000).toLocaleString('fr-FR', { maximumFractionDigits: 1 })} Yt`;
            } else {
                // === EASTER EGG POUR LES VALEURS INIMAGINABLES ===
                const easterEggs = [
                    'Hercule ?',
                ];
                return easterEggs[Math.floor(Math.random() * easterEggs.length)];
            }
        }

        function formatXP(num) {
            if (num < 1000) return num.toString();
            if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
            if (num < 1000000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B';
        }

        function formatTimestampForInbox(timestamp) {
    if (!timestamp || typeof timestamp.toDate !== 'function') return '';
    
    const now = new Date();
    const messageDate = timestamp.toDate();
    const diffSeconds = Math.round((now - messageDate) / 1000);

    if (diffSeconds < 60) return `${diffSeconds}s`;
    const diffMinutes = Math.round(diffSeconds / 60);
    if (diffMinutes < 60) return `${diffMinutes}m`;
    const diffHours = Math.round(diffMinutes / 60);
    if (diffHours < 24) return `${diffHours}h`;
    const diffDays = Math.round(diffHours / 24);
    if (diffDays === 1) return 'Hier';
    return messageDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
}

        function renderAvatar(profilePicUrl, classes = "w-12 h-12") {
    if (profilePicUrl) {
        // Pour une image de profil, le comportement ne change pas.
        return `<img src="${profilePicUrl}" class="${classes} rounded-full object-cover" alt="Avatar">`;
    } else {
        // Pour l'icône par défaut, nous rendons la taille dynamique.
        
        // 1. On extrait la taille numérique de la classe Tailwind (ex: 'w-28' -> 28).
        const sizeString = classes.split(' ').find(c => c.startsWith('w-'));
        const sizeNum = sizeString ? parseInt(sizeString.split('-')[1]) : 12; // 12 par défaut (w-12)

        // 2. On calcule la taille de l'icône (environ la moitié de celle du conteneur).
        // L'échelle de Tailwind est de 4 unités par rem, donc on divise par 4 puis par 2.
        const iconSizeRem = (sizeNum / 4) / 2;

        // 3. On retourne un conteneur flex qui centre l'icône avec la taille calculée.
        return `
            <div class="${classes} rounded-full bg-black/20 flex items-center justify-center">
                <i class="fa-solid fa-user text-gray-500" style="font-size: ${iconSizeRem}rem;"></i>
            </div>
        `;
    }
}

function renderUnifiedUserCard(user, context = '', chefUid = null) {
    if (!user) return '';
    
    const isChef = user.uid === chefUid;

    const optionsButtonHtml = user.uid === currentUserId ?
    `<div class="w-8 h-8 p-2"></div>` :
    `<button data-action="open-user-options-menu" data-uid="${user.uid}" data-context="${context}" class="text-gray-500 hover:text-white p-2 w-8 h-8 rounded-full">
        <i class="fa-solid fa-ellipsis-vertical"></i>
    </button>`;

    const equippedTitle = TITLES_DATABASE.find(t => t.id === user.equipped?.title) || { name: 'Débutant', rarity: 'Commun' };
    const equippedBorder = BORDERS_DATABASE.find(b => b.id === user.equipped?.border) || { style: '' };
    
    let titleClass = equippedTitle.color ? equippedTitle.color : `rarity-${normalizeString(equippedTitle.rarity)}-text`;
    if (equippedTitle.source === 'secret') {
        if (equippedTitle.id === 't-gymbro-originel') titleClass = 'title-gymbro-originel';
        else if (equippedTitle.id === 't-pompier-muscle' || equippedTitle.id === 't-the-bench-monster') titleClass = 'title-pompier-muscle';
        else if (equippedTitle.id === 't-createur-supreme') titleClass = 'title-createur-supreme';
    }

    const chefGlowStyle = isChef && state.currentClanData ? `box-shadow: 0 0 15px 2px ${state.currentClanData.iconColor || '#A78BFA'}40;` : '';

    // LA CORRECTION EST ICI : on utilise "user.uid" au lieu de "userData.uid"
    return `
    <div class="glass-card p-3 rounded-xl flex items-center justify-between h-20" style="${chefGlowStyle}">
        <div data-action="view-public-profile" data-uid="${user.uid}" class="flex items-center gap-3 min-w-0 cursor-pointer">
            <div class="w-14 h-14 rounded-full flex-shrink-0" style="${equippedBorder.style}">
                <div class="w-full h-full rounded-full" style="background-color: rgb(29, 31, 43);">
                    ${renderAvatar(user.profilePicUrl, "w-full h-full")}
                </div>
            </div>
            <div class="min-w-0">
                <p class="font-bold truncate">${user.name} ${isChef ? '👑' : ''}</p>
                <p class="text-sm truncate ${titleClass}" title="${equippedTitle.name}">${equippedTitle.name}</p>
            </div>
        </div>
        <div class="flex items-center flex-shrink-0">
            <div class="w-12 h-12 ml-2 mr-2" title="${user.globalRank || 'Non classé'}">
                ${getRankBadgeSVG(user.globalRank || 'Novice III', '48px')}
            </div>
            ${optionsButtonHtml}
        </div>
    </div>
    `;
}

        function closeAllDropdowns() {
    // Sélectionne toutes les listes d'options qui sont actuellement actives
    document.querySelectorAll('.custom-select-options.active, .shop-sort-options.active').forEach(options => {
        options.classList.remove('active');
        // On s'assure de retirer aussi la classe 'active' du bouton parent
        const parentContainer = options.closest('.custom-select-container');
        if (parentContainer) {
            parentContainer.querySelector('.custom-select-button, .shop-sort-button')?.classList.remove('active');
        }
    });
}

        let cropper = null;

        function showToast(message, type = 'success') { // 'success', 'error', 'info'
    const toastContainer = document.getElementById('toast-container');
    if (!toastContainer) return;

    // La ligne qui effaçait les anciennes notifications a été SUPPRIMÉE.

    const toast = document.createElement('div');
    let bgColorClass = '';
    let textColorClass = '';

    if (type === 'success') {
        bgColorClass = 'bg-green-500';
        textColorClass = 'text-green-900';
    } else if (type === 'error') {
        bgColorClass = 'bg-red-500';
        textColorClass = 'text-white';
    } else { // info or default
        bgColorClass = 'bg-violet-500';
        textColorClass = 'text-white';
    }

    toast.className = `toast-notification ${bgColorClass} ${textColorClass}`;
    toast.textContent = message;
    toastContainer.appendChild(toast);

    // Animate in
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Animate out and remove after a duration
    setTimeout(() => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    }, 2500); // Durée légèrement augmentée pour une meilleure lisibilité
}

        // Dans votre <script>

function animateItemPurchaseSuccess(itemCardElement) {
    if (!itemCardElement) return;
    // On garde le même nom de classe, mais le CSS derrière a changé !
    itemCardElement.classList.add('animate-purchase-success');

    // La classe est retirée après l'animation pour permettre de futurs achats
    itemCardElement.addEventListener('animationend', () => {
        // On retire la classe pour que la pseudo-classe ::after disparaisse
        itemCardElement.classList.remove('animate-purchase-success');
    }, { once: true });
}

        function animateButtonFailure(buttonElement) {
    if (!buttonElement) return;
    buttonElement.classList.add('animate-purchase-fail'); // Utilise la classe pour la vibration
    buttonElement.addEventListener('animationend', () => {
        buttonElement.classList.remove('animate-purchase-fail');
    }, { once: true });
}

        function animateProfileSave(saveButton) {
            if (!saveButton) return;
            // Create a temporary checkmark icon
            const checkIcon = document.createElement('i');
            checkIcon.className = 'fa-solid fa-check text-green-400 text-xl ml-2 animate-checkmark';
            
            // Append it next to the button
            // Use saveButton.parentNode.insertBefore instead of nextSibling for more robust placement
            saveButton.parentNode.insertBefore(checkIcon, saveButton.nextSibling);

            // Make toast appear briefly
            showToast('Profil sauvegardé avec succès !');

            // Remove the checkmark after a short delay
            setTimeout(() => {
                checkIcon.remove();
            }, 1500); // Checkmark fades out faster than toast
        }

        const normalizeString = (str) => {
    if (!str) return '';
    return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
};

        function openCropperModal(imageSrc) {
    const cropperModalContainer = document.getElementById('cropper-modal-container');
    const appContainer = document.getElementById('app-container');
    
    const modalHTML = `
        <div id="cropper-modal-content" class="absolute bottom-0 left-0 right-0 p-4 rounded-t-3xl flex flex-col h-[70vh]">
            <h2 class="text-xl font-bold text-center mb-4">Recadrer la photo</h2>
            <div id="cropper-image-container" class="flex-grow">
                <img id="cropper-image" src="${imageSrc}">
            </div>
            <div class="flex gap-4 mt-4">
                <button id="cancel-crop-btn" class="w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
                <button id="confirm-crop-btn" class="w-full btn-primary">Valider</button>
            </div>
        </div>`;
    
    cropperModalContainer.innerHTML = modalHTML;
    cropperModalContainer.classList.remove('hidden');
    appContainer.style.transform = 'scale(0.95) translateY(-20px)';
    appContainer.style.transition = 'transform 0.3s ease';

    const image = document.getElementById('cropper-image');
    cropper = new Cropper(image, {
        aspectRatio: 1,
        viewMode: 1,
        background: false,
        autoCropArea: 0.8,
    });

    document.getElementById('confirm-crop-btn').onclick = () => {
        const croppedCanvas = cropper.getCroppedCanvas({
            width: 256,
            height: 256,
            imageSmoothingQuality: 'high',
        });
        const newImageUrl = croppedCanvas.toDataURL('image/png');
        
        // On met à jour l'état temporaire du profil
        if (state.tempUserProfile) {
            state.tempUserProfile.profilePicUrl = newImageUrl;
        }
        
        cropper.destroy();
        cropperModalContainer.classList.add('hidden');
        appContainer.style.transform = '';
        render(); // On redessine la page pour afficher la nouvelle image
    };

    document.getElementById('cancel-crop-btn').onclick = () => {
        cropper.destroy();
        cropperModalContainer.classList.add('hidden');
        appContainer.style.transform = '';
    };
}

function handleProfilePictureChange(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => openCropperModal(e.target.result);
        reader.readAsDataURL(file);
        // On réinitialise l'input pour pouvoir sélectionner le même fichier à nouveau
        event.target.value = '';
    }
}

        // --- Fonctions pour le système de Rangs ---
        function calculatePerformanceScore(params) {
    // NOTE : Le paramètre 'bilateral' a été retiré. Le calcul est à nouveau comme à l'origine.
    const { type, charge, reps, poidsDuCorps, coefficient, pdcPercent } = params;
    if (!poidsDuCorps || poidsDuCorps <= 0 || reps <= 0) return 0;

    const repMultiplier = 1 + (reps / (30 + (reps / 4)));
    let effectiveLoad = 0;

    if (type === 'weighted') {
        effectiveLoad = charge; // On utilise la charge brute (poids d'un seul haltère)
    } else if (type === 'bodyweight') {
        effectiveLoad = (poidsDuCorps * (pdcPercent || 0)) + (charge * 0.75);
    } else if (type === 'timed') {
        const chargeEffectiveTimed = charge > 0 ? charge : poidsDuCorps * (pdcPercent || 1.0);
        return (chargeEffectiveTimed * reps * coefficient) / (poidsDuCorps * 10);
    }

    const normalizedStrength = (effectiveLoad * repMultiplier) / poidsDuCorps;
    const score = normalizedStrength * coefficient * 10;
    return score > 0 ? score : 0;
}

        function calculateAbsolutePerformance(params) {
            const { type, charge, reps, coefficient, pdcPercent } = params;
            if (reps <= 0) return 0;

            const repMultiplier = 1 + (reps / (30 + (reps / 4)));
            let effectiveLoad = 0;

            if (type === 'weighted') {
                effectiveLoad = charge;
            } else if (type === 'bodyweight') {
                const referenceBodyweight = 80;
                effectiveLoad = (referenceBodyweight * (pdcPercent || 0)) + (charge * 0.75);
            } else if (type === 'timed') {
                const referenceBodyweight = 80;
                const chargeEffectiveTimed = charge > 0 ? charge : referenceBodyweight * (pdcPercent || 1.0);
                return (chargeEffectiveTimed * reps * coefficient);
            }

            const absoluteScore = (effectiveLoad * repMultiplier) * coefficient;
            return absoluteScore > 0 ? absoluteScore : 0;
        }


        function getRankFromScore(score, exerciseId) {
            const exercise = getExerciseById(exerciseId);
            if (!exercise || exercise.targetScore <= 0) return { name: 'Non classé', baseName: 'Novice', progress: 0, nextRankName: 'N/A', points: 0, sr: 0, color: getRankColor('Novice') };

            let adjustedTargetScore = exercise.targetScore;
            if (state.userProfile.sex === 'Femme') {
                adjustedTargetScore *= 0.70;
            }

            const progressionCurve = [0, 0.15, 0.30, 0.45, 0.60, 0.75, 0.88, 1.0];
            const thresholds = progressionCurve.map(p => p * adjustedTargetScore);
            
            let rankIndex = 0;
            for (let i = thresholds.length - 1; i >= 0; i--) {
                if (score >= thresholds[i]) { rankIndex = i; break; }
            }

            const isMaxRank = (rankIndex === RANK_NAMES.length - 1);
            const currentThreshold = thresholds[rankIndex];
            const nextThreshold = isMaxRank ? (adjustedTargetScore * 1.1) : thresholds[rankIndex + 1];
            
            const scoreInLevel = score - currentThreshold;
            const scoreToNextLevel = nextThreshold - currentThreshold;
            const progress = scoreToNextLevel > 0 ? Math.min(Math.round((scoreInLevel / scoreToNextLevel) * 100), 100) : 100;

            let division = 'I';
            if (progress < 34) division = 'III';
            else if (progress < 67) division = 'II';
            
            const baseName = score === 0 ? RANK_NAMES[0] : RANK_NAMES[rankIndex];
            if (score === 0) division = 'III';

            const rankName = `${baseName} ${division}`;
            const nextRankName = isMaxRank ? 'Max' : `${RANK_NAMES[rankIndex + 1]} III`;
            
            const totalPoints = RANK_POINTS_MAP[rankName] || 0;

            // --- MODIFICATION APPLIQUÉE ICI ---
            let sr = 0;
            // On vérifie que le rang est bien Demi-Dieu (isMaxRank) ET que la division est bien I (progress >= 67)
            const isDemiDieuOne = isMaxRank && progress >= 67;

            // Le SR n'est calculé que si cette condition est vraie
            if (isDemiDieuOne && score > adjustedTargetScore) {
                // Le calcul du SR reste le même, seule la condition d'entrée change.
                sr = Math.floor(((score / adjustedTargetScore) - 1) * 50);
            }
            // --- FIN DE LA MODIFICATION ---

            return { name: rankName, baseName, progress, nextRankName, points: totalPoints, sr: sr, color: getRankColor(baseName) };
        }

        function calculateSessionRewards(sessionStats) {
    // --- Calcul de l'XP ---
    const xpFromTime = sessionStats.durationInMinutes * 30;
    const xpFromVolume = sessionStats.totalVolume * 0.05;
    const xpFromExerciseCount = sessionStats.exerciseCount * 25;
    const baseXP = xpFromTime + xpFromVolume + xpFromExerciseCount;

    // Le multiplicateur est maintenant basé sur le score moyen (0-100)
    const qualityMultiplier = 1 + (sessionStats.averageSessionScore / 200);
    const qualityAdjustedXP = baseXP * qualityMultiplier;
    
    const xpFromPRs = sessionStats.prBeatenCount * 150;
    const totalXp = Math.round(qualityAdjustedXP + xpFromPRs);

    // --- Calcul de l'Or (avec une approche conservatrice) ---
    const goldFromTime = sessionStats.durationInMinutes * 0.3;
    const goldFromVolume = sessionStats.totalVolume / 800;
    // Le bonus de score est maintenant basé sur le score moyen (0-100)
    const goldFromScore = sessionStats.averageSessionScore / 4;
    const goldFromExerciseCount = sessionStats.exerciseCount * 1.5;
    const goldFromPRs = sessionStats.prBeatenCount * 20;
    const totalGold = Math.round(goldFromTime + goldFromVolume + goldFromScore + goldFromExerciseCount + goldFromPRs);

    return {
        xp: totalXp,
        gold: totalGold
    };
}

        
        const RANK_COLORS = {
            'Novice':    { main: '#6B7280', accent: '#9CA3AF', shadow: '#4B5563' },
            'Rookie':    { main: '#10B981', accent: '#6EE7B7', shadow: '#059669' },
            'Disciple':  { main: '#3B82F6', accent: '#93C5FD', shadow: '#2563EB' },
            'Forgeron':  { main: '#F59E0B', accent: '#FCD34D', shadow: '#D97706' },
            'Vétéran':   { main: '#6366F1', accent: '#A5B4FC', shadow: '#4F46E5' },
            'Prodige':   { main: '#EC4899', accent: '#F9A8D4', shadow: '#DB2777' },
            'Colosse':   { main: '#EF4444', accent: '#FCA5A5', shadow: '#DC2626' },
            'Demi-Dieu': { main: '#8B5CF6', accent: '#C4B5FD', shadow: '#7C3AED' }
        };

        const RANKS_DATABASE = RANK_NAMES.map(name => ({
    name: name,
    color: RANK_COLORS[name]
}));

        function getRankColor(rankBaseName) {
            return RANK_COLORS[rankBaseName] || RANK_COLORS['Novice'];
        }

        function getRankFromPoints(points) {
            const roundedPoints = Math.round(points);
            const rankName = REVERSE_RANK_POINTS_MAP[roundedPoints];
            if (rankName) {
                return {
                    name: rankName,
                    baseName: rankName.split(' ')[0],
                    points: roundedPoints
                };
            }
            // Failsafe pour les cas où le point n'existe pas (ne devrait pas arriver)
            return { name: 'Non classé', baseName: 'Novice', points: 0 };
        }

        function getRankBadgeSVG(rankName, size = '100%') {
            if (!rankName) return '';
            const rankBaseName = rankName.split(' ')[0];
            const selected = getRankColor(rankBaseName);
            
            if (!selected) {
                return `<svg width="${size}" height="${size}" viewBox="0 0 100 100"><text x="50" y="50" text-anchor="middle" fill="white">?</text></svg>`;
            }

            let divisionOpacity = 0.4;
            if (rankName.includes('II')) divisionOpacity = 0.7;
            if (rankName.includes('I')) divisionOpacity = 1.0;

            const icons = {
                'Novice': `<path d="M35 50H65M50 35V65" stroke-width="6"/>`,
                'Rookie': `<path d="M68 32C68 32 56 41 50 53C44 65 32 68 32 68" stroke-width="5" fill="none"/><path d="M41 24L68 32L60 41" stroke-width="4" fill="${selected.main}"/>`,
                'Disciple': `<path d="M28 75V31.8C28 29.7 29.7 28 31.8 28H68.2C70.3 28 72 29.7 72 31.8V75" stroke-width="4" fill="${selected.main}"/><path d="M50 48L58 58L50 68" stroke-width="3"/><path d="M42 48L34 58L42 68" stroke-width="3"/>`,
                'Forgeron': `<path d="M63,32,43.5,51.5,l-9-9L28,49,l9,9,6.5,6.5,19-19V32Z" fill="${selected.main}"/><path d="M37 32L63 58" stroke-width="5"/><path d="M63 32L37 58" stroke-width="5"/>`,
                'Vétéran': `<path d="M50 20L76 35V65L50 80L24 65V35L50 20Z" stroke-width="4" fill="${selected.main}"/><path d="M35 45L50 55L65 45" stroke-width="4"/><path d="M35 60L50 70L65 60" stroke-width="4"/>`,
                'Prodige': `<path d="M50 20V44L62 50L50 80V56L38 50L50 20Z" stroke-width="4" fill="${selected.main}"/>`,
                'Colosse': `<path d="M28 75L50 30L72 75H28Z" stroke-width="4" fill="${selected.main}"/><path d="M40 60L50 40L60 60H40Z" stroke-width="3" fill="${selected.accent}"/>`,
                'Demi-Dieu': `<path d="M24 68L50 80L76 68" stroke-width="3"/><path d="M24 50L50 62L76 50" stroke-width="3"/><path d="M24 32L50 44L76 32" stroke-width="3"/><path d="M50 20L24 32V68L50 80L76 68V32L50 20Z" stroke-width="4" fill="${selected.main}"/>`
            };
            const selectedIcon = icons[rankBaseName] || icons['Novice'];

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g opacity="${divisionOpacity}">
                        <defs>
                            <filter id="shadow-${rankBaseName}" x="-20%" y="-20%" width="140%" height="140%">
                                <feDropShadow dx="0" dy="4" stdDeviation="4" flood-color="${selected.shadow}" flood-opacity="0.6"/>
                            </filter>
                        </defs>
                        <g filter="url(#shadow-${rankBaseName})">
                            <path d="M50 95C40.61 95 31.51 90.56 25.36 83.11L25 82.68V82.68L5.36 53.11C1.94 47.79 2.18 40.94 6.09 35.9L6.36 35.54L25.36 16.89C31.51 9.44 40.61 5 50 5C59.39 5 68.49 9.44 74.64 16.89L75 17.32V17.32L94.64 46.89C98.06 52.21 97.82 59.06 93.91 64.1L93.64 64.46L74.64 83.11C68.49 90.56 59.39 95 50 95Z" fill="${selected.main}"/>
                            <path d="M50 95C40.61 95 31.51 90.56 25.36 83.11L25 82.68V82.68L5.36 53.11C1.94 47.79 2.18 40.94 6.09 35.9L6.36 35.54L25.36 16.89C31.51 9.44 40.61 5 50 5C59.39 5 68.49 9.44 74.64 16.89L75 17.32V17.32L94.64 46.89C98.06 52.21 97.82 59.06 93.91 64.1L93.64 64.46L74.64 83.11C68.49 90.56 59.39 95 50 95Z" stroke="${selected.accent}" stroke-width="2"/>
                            <g stroke="${selected.accent}" stroke-linecap="round" stroke-linejoin="round">
                                ${selectedIcon}
                            </g>
                        </g>
                    </g>
                </svg>
            `;
        }

        async function saveState() {
    if (!currentUserId) {
        console.warn("Tentative de sauvegarde sans utilisateur connecté. Opération annulée.");
        return;
    }

    try {
        const stateToSave = JSON.parse(JSON.stringify(state));

        if (state.userProfile && state.userProfile.achievements) {
            for (const achId in state.userProfile.achievements) {
                const originalAch = state.userProfile.achievements[achId];
                if (originalAch && originalAch.qualifyingData instanceof Set) {
                    stateToSave.userProfile.achievements[achId].qualifyingData = Array.from(originalAch.qualifyingData);
                }
            }
        }

        const privateData = {
            userProfile: stateToSave.userProfile,
            workouts: stateToSave.workouts,
            meals: stateToSave.meals,
            sessionHistory: stateToSave.sessionHistory,
            calendarEvents: stateToSave.calendarEvents,
            userGoals: stateToSave.userGoals,
            workoutTags: stateToSave.workoutTags,
            mealTags: stateToSave.mealTags,
            exerciseStats: stateToSave.exerciseStats,
            streaks: stateToSave.streaks,
            recurrence: stateToSave.recurrence,
            friends: stateToSave.friends || { accepted: [], pendingSent: [], pendingReceived: [] }
        };

        const sbdRanks = {
            total: { best_1rm: 0 },
            squat: { best_1rm: 0, bodyweight: 0 },
            bench: { best_1rm: 0, bodyweight: 0 },
            deadlift: { best_1rm: 0, bodyweight: 0 },
        };
        let total = 0;
        ['squat', 'bench', 'deadlift'].forEach(lift => {
            const verifiedPerf = state.userProfile.sbdVault[lift]?.verified;
            if (verifiedPerf) {
                sbdRanks[lift].best_1rm = verifiedPerf.weight;
                sbdRanks[lift].bodyweight = verifiedPerf.bodyweight; // On récupère le poids de corps de la performance
                total += verifiedPerf.weight;
            }
        });
        sbdRanks.total.best_1rm = total;
        // --- FIN DE LA NOUVELLE LOGIQUE ---

        // --- CORRECTION : Calcul des rangs par groupe musculaire ---
        const muscleGroupRanks = {};
        Object.keys(MUSCLE_GROUPS).forEach(key => {
            // On s'assure d'appeler la fonction de calcul et de stocker le résultat
            muscleGroupRanks[key] = calculateMuscleGroupRank(key).globalRank;
        });
        // --- FIN DE LA CORRECTION ---

        const { globalRank, totalSr } = calculateGlobalRank();

        const publicData = {
            uid: currentUserId,
            name: state.userProfile.name,
            name_lowercase: state.userProfile.name.toLowerCase(),
            profilePicUrl: state.userProfile.profilePicUrl,
            country: state.userProfile.country,
            sex: state.userProfile.sex,
            leveling: state.userProfile.leveling,
            equipped: state.userProfile.equipped,
            globalRank: calculateGlobalRank().globalRank,
            totalSr: totalSr,
            muscleGroupRanks: muscleGroupRanks, // <-- Cette ligne est maintenant correctement alimentée
            clanId: state.userProfile.clanId || null,
            clanName: state.currentClanData ? state.currentClanData.name : null,
            clanIconId: state.currentClanData ? state.currentClanData.iconId : null,
            clanIconColor: state.currentClanData ? state.currentClanData.iconColor : null,
            iconIsAnimated: state.currentClanData ? state.currentClanData.iconIsAnimated : false,
            gymId: state.userProfile.gymId || null,
            gymName: state.currentGymData ? state.currentGymData.name : null
        };

        const userRef = doc(db, 'users', currentUserId);
        const publicProfileRef = doc(db, 'publicProfiles', currentUserId);

        await Promise.all([
            setDoc(userRef, privateData, { merge: true }),
            setDoc(publicProfileRef, publicData, { merge: true })
        ]);

        console.log("Données privées et publiques sauvegardées avec succès.");

    } catch (error) {
        console.error("Erreur critique lors de la sauvegarde sur Firestore:", error);
        showToast("Erreur de sauvegarde des données.", "error");
    }
}

        // --- DATA PERSISTENCE & BUSINESS LOGIC ---
        async function saveWorkout() {
    const workoutName = document.getElementById('workout-name-input').value;
    if (!workoutName || !state.editingWorkout) return;
    state.editingWorkout.name = workoutName;

    const workoutIndex = state.workouts.findIndex(w => w.id === state.editingWorkout.id);
    if (workoutIndex > -1) {
        state.workouts[workoutIndex] = state.editingWorkout;
    } else {
        state.workouts.push(state.editingWorkout);
    }
    
    // --- CORRECTION APPLIQUÉE ICI ---
    // On sauvegarde et on navigue d'abord...
    await saveState();
    navigate('Workouts');
    // ...et on nettoie l'état SEULEMENT APRÈS être parti de la page de l'éditeur.
    state.editingWorkout = null; 
    // --- FIN DE LA CORRECTION ---
}

        async function saveMeal() {
    const mealName = document.getElementById('meal-name-input').value;
    if (!mealName || !state.editingMeal) return;
    state.editingMeal.name = mealName;
    
    const totals = state.editingMeal.ingredients.reduce((acc, ing) => {
        acc.calories += ing.nutrition.calories || 0;
        acc.protein += ing.nutrition.protein || 0;
        acc.carbs += ing.nutrition.carbs || 0;
        acc.fat += ing.nutrition.fat || 0;
        return acc;
    }, { calories: 0, protein: 0, carbs: 0, fat: 0 });
    state.editingMeal.nutrition = totals;

    const { finalScore } = calculateMealFitScore(state.editingMeal);
    state.editingMeal.fitScore = finalScore;

    const mealIndex = state.meals.findIndex(m => m.id === state.editingMeal.id);
    if (mealIndex > -1) {
        state.meals[mealIndex] = state.editingMeal;
    } else {
        state.meals.push(state.editingMeal);
        updateQuestProgress('create_new_meal', 1); // Déclencheur pour la quête
    }
    
    updateAchievementProgress('meals_created', 1, 'increment');
    const isQuickAdd = state.editingMeal.isQuickAdd;
    state.editingMeal = null;

    await saveState();

    if (isQuickAdd) navigate('Accueil');
    else navigate('Repas');
}

function getFitScoreColor(score) {
    if (score >= 80) return '#05E509'; // Vert foncé (Excellent)
    if (score >= 60) return '#B5E06C'; // Vert clair (Très bon)
    if (score >= 40) return '#F2CC4E'; // Jaune (Bon)
    if (score >= 20) return '#F97316'; // Orange (Moyen)
    return '#F03737'; // Rouge (Faible)
}

function getLevelTierColors(realLevel) {
    const { prestigeTier } = getDisplayLevelInfo(realLevel); // On utilise notre traducteur
    const tierIndex = prestigeTier % PRESTIGE_TIER_COLORS.length;
    const color = PRESTIGE_TIER_COLORS[tierIndex];
    
    return { color: color, shadow: color };
}

function getDisplayLevelInfo(realLevel) {
    if (realLevel >= 4000) {
        return { displayLevel: 100, prestige: 3, prestigeTier: 9 };
    }

    // Un niveau réel de 1 est au tout début. On ajuste pour les calculs basés sur 0.
    const levelIndex = realLevel - 1;

    // Chaque gamme de prestige dure 400 niveaux (4 prestiges de 100 niveaux)
    const prestigeTier = Math.floor(levelIndex / 400);
    
    // Niveau à l'intérieur de la gamme actuelle (de 0 à 399)
    const levelInTier = levelIndex % 400;

    // Chaque prestige dure 100 niveaux
    const prestige = Math.floor(levelInTier / 100);

    // Le niveau affiché est le reste + 1 (pour aller de 1 à 100)
    const displayLevel = (levelInTier % 100) + 1;

    return { displayLevel, prestige, prestigeTier };
}

function _formatApiProduct(product) {
    const nutriments = product.nutriments || {};

    let calories = nutriments.energy_kcal_100g || nutriments['energy-kcal_100g'];
    // Si les calories en kcal sont manquantes, on les calcule depuis les kJ
    if (typeof calories !== 'number' && (nutriments.energy_100g || nutriments['energy-kj_100g'])) {
        calories = (nutriments.energy_100g || nutriments['energy-kj_100g']) / 4.184;
    }

    return {
        code: product.code,
        name: product.product_name_fr || product.product_name || 'Aliment inconnu',
        brand: product.brands || null,
        imageUrl: product.image_url || null,
        additives: product.additives_tags || [],
        labels_tags: product.labels_tags || [],
        base_100g: {
            // --- MODIFICATION CLÉ CI-DESSOUS ---
            // On vérifie si la donnée est un nombre. Si ce n'est pas le cas (undefined, null, etc.),
            // on stocke 'null' pour marquer la donnée comme manquante.
            calories: typeof calories === 'number' ? Math.round(calories) : null,
            protein: typeof nutriments.proteins_100g === 'number' ? nutriments.proteins_100g : null,
            fat: typeof nutriments.fat_100g === 'number' ? nutriments.fat_100g : null,
            carbs: typeof nutriments.carbohydrates_100g === 'number' ? nutriments.carbohydrates_100g : null,
            sugars: typeof nutriments.sugars_100g === 'number' ? nutriments.sugars_100g : null,
            fiber: typeof nutriments.fiber_100g === 'number' ? nutriments.fiber_100g : null,
            saturated_fat: typeof nutriments['saturated-fat_100g'] === 'number' ? nutriments['saturated-fat_100g'] : null,
            // --- FIN DE LA MODIFICATION ---
            nutri_score_grade: product.nutriscore_grade || 'unknown',
            nutri_score_value: product.nutriscore_score
        }
    };
}

function calculateMealFitScore(meal) {
    // --- MODIFICATION N°1 : Un repas vide renvoie N/A (null) ---
    if (!meal || !meal.ingredients || meal.ingredients.length === 0) {
        return { finalScore: null, adjustments: {} };
    }

    // On crée une liste qui ne contient QUE les ingrédients valides (avec Nutri-Score)
    const validIngredients = meal.ingredients.filter(ing => calculateIngredientFitScore(ing) !== null);

    // Si, après filtrage, il n'y a aucun ingrédient valide, le score est N/A (null)
    if (validIngredients.length === 0) {
        return { finalScore: null, adjustments: {} };
    }

    // Le score de base est calculé uniquement sur les ingrédients valides
    let weightedScoreSum = 0;
    let totalWeight = 0;
    validIngredients.forEach(ing => {
        const scoreResult = calculateIngredientFitScore(ing); // On sait qu'il n'est pas null ici
        weightedScoreSum += scoreResult.score * ing.quantity;
        totalWeight += ing.quantity;
    });
    
    const baseScore = weightedScoreSum / totalWeight;

    // --- MODIFICATION N°2 : Les ajustements sont aussi calculés UNIQUEMENT sur les ingrédients valides ---
    let effectiveTotalSugars = 0;
    const totals = validIngredients.reduce((acc, ing) => {
        const labels = ing.labels_tags || [];
        const name = ing.name ? ing.name.toLowerCase() : '';
        const noAddedSugarLabels = ['en:no-added-sugar', 'fr:sans-sucres-ajoutes'];
        const rawFruitVegRegex = /\b(abricot|abricots|ananas|avocat|avocats|banane|bananes|cassis|cerise|cerises|citron|citrons|clémentine|clémentines|coing|coings|datte|dattes|figue|figues|fraise|fraises|framboise|framboises|grenade|grenades|groseille|groseilles|kiwi|kiwis|kumquat|kumquats|litchi|litchis|mandarine|mandarines|mangue|mangues|melon|melons|mirabelle|mirabelles|mûre|mûres|myrtille|myrtilles|nectarine|nectarines|orange|oranges|pamplemousse|pamplemousses|papaye|papayes|pastèque|pastèques|pêche|pêches|poire|poires|pomme|pommes|prune|prunes|raisin|raisins|tomate|tomates|artichaut|artichauts|asperge|asperges|aubergine|aubergines|betterave|betteraves|blette|blettes|brocoli|brocolis|carotte|carottes|céleri|céleris|champignon|champignons|chou|choux|concombre|concombres|courgette|courgettes|endive|endives|épinard|épinards|fenouil|fenouils|haricot vert|haricots verts|laitue|laitues|maïs|navet|navets|oignon|oignons|panais|poivron|poivrons|potiron|potirons|radis|salade|salades)\b/;
        const processedFruitRegex = /\b(jus de|compote|purée de|confiture|sirop)/;
        let ingredientEffectiveSugar = ing.nutrition.sugars || 0;
        if (labels.some(label => noAddedSugarLabels.includes(label)) || (rawFruitVegRegex.test(name) && !processedFruitRegex.test(name))) {
            ingredientEffectiveSugar *= 0.20;
        } else if (processedFruitRegex.test(name)) {
            ingredientEffectiveSugar *= 0.60;
        }
        effectiveTotalSugars += ingredientEffectiveSugar;
        const nut = ing.nutrition;
        acc.calories += nut.calories || 0;
        acc.protein += nut.protein || 0;
        acc.saturated_fat += nut.saturated_fat || 0;
        acc.fiber += ing.nutrition.fiber || 0;
        return acc;
    }, { calories: 0, protein: 0, saturated_fat: 0, fiber: 0 });

    const adjustments = { sugarMalus: 0, satFatMalus: 0, proteinBonus: 0, completenessBonus: 0 };
    if (totals.calories > 0) {
        const sugarCaloriePercent = (effectiveTotalSugars * 4 / totals.calories) * 100;
        const satFatCaloriePercent = (totals.saturated_fat * 9 / totals.calories) * 100;
        const proteinCaloriePercent = (totals.protein * 4 / totals.calories) * 100;
        if (sugarCaloriePercent > 30) adjustments.sugarMalus = Math.round(-Math.min(5, (sugarCaloriePercent - 30) * 0.2));
        if (satFatCaloriePercent > 15) adjustments.satFatMalus = Math.round(-Math.min(5, (satFatCaloriePercent - 15) * 0.3));
        if (proteinCaloriePercent > 25) adjustments.proteinBonus = Math.round(Math.min(5, (proteinCaloriePercent - 25) * 0.2));
        if (totals.protein >= 20 && totals.fiber >= 5) adjustments.completenessBonus = 3;
    }
    
    const totalAdjustment = Object.values(adjustments).reduce((sum, val) => sum + val, 0);
    const finalScore = Math.max(0, Math.min(100, Math.round(baseScore + totalAdjustment)));

    return { finalScore, adjustments };
}

async function handleOnboardingEvents(e) {
    // Gestion du menu déroulant pour le sexe
    const sexBtn = e.target.closest('#onboarding-sex-select');
    if (sexBtn) {
        const options = sexBtn.nextElementSibling;
        options.classList.toggle('active');
        sexBtn.classList.toggle('active');
        return;
    }

    // Gestion du menu déroulant pour le pays
    const countryBtn = e.target.closest('#onboarding-country-select');
    if (countryBtn) {
        const options = countryBtn.nextElementSibling;
        options.classList.toggle('active');
        countryBtn.classList.toggle('active');
        return;
    }

    // Gestion de la sélection d'une option
    const option = e.target.closest('.custom-select-option');
    if (option) {
        const parentBtn = option.closest('.custom-select-container').querySelector('button');
        parentBtn.innerHTML = option.innerHTML + `<i class="fa-solid fa-chevron-down text-gray-500"></i>`;
        
        const target = parentBtn.id === 'onboarding-sex-select' ? 'sex' : 'country';
        state.tempUserProfile[target] = option.dataset.value;

        // Ferme le menu déroulant après la sélection
        parentBtn.nextElementSibling.classList.remove('active');
        parentBtn.classList.remove('active');
        return;
    }

    // Gestion du clic sur le bouton "Commencer !"
    const saveBtn = e.target.closest('#complete-onboarding-btn');
    if (saveBtn) {
        const name = document.getElementById('onboarding-name').value.trim();
        const dob = document.getElementById('onboarding-dob').value;
        const weight = parseFloat(document.getElementById('onboarding-weight').value);
        const sex = state.tempUserProfile.sex;
        const country = state.tempUserProfile.country;
        
        if (!name || !dob || !sex || !country || !weight || weight <= 0) {
            showToast("Veuillez remplir toutes les informations.", "error");
            return;
        }

        const userRef = doc(db, 'users', currentUserId);
        // Référence au profil public
        const publicProfileRef = doc(db, 'publicProfiles', currentUserId);
        
        try {
            // Création de l'objet du profil utilisateur avec toutes les valeurs par défaut
            const newUserProfile = {
                name: name,
                dob: dob,
                sex: sex,
                country: country,
                profilePicUrl: null,
                coins: 100,
                inventory: { borders: ['b001'], titles: ['t001'], collectibles: [] },
                equipped: { border: 'b001', title: 't001', showcase: [null, null, null] },
                achievements: { 'hello_world': { progress: 1, claimedTiers: [] } },
                leveling: { realLevel: 1, xp: 0, isMaxedOut: false },
                quests: { lastDailyReset: null, lastWeeklyReset: null, daily: [], weekly: [] }
            };
            
            // Préparation du document complet pour la collection privée 'users'
            const privateUserData = {
                userProfile: newUserProfile,
                userGoals: { calories: 2500, protein: 180, bodyWeight: weight },
                workouts: [],
                meals: [],
                sessionHistory: [],
                calendarEvents: [],
                workoutTags: state.workoutTags,
                mealTags: state.mealTags,
                exerciseStats: {},
                streaks: { workout: { count: 0, lastChance: false }, nutrition: { count: 0 } },
                recurrence: {
                    workout: { enabled: false, period: 'week', templates: { week: {}, month: {} } },
                    nutrition: { enabled: false, period: 'week', templates: { week: {}, month: {} } }
                },
                friends: { accepted: [], pendingSent: [], pendingReceived: [] }
            };
            
            // Préparation de la "carte de visite" pour la collection publique 'publicProfiles'
            const publicUserData = {
                uid: currentUserId,
                name: name,
                name_lowercase: name.toLowerCase(),
                profilePicUrl: null,
                country: country,
                sex: sex,
                leveling: newUserProfile.leveling,
                equipped: newUserProfile.equipped,
                globalRank: "Novice III"
            };

            // Mise à jour de l'état local pour une transition fluide
            state = deepMerge(state, privateUserData);
            checkAndResetQuests();
            privateUserData.userProfile.quests = state.userProfile.quests;

            // Sauvegarde des deux documents en parallèle pour plus d'efficacité
            await Promise.all([
                setDoc(userRef, privateUserData),
                setDoc(publicProfileRef, publicUserData)
            ]);

            showToast("Votre profil a été créé !", "success");
            navigate('Accueil'); 

        } catch (error) {
            console.error("Erreur lors de la création du profil :", error);
            showToast("Erreur lors de la création du profil. Veuillez réessayer.", "error");
        }
    }
}

async function handleAutocompleteSearch(e) {
    const query = e.target.value;
    const resultsContainer = document.getElementById('autocomplete-results');
    if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
    if (!query || query.length < 3) {
        resultsContainer.innerHTML = '';
        currentSearchResults = [];
        return;
    }
    resultsContainer.innerHTML = '<div class="p-3 text-gray-400 text-center">Recherche...</div>';
    autocompleteTimeout = setTimeout(async () => {
        try {
            const fields = 'code,product_name_fr,product_name,brands,nutriments,image_url,nutriscore_score,additives_tags,labels_tags';
            const encodedQuery = encodeURIComponent(query);
            const apiUrl = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodedQuery}&action=process&json=1&page_size=20&lc=fr&sort_by=unique_scans_n&fields=${fields}`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`Erreur API: Statut ${response.status}`);
            }
            const data = await response.json();
            
            if (!data.products || data.products.length === 0) {
                 resultsContainer.innerHTML = '<div class="p-3 text-gray-500 text-center">Aucun résultat trouvé.</div>';
                 currentSearchResults = [];
                 return;
            }

            const formattedProducts = data.products.map(_formatApiProduct);

            // --- MODIFICATION CLÉ : ON AJOUTE DEUX FILTRES ---
            const filteredProducts = formattedProducts.filter(p => {
                const base = p.base_100g;
                const name = p.name.toLowerCase();
                
                // Règle 1: Doit avoir un Nutri-Score connu.
                const hasNutriScore = typeof base.nutri_score_value === 'number';
                
                // Règle 2: Doit avoir des calories, SAUF si c'est de l'eau.
                const isWater = name.includes('eau de source') || name.includes('eau minérale');
                const hasCalories = typeof base.calories === 'number' && base.calories > 0;

                return hasNutriScore && (hasCalories || isWater);
            });
            // --- FIN DE LA MODIFICATION ---

            currentSearchResults = filteredProducts;

            if (currentSearchResults.length === 0) {
                resultsContainer.innerHTML = '<div class="p-3 text-gray-500 text-center">Aucun aliment pertinent trouvé.</div>';
                return;
            }

            resultsContainer.innerHTML = currentSearchResults.map((food, index) =>
                `<div class="p-3 hover:bg-violet-500 rounded-md cursor-pointer" data-index="${index}"><p class="font-semibold">${food.name}</p><p class="text-sm text-gray-400">${food.brand || 'Marque inconnue'} - ${food.base_100g.calories || '0'} kcal</p></div>`
            ).join('');
        } catch (error) {
            resultsContainer.innerHTML = '<div class="p-3 text-red-400 text-center">Erreur de connexion à l\'API.</div>';
        }
    }, 300);
}

        async function addIngredientToMeal(foodItem, isQuickAdd = false) {
    const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-4">Quantité pour ${foodItem.name}</h2>
        <div class="relative">
            <input id="quantity-input" type="number" class="input-glass text-center" placeholder="Ex: 150" onkeydown="return event.key !== '.' && event.key !== ',' && event.key !== 'e' && event.key !== 'E' && event.key !== '-'">
            <span class="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400">grammes</span>
        </div>
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-quantity-btn" class="w-full btn-primary">Ajouter</button>
        </div>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#confirm-quantity-btn').onclick = async () => {
            const quantity = parseInt(modalWrapper.querySelector('#quantity-input').value) || 0;
            if (!quantity || quantity <= 0) return;

            const base = foodItem.base_100g;
            const nutritionForPortion = {
                calories: (base.calories / 100) * quantity,
                protein: (base.protein / 100) * quantity,
                carbs: (base.carbs / 100) * quantity,
                fat: (base.fat / 100) * quantity,
                sugars: (base.sugars / 100) * quantity,
                fiber: (base.fiber / 100) * quantity,
                saturated_fat: (base.saturated_fat / 100) * quantity
            };

            const newIngredient = {
                id: generateId(),
                name: foodItem.name,
                code: foodItem.code, 
                quantity,
                imageUrl: foodItem.imageUrl,
                nutrition: nutritionForPortion,
                additives: foodItem.additives || [],
                labels_tags: foodItem.labels_tags || [],
                base_100g: base 
            };

            if (isQuickAdd) {
                const newMeal = { id: generateId(), name: newIngredient.name, ingredients: [newIngredient], nutrition: newIngredient.nutrition, isQuickAdd: true };
                state.meals.push(newMeal);
                
                const now = new Date();
                const newEvent = { id: generateId(), date: formatDateToYYYYMMDD(now), refId: newMeal.id, title: newMeal.name, time: now.toTimeString().slice(0,5), type: 'meal', completed: false, validated: false };
                state.calendarEvents.push(newEvent);
                await saveState();

                closeModal();
                render();
            } else if (state.editingMeal) {
                state.editingMeal.ingredients.push(newIngredient);
                await saveState();
                closeModal();
                render(); 
            }
        };
    });
}

function calculateIngredientFitScore(ingredient) {
    const base = ingredient?.base_100g;

    // Règle unique : si le Nutri-Score n'est pas un nombre, l'ingrédient est invalide pour les calculs.
    if (typeof base?.nutri_score_value !== 'number') {
        console.warn(`Nutri-Score manquant pour '${ingredient.name}'. L'ingrédient sera ignoré dans les calculs.`);
        return null; 
    }

    // Le calcul se poursuit uniquement pour les aliments valides.
    const macroScore = _getMacroScore(ingredient);
    const nutriScoreValue = base.nutri_score_value;

    const nutriScoreComponent = _convertScoreToFitScore(nutriScoreValue);
    const finalScore = (nutriScoreComponent * 0.6) + (macroScore * 0.4);
    const roundedFinalScore = Math.round(finalScore);
    
    return { score: roundedFinalScore, details: null };
}

// --- NOUVELLE FONCTION _getMacroScore (REMPLACEZ L'ANCIENNE PAR CELLE-CI) ---
function _getMacroScore(ingredient) {
    const base = ingredient.base_100g;
    const SUGAR_WEIGHT = 1.0;
    const SAT_FAT_WEIGHT = 1.5;
    const SALT_WEIGHT = 15.0;
    const DECAY_CONSTANT = 0.05;
    const PROTEIN_BONUS = 0.5;
    const FIBER_BONUS = 1.0;

    const sugar = base.sugars || 0;
    const saturatedFat = base.saturated_fat || 0;
    const salt = base.salt || 0;
    const protein = base.protein || 0;
    const fiber = base.fiber || 0;
    
    const labels = ingredient.labels_tags || [];
    const name = ingredient.name ? ingredient.name.toLowerCase() : '';

    const noAddedSugarLabels = ['en:no-added-sugar', 'fr:sans-sucres-ajoutes'];
    
    // CORRECTION DÉFINITIVE : Liste exhaustive des formes singulières et plurielles
    const rawFruitVegRegex = /\b(abricot|abricots|ananas|avocat|avocats|banane|bananes|cassis|cerise|cerises|citron|citrons|clémentine|clémentines|coing|coings|datte|dattes|figue|figues|fraise|fraises|framboise|framboises|grenade|grenades|groseille|groseilles|kiwi|kiwis|kumquat|kumquats|litchi|litchis|mandarine|mandarines|mangue|mangues|melon|melons|mirabelle|mirabelles|mûre|mûres|myrtille|myrtilles|nectarine|nectarines|orange|oranges|pamplemousse|pamplemousses|papaye|papayes|pastèque|pastèques|pêche|pêches|poire|poires|pomme|pommes|prune|prunes|raisin|raisins|tomate|tomates|artichaut|artichauts|asperge|asperges|aubergine|aubergines|betterave|betteraves|blette|blettes|brocoli|brocolis|carotte|carottes|céleri|céleris|champignon|champignons|chou|choux|concombre|concombres|courgette|courgettes|endive|endives|épinard|épinards|fenouil|fenouils|haricot vert|haricots verts|laitue|laitues|maïs|navet|navets|oignon|oignons|panais|poivron|poivrons|potiron|potirons|radis|salade|salades)\b/;
    
    const processedFruitRegex = /\b(jus de|compote|purée de|confiture|sirop)/;

    let effectiveSugar = sugar;
    
    if (labels.some(label => noAddedSugarLabels.includes(label)) || (rawFruitVegRegex.test(name) && !processedFruitRegex.test(name))) {
        effectiveSugar *= 0.20;
    } else if (processedFruitRegex.test(name)) {
        effectiveSugar *= 0.60;
    }

    const badnessScore = (effectiveSugar * SUGAR_WEIGHT) + (saturatedFat * SAT_FAT_WEIGHT) + (salt * SALT_WEIGHT);
    const baseScore = 100 * Math.exp(-DECAY_CONSTANT * badnessScore);
    const bonusScore = (protein * PROTEIN_BONUS) + (fiber * FIBER_BONUS);
    const finalScore = baseScore + bonusScore;
    
    return Math.max(0, Math.min(100, Math.round(finalScore)));
}

// --- FONCTION UTILITAIRE (INCHANGÉE, POUR CONTEXTE) ---
function _convertScoreToFitScore(scoreValue) {
    // ... (aucun changement ici, la fonction est déjà parfaite)
    const mapRange = (value, in_min, in_max, out_min, out_max) => {
        return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    };
    let fitScore;
    if (scoreValue <= -1) { fitScore = mapRange(scoreValue, -15, -1, 100, 90); }
    else if (scoreValue <= 2) { fitScore = mapRange(scoreValue, 0, 2, 89, 70); }
    else if (scoreValue <= 10) { fitScore = mapRange(scoreValue, 3, 10, 69, 50); }
    else if (scoreValue <= 18) { fitScore = mapRange(scoreValue, 11, 18, 49, 25); }
    else { fitScore = mapRange(scoreValue, 19, 40, 24, 0); }
    return Math.max(0, Math.min(100, Math.round(fitScore)));
}
        
/**
 * NOUVELLE FONCTION D'ASSISTANCE POUR L'APPEL À L'API
 * Isole la logique de l'appel réseau et le formatage des données.
 */
async function fetchProductFromAPI(code) {
    // On définit les champs dont on a besoin pour optimiser la requête
    const fields = 'product_name_fr,product_name,nutriments,brands,image_url,nutriscore_grade,nutriscore_score,code,additives_tags,labels_tags';
    const apiUrl = `https://world.openfoodfacts.org/api/v2/product/${code}?fields=${fields}`;

    try {
        const response = await fetch(apiUrl, {
            // Un User-Agent est recommandé pour être poli avec l'API
            headers: { 'User-Agent': 'FitFlowApp/1.0 - Projet Etudiant' }
        });

        // On vérifie si la requête a échoué (ex: erreur 404 ou 500)
        if (!response.ok) {
            throw new Error(`L'API a répondu avec le statut : ${response.status}`);
        }

        const apiData = await response.json();

        // On vérifie si l'API a bien trouvé un produit correspondant au code
        if (apiData.status === 1 && apiData.product) {
            // On utilise la fonction de formatage pour garantir un objet cohérent
            return _formatApiProduct(apiData.product);
        } else {
            // Le produit n'existe pas dans la base de données
            console.warn(`Produit non trouvé dans OpenFoodFacts pour le code : ${code}`);
            return null;
        }

    } catch (error) {
        // On attrape les erreurs (problème de réseau, API indisponible, etc.)
        console.error("Erreur lors de la récupération du produit depuis l'API :", error);
        return null; // On retourne null pour que le reste de l'app puisse gérer l'échec
    }
}

/**
 * VERSION FINALE DE LA FONCTION startScanner
 * Intègre la nouvelle interface et des améliorations de fiabilité.
 */
async function startScanner(isQuickAdd = false) {
    // 1. Interface de la modale améliorée avec un viseur esthétique et une animation.
    const modalContent = `
        <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center flex flex-col h-[80vh]">
            <header class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Scanner un produit</h2>
                <button id="torch-toggle-btn" class="text-gray-400 hover:text-white p-2 w-10 h-10 rounded-full bg-black/20 hidden" title="Activer le flash">
                    <i class="fa-solid fa-lightbulb text-lg"></i>
                </button>
            </header>
            
            <div id="interactive" class="relative flex-grow rounded-lg overflow-hidden bg-black group">
                <style>
                    .scanner-corner {
                        position: absolute; width: 30px; height: 30px;
                        border: 5px solid white; border-radius: 12px;
                        transition: border-color 0.2s;
                    }
                    .group:hover .scanner-corner { border-color: var(--accent-color); }
                    .scanner-corner.top-left { top: 15px; left: 15px; border-right: none; border-bottom: none; }
                    .scanner-corner.top-right { top: 15px; right: 15px; border-left: none; border-bottom: none; }
                    .scanner-corner.bottom-left { bottom: 15px; left: 15px; border-right: none; border-top: none; }
                    .scanner-corner.bottom-right { bottom: 15px; right: 15px; border-left: none; border-top: none; }
                    @keyframes scanner-animation {
                        0%, 100% { top: 15%; } 50% { top: 85%; }
                    }
                    .scanner-laser {
                        position: absolute; left: 10%; right: 10%; height: 2px;
                        background: var(--accent-color);
                        box-shadow: 0 0 8px var(--accent-color);
                        animation: scanner-animation 3s infinite ease-in-out;
                        border-radius: 2px;
                    }
                </style>
                <div class="scanner-corner top-left"></div>
                <div class="scanner-corner top-right"></div>
                <div class="scanner-corner bottom-left"></div>
                <div class="scanner-corner bottom-right"></div>
                <div class="scanner-laser"></div>
            </div>
            
            <p id="scan-status-message" class="text-gray-400 mt-4 h-6 flex items-center justify-center font-semibold">
                Visez un code-barres...
            </p>
            <button class="close-modal w-full mt-4 glass-card p-3 rounded-lg font-bold">Annuler</button>
        </div>
    `;

    // FIABILITÉ ACCRUE : Le 'closeCallback' garantit que la caméra est toujours libérée.
    const cleanup = () => {
        Quagga.stop();
        // Vous pouvez ajouter d'autres actions de nettoyage ici si nécessaire.
    };

    showModal(modalContent, (modalWrapper) => {
        // ... (Le reste du code de la fonction est quasi identique à la version précédente)
        const scannerContainer = modalWrapper.querySelector('#interactive');
        const statusMessageEl = modalWrapper.querySelector('#scan-status-message');
        const torchBtn = modalWrapper.querySelector('#torch-toggle-btn');
        let isTorchOn = false;

        const quaggaConfig = {
            inputStream: {
                name: "Live",
                type: "LiveStream",
                target: scannerContainer,
                constraints: {
                    width: { min: 640, ideal: 1280 },
                    height: { min: 480, ideal: 720 },
                    facingMode: "environment",
                    advanced: [{ torch: isTorchOn }, { focusMode: 'continuous' }]
                },
                area: { top: "30%", right: "10%", left: "10%", bottom: "30%" },
                frequency: 10
            },
            locator: { halfSample: false, patchSize: "large" },
            decoder: { readers: ["ean_reader", "upc_reader", "ean_8_reader", "code_128_reader"], multiple: false },
            locate: true,
            numOfWorkers: navigator.hardwareConcurrency || 2,
        };

        const startQuagga = () => {
            Quagga.init(quaggaConfig, function (err) {
                if (err) {
                    // GESTION AMÉLIORÉE : Gestion plus claire des erreurs de caméra.
                    console.error("Erreur QuaggaJS:", err);
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        statusMessageEl.textContent = "Accès à la caméra refusé.";
                    } else {
                        statusMessageEl.textContent = "Erreur caméra.";
                    }
                    statusMessageEl.classList.add('text-red-400');
                    return;
                }
                const capabilities = Quagga.CameraAccess.getActiveTrack().getCapabilities();
                if (capabilities.torch) {
                    torchBtn.classList.remove('hidden');
                }
                Quagga.start();
            });
        };

        startQuagga();

        let detectedCodes = [];
        const requiredDetections = 3;

        Quagga.onDetected(async (result) => {
            const code = result.codeResult.code;
            if (!code) return;

            detectedCodes.push(code);
            if (detectedCodes.length < requiredDetections) return;

            const lastDetections = detectedCodes.slice(-requiredDetections);
            if (new Set(lastDetections).size === 1) {
                cleanup(); // Arrête le scanner
                detectedCodes = []; 

                statusMessageEl.textContent = `Recherche de ${code}...`;
                statusMessageEl.classList.add('text-yellow-400');
                
                let productData = null;
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        productData = await fetchProductFromAPI(code);
                        if (productData) break;
                    } catch (error) {
                        console.error(`Tentative API ${attempt} échouée:`, error);
                        if (attempt >= 3) {
                            showToast("Produit non trouvé après plusieurs tentatives.", "error");
                            closeModal();
                            return;
                        }
                    }
                }

                closeModal();

                if (productData) {
                    addIngredientToMeal(productData, isQuickAdd);
                    showToast("Produit ajouté !", "success");
                    updateAchievementProgress('scan_master', code, 'add_to_set');
                } else {
                     showToast("Produit non trouvé.", "error");
                }
            } else {
                detectedCodes = detectedCodes.slice(1);
            }
        });

        torchBtn.addEventListener('click', () => {
            isTorchOn = !isTorchOn;
            torchBtn.classList.toggle('text-yellow-400', isTorchOn);
            torchBtn.classList.toggle('bg-yellow-400/20', isTorchOn);
            Quagga.stop();
            quaggaConfig.inputStream.constraints.advanced = [{ torch: isTorchOn }, { focusMode: 'continuous' }];
            startQuagga();
        });

    }, cleanup); // On passe la fonction de nettoyage ici
}

function convertScoreToGrade(score) {
    if (score >= 80) return 'A';
    if (score >= 60) return 'B';
    if (score >= 40) return 'C';
    if (score >= 20) return 'D';
    return 'E';
}

        function openQuickAddFood() {
            const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
                <h2 class="text-xl font-bold mb-6">Ajout Rapide</h2>
                <div class="space-y-4">
                     <button id="quick-add-search-btn" class="w-full btn-primary">
                        <i class="fa-solid fa-search mr-2"></i> Rechercher un aliment
                    </button>
                    <button id="quick-add-scan-btn" class="w-full btn-primary">
                        <i class="fa-solid fa-barcode mr-2"></i> Scanner un produit
                    </button>
                </div>
                 <button class="close-modal w-full mt-8 glass-card p-3 rounded-lg font-bold">Annuler</button>
            </div>`;

            showModal(modalContent, (modalWrapper) => {
                modalWrapper.querySelector('#quick-add-scan-btn').onclick = () => {
                    closeModal();
                    startScanner(true);
                };
                modalWrapper.querySelector('#quick-add-search-btn').onclick = () => {
                    const searchModalContent = `<div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col">
                        <header class="flex justify-between items-center mb-4 flex-shrink-0">
                            <h2 class="text-2xl font-bold">Ajout Rapide</h2>
                            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
                        </header>
                        <div class="relative mb-4 flex-shrink-0">
                            <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                            <input id="ingredient-search-input" type="text" placeholder="Rechercher..." class="input-glass pl-12 w-full">
                        </div>
                        <div id="autocomplete-results" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                    </div>`;

                    showModal(searchModalContent, (searchModalWrapper) => {
                         searchModalWrapper.querySelector('#ingredient-search-input').addEventListener('input', handleAutocompleteSearch);
                         searchModalWrapper.querySelector('#autocomplete-results').addEventListener('click', (e) => {
                            const resultDiv = e.target.closest('[data-index]');
                            if(resultDiv) {
                                const foodItem = currentSearchResults[parseInt(resultDiv.dataset.index)];
                                if(foodItem) {
                                    addIngredientToMeal(foodItem, true);
                                }
                            }
                         });
                    });
                };
            });
        }

        function startWorkout(eventId) {
            const event = state.calendarEvents.find(e => e.id === eventId);
            if (!event) return;
            const workoutTemplate = state.workouts.find(w => w.id === event.refId);
            if (!workoutTemplate) return;

            // === VÉRIFICATION AJOUTÉE ===
            // Si la séance n'a pas d'exercices, on affiche une erreur et on arrête.
            if (!workoutTemplate.exercises || workoutTemplate.exercises.length === 0) {
                showToast("Impossible de lancer une séance vide !", "error");
                return;
            }
            // =============================

            const session = {
                eventId: eventId,
                workout: JSON.parse(JSON.stringify(workoutTemplate)),
                currentExerciseIndex: 0,
                currentSet: 1,
                isResting: false,
                restTime: 0,
                performance: workoutTemplate.exercises.map(ex => ({ exerciseId: ex.exerciseId, sets: [] })),
                sessionBestSets: {},
                startTime: Date.now(),
            };
            
            state.activeWorkoutSession = session;
            navigate('WorkoutPlayer', { eventId });
        }

        async function startWorkoutFromTemplate(workoutId) {
            const workoutTemplate = state.workouts.find(w => w.id === workoutId);
            if (!workoutTemplate) return;

            // === VÉRIFICATION AJOUTÉE ===
            // On vérifie aussi ici pour une meilleure réactivité.
            if (!workoutTemplate.exercises || workoutTemplate.exercises.length === 0) {
                showToast("Impossible de lancer une séance vide !", "error");
                return;
            }
            // =============================

            // Crée un événement temporaire pour aujourd'hui
            const now = new Date();
            const tempEvent = {
                id: generateId(),
                date: formatDateToYYYYMMDD(now),
                refId: workoutId,
                title: workoutTemplate.name,
                time: now.toTimeString().slice(0, 5),
                type: 'workout',
                completed: false,
                isUnscheduled: true // Un drapeau pour identifier ces séances si besoin
            };
            state.calendarEvents.push(tempEvent);

            await saveState();

            // Utilise la logique de lancement existante avec l'ID du nouvel événement
            startWorkout(tempEvent.id);
        }

        function finishSet() {
    if (!state.activeWorkoutSession) return;
    const session = state.activeWorkoutSession;
    const repsInput = document.getElementById('reps-input');
    const weightInput = document.getElementById('weight-input');
    const messageContainer = document.getElementById('humorous-message-container');

    const reps = parseInt(repsInput.value) || 0;
    let weight = parseFloat(weightInput.value) || 0;

    const roundToQuarter = (num) => {
        if (num > 999.75 && num < 1000) {
            return 999.75;
        }
        return Math.round(num * 4) / 4;
    };

    weight = roundToQuarter(weight);
    weightInput.value = weight;

    const maxWeight = 999.99;
    const maxReps = 999;
    const isWeightTooHigh = weight >= 1000;
    const isRepsTooHigh = reps > maxReps;

    const humorousMessages = [
        "Même Hercule n'y arriverait pas, petit malin.",
        "Ton alter ego est un T-Rex ? Car là, on dirait que t'essaies de soulever la lune.",
        "Je crois que tu as oublié de diviser par l'âge de l'univers.",
        "Le record du monde est loin derrière, mais pas de 1000 kg quand même !",
        "C'est un poids ou une valeur aléatoire ? On va partir sur un poids plus réaliste.",
        "J'ai vu un chat soulever 1000kg. Et c'est un chat de dessin animé.",
        "Tu as l'intention de plier la barre en deux ?",
        "Wow, tu as trouvé un bug. Mais je ne suis pas un poids.",
        "Es-tu un robot ? S'il vous plaît, ne cassez pas l'application.",
    ];

    const funnyRepsMessages = [
        "J'ai cru que tu avais fait une sieste sur le banc, mais c'était la 999ème répétition !",
        "On a un nouveau maître des répétitions ici... mais pas tout de suite.",
        "Tu t'es perdu dans tes comptes ? Recommence, mais pas plus de 999.",
        "À ce niveau de reps, c'est du cardio, plus de la muscu !",
        "À ce rythme-là, on va devoir racheter la machine.",
        "D'accord, on a compris, tu es très endurant. Mais pas de 1000 reps, la machine risque de casser !",
        "Le système peut pas compter jusque là. Réinitialise.",
        "Mon cerveau a fondu, 999 reps c'est bien, mais pas 1000.",
    ];

    const epicMessages = [
        "Calme-toi, tu vas soulever la salle entière !",
        "Je suis sûr que tu vas pouvoir soulever ma voiture, mais on va s'arrêter là pour l'instant.",
        "Wow, tu as une force surhumaine, il faut doser un peu !",
        "Tu es en train de battre tous les records à la fois. Ce n'est pas permis !",
        "Le système a planté, un humain n'est pas censé être aussi fort et endurant en même temps."
    ];

    // Fonction d'assistance pour obtenir un message unique
    const getUniqueMessage = (messages, lastMessage) => {
        let newMessage;
        do {
            newMessage = messages[Math.floor(Math.random() * messages.length)];
        } while (newMessage === lastMessage);
        return newMessage;
    };

    let currentMessage = '';
    
    if (isWeightTooHigh && isRepsTooHigh) {
        currentMessage = getUniqueMessage(epicMessages, lastHumorousMessage);
        weightInput.classList.add('animate-shake');
        repsInput.classList.add('animate-shake');
    } else if (isWeightTooHigh) {
        currentMessage = getUniqueMessage(humorousMessages, lastHumorousMessage);
        weightInput.classList.add('animate-shake');
    } else if (isRepsTooHigh) {
        currentMessage = getUniqueMessage(funnyRepsMessages, lastHumorousMessage);
        repsInput.classList.add('animate-shake');
    }

    if (currentMessage) {
        messageContainer.textContent = currentMessage;
        lastHumorousMessage = currentMessage; // Met à jour le dernier message
        messageContainer.classList.remove('hidden');
        repsInput.addEventListener('animationend', () => repsInput.classList.remove('animate-shake'), { once: true });
        weightInput.addEventListener('animationend', () => weightInput.classList.remove('animate-shake'), { once: true });
        return;
    }

    // Réinitialisation des classes d'erreur
    weightInput.classList.remove('animate-shake');
    repsInput.classList.remove('animate-shake');
    messageContainer.classList.add('hidden');
    
    const set = { reps, weight };
    session.performance[session.currentExerciseIndex].sets.push(set);
    
    const exercise = getExerciseById(session.performance[session.currentExerciseIndex].exerciseId);
    
    const params = { type: exercise.type, coefficient: exercise.coefficient, pdcPercent: exercise.pdcPercent };
    const score = calculatePerformanceScore({ ...params, charge: set.weight, reps: set.reps, poidsDuCorps: state.userGoals.bodyWeight });
    
    const currentBestSet = session.sessionBestSets[exercise.id] || {score: 0};
    if(score > currentBestSet.score) {
        session.sessionBestSets[exercise.id] = { ...set, score };
    }

    const currentExercisePlan = session.workout.exercises[session.currentExerciseIndex];

    const isLastExercise = session.currentExerciseIndex === session.workout.exercises.length - 1;
    const isLastSetOfExercise = session.currentSet === currentExercisePlan.sets;

    if (isLastExercise && isLastSetOfExercise) {
        finishWorkout();
        return;
    }

    session.isResting = true;
    session.restTime = currentExercisePlan.rest;

    if (playerTimer) clearInterval(playerTimer);
    playerTimer = setInterval(() => {
        session.restTime--;
        
        const restTimerElement = document.getElementById('rest-timer-display');
        if(restTimerElement) {
           restTimerElement.textContent = formatDuration(session.restTime * 1000);
        }

        if (session.restTime <= 0) {
            clearInterval(playerTimer);
            playerTimer = null;
            nextPlayerStep();
        }
    }, 1000);
    
    render();
}

        function nextPlayerStep() {
            if (!state.activeWorkoutSession) return;
            if(playerTimer) clearInterval(playerTimer);
            playerTimer = null;

            const session = state.activeWorkoutSession;
            const currentExercisePlan = session.workout.exercises[session.currentExerciseIndex];

            session.isResting = false;
            
            if (session.currentSet < currentExercisePlan.sets) {
                session.currentSet++;
            } else {
                if (session.currentExerciseIndex < session.workout.exercises.length - 1) {
                    session.currentExerciseIndex++;
                    session.currentSet = 1;
                } else {
                    finishWorkout();
                    return; 
                }
            }
            render();
        }

        // REMPLACEZ votre fonction finishWorkout existante par celle-ci
async function finishWorkout() {
    const session = state.activeWorkoutSession;
    if (!session) return;

    if (playerTimer) clearInterval(playerTimer);
    if (sessionDurationTimer) clearInterval(sessionDurationTimer);
    playerTimer = null;
    sessionDurationTimer = null;
    
    const startTime = new Date(session.startTime);
    const durationMs = Date.now() - session.startTime;
    const bodyWeight = state.userGoals.bodyWeight;

    const rejectedPerformancesForMessage = [];

    const sbdExerciseIds = ['ex036', 'ex001', 'ex021'];
    const userData = { sex: state.userProfile.sex, bodyweight: bodyWeight };
    const processedPerformances = JSON.parse(JSON.stringify(session.performance));

    // --- BLOC ENTIÈREMENT CORRIGÉ ---
    // La logique de validation s'applique maintenant à tous les exercices lestés.
    processedPerformances.forEach(perf => {
        const exercise = getExerciseById(perf.exerciseId);
        // On ne traite que les exercices qui ont au moins une série enregistrée
        if (!perf.sets || perf.sets.length === 0) return;

        const isSBD = ['ex036', 'ex001', 'ex021'].includes(perf.exerciseId);
        const sbdLiftType = { 'ex036': 'squat', 'ex001': 'bench', 'ex021': 'deadlift' }[perf.exerciseId];
        
        // On parcourt chaque série pour la valider individuellement
        perf.sets.forEach(set => {
            set.isRejected = false; // On initialise la série comme valide par défaut

            // Cas 1 : C'est un 1RM sur un exercice SBD -> validation stricte et prioritaire
            if (isSBD && set.reps === 1) {
                const result = validateSBDPerformance({ weight: set.weight, liftType: sbdLiftType }, userData);
                if (result.status === 'rejected') {
                    set.isRejected = true;
                }
            } 
            // Cas 2 : Toutes les autres séries (multi-reps SBD, autres exercices) -> validation universelle
            else {
                if (!isPerformanceSetPlausible(set, exercise, userData)) {
                    set.isRejected = true;
                }
            }

            // Si la série est rejetée, on prépare le message pour le toast et la boîte de réception
            if (set.isRejected) {
                showToast(`Série de ${exercise.name} (${set.weight}kg x ${set.reps}) jugée irréaliste et ignorée.`, "error", 4000);
                rejectedPerformancesForMessage.push({
                    exerciseName: exercise.name,
                    weight: set.weight,
                    reps: set.reps
                });
            }
        });
    });
    // --- FIN DU BLOC CORRIGÉ ---

    const finalProcessedPerformance = processedPerformances.map(perf => {
        const exercise = getExerciseById(perf.exerciseId);
        const validSets = perf.sets.filter(set => !set.isRejected);

        if (validSets.length === 0 && perf.sets.length > 0) {
            return { ...perf, sets: perf.sets, bestSet: null, bestScoreInSession: 0, isNewPr: false, exercise, allSetsRejected: true };
        }
        
        if (validSets.length === 0) {
             return { ...perf, sets: perf.sets, bestSet: null, bestScoreInSession: 0, isNewPr: false, exercise, allSetsRejected: false };
        }

        const params = { type: exercise.type, poidsDuCorps: bodyWeight, coefficient: exercise.coefficient, pdcPercent: exercise.pdcPercent };
        const bestSetInSession = validSets.reduce((best, current) => {
            const bestScore = calculatePerformanceScore({ ...params, charge: best.weight, reps: best.reps });
            const currentScore = calculatePerformanceScore({ ...params, charge: current.weight, reps: current.reps });
            return currentScore > bestScore ? current : best;
        });
        const bestScoreInSession = calculatePerformanceScore({ ...params, charge: bestSetInSession.weight, reps: bestSetInSession.reps });
        const currentPrScore = state.exerciseStats[perf.exerciseId]?.rankPr?.score || 0;
        const isNewPr = bestScoreInSession > currentPrScore;

        return { ...perf, sets: perf.sets, bestSet: bestSetInSession, bestScoreInSession, isNewPr, exercise, allSetsRejected: false };
    });
    
    for (const exerciseId of sbdExerciseIds) {
        const perf = processedPerformances.find(p => p.exerciseId === exerciseId);
        if (!perf || !perf.sets || perf.sets.length === 0) continue;

        const validOneRepMaxSets = perf.sets.filter(s => s.reps === 1 && !s.isRejected);
        if (validOneRepMaxSets.length === 0) continue;

        const bestOneRepMaxSet = validOneRepMaxSets.reduce((best, current) => (current.weight > best.weight) ? current : best);
        const trueOneRmWeight = bestOneRepMaxSet.weight;
        const liftType = { 'ex036': 'squat', 'ex001': 'bench', 'ex021': 'deadlift' }[exerciseId];
        
        if (!state.userProfile.sbdVault || !state.userProfile.sbdVault[liftType]) {
            if (!state.userProfile.sbdVault) state.userProfile.sbdVault = {};
            state.userProfile.sbdVault[liftType] = { leaderboard: null, verified: null, pending_tribunal: null, processing: null };
        }
        const vaultLift = state.userProfile.sbdVault[liftType];

        const currentVerifiedWeight = vaultLift.verified?.weight || 0;
        const currentLeaderboardWeight = vaultLift.leaderboard?.weight || 0;
        const bestCurrentWeight = Math.max(currentVerifiedWeight, currentLeaderboardWeight);

        if (trueOneRmWeight <= bestCurrentWeight) {
            console.log(`Le 1RM de ${trueOneRmWeight}kg pour ${liftType} n'est pas supérieur au record de ${bestCurrentWeight}kg. Ignoré.`);
            continue;
        }

        const result = validateSBDPerformance({ weight: trueOneRmWeight, liftType }, userData);

        if (result.status !== 'rejected') {
            const newPerfData = {
                id: generateId(), weight: trueOneRmWeight, status: result.status, 
                timestamp: serverTimestamp(), bodyweight: bodyWeight, 
                sourcePerf: { sessionId: session.id, exerciseId, set: bestOneRepMaxSet }
            };

            if (result.status === 'verified') {
                vaultLift.verified = newPerfData;
                showToast(`Nouveau 1RM vérifié pour le ${liftType} ajouté au coffre-fort !`, "success");

                const newVerifiedWeight = newPerfData.weight;
                const statusesToClean = ['pending_tribunal', 'processing', 'pending'];
                for (const status of statusesToClean) {
                    const perfToClean = vaultLift[status];
                    if (perfToClean && newVerifiedWeight >= perfToClean.weight) {
                        console.log(`Nettoyage de la performance '${status}' de ${perfToClean.weight}kg, car elle est obsolète.`);
                        if (perfToClean.validationId) {
                            await deletePendingPerformance(perfToClean.validationId);
                        }
                        vaultLift[status] = null;
                    }
                }
            } else if (result.status === 'pending_tribunal') {
                if (!vaultLift.pending_tribunal || newPerfData.weight > vaultLift.pending_tribunal.weight) {
                    vaultLift.pending_tribunal = newPerfData;
                    showToast(`Nouveau 1RM en attente pour le ${liftType} ajouté au coffre-fort.`, "info");
                }
            }
        }
    }

    let newPrCount = 0;
    let totalVolume = 0;
    let totalReps = 0;
    let totalSets = 0;
    const trainedMuscleGroups = new Set();
    const finalPerformanceForHistory = [];

    finalProcessedPerformance.forEach(perf => {
        // CORRECTION CLÉ : On filtre les séries invalides AVANT de calculer les stats
        const validSets = perf.sets.filter(s => !s.isRejected);

        finalPerformanceForHistory.push({
            exerciseId: perf.exerciseId,
            sets: perf.sets, 
            isNewPr: !perf.allSetsRejected && perf.isNewPr,
            bestSet: perf.bestSet,
            isRejected: perf.allSetsRejected
        });

        // On ignore les calculs pour cet exercice si toutes ses séries sont invalides
        if (perf.allSetsRejected || validSets.length === 0) return;

        const params = { type: perf.exercise.type, poidsDuCorps: bodyWeight, coefficient: perf.exercise.coefficient, pdcPercent: perf.exercise.pdcPercent };
        
        const bestValidSetForStats = validSets.reduce((best, current) => {
            const bestScore = calculatePerformanceScore({ ...params, charge: best.weight, reps: best.reps });
            const currentScore = calculatePerformanceScore({ ...params, charge: current.weight, reps: current.reps });
            return currentScore > bestScore ? current : best;
        });
        const bestValidScoreForStats = calculatePerformanceScore({ ...params, charge: bestValidSetForStats.weight, reps: bestValidSetForStats.reps });

        if (perf.exercise.groups) {
            Object.keys(perf.exercise.groups).forEach(group => trainedMuscleGroups.add(group));
        }

        // CORRECTION CLÉ : Les calculs se basent maintenant sur "validSets" et non "perf.sets"
        totalSets += validSets.length;
        validSets.forEach(set => { // Boucle uniquement sur les séries valides
            let effectiveWeight = set.weight || 0;
            if (perf.exercise.bilateral) effectiveWeight *= 2;
            totalVolume += effectiveWeight * (set.reps || 0);
            totalReps += (set.reps || 0);
        });

        if (perf.isNewPr) {
            newPrCount++;
            const currentStats = state.exerciseStats[perf.exerciseId] || { allTimeBest: null };
            state.exerciseStats[perf.exerciseId] = {
                ...currentStats,
                rankPr: { score: bestValidScoreForStats, bestSet: bestValidSetForStats, dateAchieved: new Date().toISOString(), bodyWeightAtPR: bodyWeight }
            };
        }
        
        const currentAllTimeBestSet = state.exerciseStats[perf.exerciseId]?.allTimeBest?.bestSet || { weight: 0, reps: 0 };
        const absoluteScoreCurrent = calculateAbsolutePerformance({ ...perf.exercise, charge: currentAllTimeBestSet.weight, reps: currentAllTimeBestSet.reps });
        const absoluteScoreNew = calculateAbsolutePerformance({ ...perf.exercise, charge: bestValidSetForStats.weight, reps: bestValidSetForStats.reps });
        if (absoluteScoreNew > absoluteScoreCurrent) {
            if (!state.exerciseStats[perf.exerciseId]) state.exerciseStats[perf.exerciseId] = {};
            state.exerciseStats[perf.exerciseId].allTimeBest = { bestSet: bestValidSetForStats, date: new Date().toISOString() };
        }

        const rmValuesForAchievements = calculate1RM(bestValidSetForStats, perf.exercise);
        if (perf.exerciseId === 'ex001') updateAchievementProgress('bench_press_club', rmValuesForAchievements.total1RM, 'max');
        if (perf.exerciseId === 'ex036') updateAchievementProgress('squat_club', rmValuesForAchievements.total1RM, 'max');
        if (perf.exerciseId === 'ex021') updateAchievementProgress('deadlift_club', rmValuesForAchievements.total1RM, 'max');
    });
    
    const sessionStats = {
        durationInMinutes: durationMs / 60000,
        totalVolume, exerciseCount: finalProcessedPerformance.filter(p => !p.allSetsRejected).length,
        prBeatenCount: newPrCount, totalReps, totalSets
    };

    let totalPerformanceScore = 0;
    finalProcessedPerformance.forEach(perf => {
        if (perf.allSetsRejected) return;
        perf.sets.filter(s => !s.isRejected).forEach(set => {
            totalPerformanceScore += calculatePerformanceScore({ ...perf.exercise, charge: set.weight, reps: set.reps, poidsDuCorps: bodyWeight });
        });
    });
    sessionStats.averageSessionScore = totalSets > 0 ? totalPerformanceScore / totalSets : 0;
    
    const rewards = calculateSessionRewards(sessionStats);
    addXP(rewards.xp);
    state.userProfile.coins += rewards.gold;

    updateQuestProgress('complete_sessions', 1);
    updateQuestProgress('total_volume', totalVolume);
    updateQuestProgress('total_reps', totalReps);
    updateQuestProgress('total_training_time', sessionStats.durationInMinutes);
    updateQuestProgress('total_sets', totalSets);
    if (session.workout.exercises.length >= 5) updateQuestProgress('distinct_exercises', 1);
    if (newPrCount > 0) updateQuestProgress('break_prs', newPrCount);
    
    const mainGroups = new Set();
    trainedMuscleGroups.forEach(group => { if (['pecs', 'dos', 'jambes'].includes(group)) mainGroups.add(group); });
    if (mainGroups.has('pecs')) updateQuestProgress('train_all_muscle_groups', 1, { muscleGroup: 'pecs' });
    if (mainGroups.has('dos')) updateQuestProgress('train_all_muscle_groups', 1, { muscleGroup: 'dos' });
    if (mainGroups.has('jambes')) updateQuestProgress('train_all_muscle_groups', 1, { muscleGroup: 'jambes' });

    updateAchievementProgress('total_sessions_completed', 1, 'increment');
    updateAchievementProgress('total_volume', totalVolume, 'increment');
    updateAchievementProgress('single_session_volume', totalVolume, 'max');
    updateAchievementProgress('total_reps', totalReps, 'increment');
    updateAchievementProgress('total_sets', totalSets, 'increment');
    updateAchievementProgress('total_training_time', sessionStats.durationInMinutes / 60, 'increment');
    if (newPrCount > 0) updateAchievementProgress('pr_breaker', newPrCount, 'increment');
    if (startTime.getHours() < 7) updateAchievementProgress('early_bird', 1, 'increment');
    if (new Date().getHours() >= 22) updateAchievementProgress('night_owl', 1, 'increment');
    if (totalReps === 0 && totalSets > 0) updateAchievementProgress('failure_is_an_option', 1, 'set');
    if (totalReps === 1 && totalSets > 0) updateAchievementProgress('one_rep_max_and_out', 1, 'set');
    if (trainedMuscleGroups.size === Object.keys(MUSCLE_GROUPS).length) updateAchievementProgress('all_muscle_groups_in_week', 1, 'set');

    const sessionReport = {
        sessionId: generateId(), workoutId: session.workout.id, date: new Date().toISOString(),
        duration: durationMs, performance: finalPerformanceForHistory, rewards: rewards,
        totalVolume: totalVolume, prBeatenCount: newPrCount
    };
    state.sessionHistory.push(sessionReport);
    
    const event = state.calendarEvents.find(e => e.id === session.eventId);
    if (event) event.completed = true;

    updateStreaks();

    if (rejectedPerformancesForMessage.length > 0) {
        const subject = "Avertissement de performance";
        const content = `Certaines de vos performances de la dernière séance ont été jugées irréalistes et n'ont pas été comptabilisées dans vos statistiques :\n\n` +
                      rejectedPerformancesForMessage.map(p => `• ${p.exerciseName}: ${p.weight}kg x ${p.reps} reps`).join('\n');
        await sendSystemMessage(currentUserId, subject, content, 'fa-triangle-exclamation');
    }

    await saveState();
    state.activeWorkoutSession = null;
    navigate('WorkoutSummary', { sessionId: sessionReport.sessionId });
}

async function removeFromLeaderboard(liftType) {
    if (!currentUserId || !liftType) return;

    const perfToRemove = state.userProfile.sbdVault[liftType]?.leaderboard;
    if (!perfToRemove) {
        showToast("Aucune performance à retirer du classement.", "error");
        return;
    }

    const publicProfileRef = doc(db, 'publicProfiles', currentUserId);

    try {
        await runTransaction(db, async (transaction) => {
            const publicProfileDoc = await transaction.get(publicProfileRef);
            if (!publicProfileDoc.exists()) throw "Profil public introuvable.";

            const currentRanks = publicProfileDoc.data().sbd_ranks || {};
            
            currentRanks[liftType] = { best_1rm: 0, bodyweight: 0 };
            
            const newTotal = (currentRanks.squat?.best_1rm || 0) + (currentRanks.bench?.best_1rm || 0) + (currentRanks.deadlift?.best_1rm || 0);
            if (!currentRanks.total) currentRanks.total = {};
            currentRanks.total.best_1rm = newTotal;

            transaction.update(publicProfileRef, { sbd_ranks: currentRanks });

            // --- CORRECTION APPLIQUÉE ICI ---
            // On met à jour l'état local du coffre-fort ET des rangs pour une synchronisation parfaite.
            state.userProfile.sbd_ranks = currentRanks; // <-- Met à jour les rangs locaux
            
            const currentVerifiedPerf = state.userProfile.sbdVault[liftType]?.verified;
            if (!currentVerifiedPerf || perfToRemove.weight > currentVerifiedPerf.weight) {
                state.userProfile.sbdVault[liftType].verified = perfToRemove;
            }
            state.userProfile.sbdVault[liftType].leaderboard = null;
            // --- FIN DE LA CORRECTION ---
        });

        await saveState();
        showToast("Performance retirée du classement.", "info");
        
        // On rafraîchit la modale du coffre-fort pour montrer le changement
        const vaultSlotsContainer = document.getElementById('vault-slots-container');
        if (vaultSlotsContainer) {
            vaultSlotsContainer.innerHTML = renderVaultSlots(liftType);
        }

    } catch (error) {
        console.error("Erreur lors du retrait de la performance :", error);
        showToast("Une erreur est survenue.", "error");
    }
}


async function openSbdVaultModal() {
    if (!state.sbdVaultModal) state.sbdVaultModal = { activeLift: 'squat' };
    
    const activeLift = state.sbdVaultModal.activeLift;

    const modalContent = `
    <div id="sbd-vault-modal" class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col" style="min-height: 520px;">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Coffre-fort SBD</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-black/20 z-20">×</button>
        </header>
        
        <div class="flex-shrink-0 mb-4 p-1 bg-black/20 rounded-lg flex gap-1">
            <button data-action="select-vault-lift" data-lift-type="squat" class="vault-lift-tab flex-1 p-2 rounded-md font-semibold ${activeLift === 'squat' ? 'active' : ''}">Squat</button>
            <button data-action="select-vault-lift" data-lift-type="bench" class="vault-lift-tab flex-1 p-2 rounded-md font-semibold ${activeLift === 'bench' ? 'active' : ''}">Bench</button>
            <button data-action="select-vault-lift" data-lift-type="deadlift" class="vault-lift-tab flex-1 p-2 rounded-md font-semibold ${activeLift === 'deadlift' ? 'active' : ''}">Deadlift</button>
        </div>

        <div id="vault-slots-container" class="flex-grow overflow-y-auto pr-2 space-y-3 scrollbar-hide min-h-0">
            ${renderVaultSlots(activeLift)}
        </div>
    </div>`;

    showModal(modalContent);
}

function renderVaultSlots(liftType) {
    const vault = state.userProfile.sbdVault[liftType] || {};
    
    // On définit les 4 statuts principaux que l'on veut toujours afficher
    const statuses = [
        { key: 'leaderboard', status: 'leaderboard', label: 'Dans le classement' },
        { key: 'verified', status: 'verified', label: 'Vérifié' },
        { key: 'pending_tribunal', status: 'pending_tribunal', label: 'À faire vérifier' },
        // On regroupe "processing" et "pending" sous le même concept visuel
        { key: 'in_progress', status: vault.processing ? 'processing' : 'pending', label: 'En cours de vérification' }
    ];

    const slotsHtml = statuses.map(slotInfo => {
        const perf = vault[slotInfo.status];
        
        if (perf) {
            // S'il y a une performance, on l'affiche
            return renderVaultSlot(liftType, slotInfo.status, perf);
        } else {
            // Sinon, on affiche un emplacement vide en pointillés
            return `
            <div class="p-4 rounded-xl border-2 border-dashed border-gray-700 text-center">
                <p class="font-semibold text-gray-500">${slotInfo.label}</p>
                <p class="text-sm text-gray-600">Emplacement vide</p>
            </div>
            `;
        }
    }).join('');

    return slotsHtml;
}

// AJOUTEZ CETTE NOUVELLE FONCTION D'ASSISTANCE
function renderVaultSlot(liftType, status, perf) {
    let statusHtml, actionsHtml = '';
    const bodyweightHtml = perf.bodyweight ? `<span class="text-sm text-gray-400 font-normal">@ ${perf.bodyweight.toFixed(1)} kg</span>` : '';

    switch(status) {
        case 'leaderboard':
            statusHtml = `<span class="font-semibold text-yellow-300 glow">Dans le classement</span>`;
            actionsHtml = `<button data-action="remove-from-leaderboard" data-lift-type="${liftType}" data-status="leaderboard" class="w-full secondary-btn !border-yellow-400 !text-yellow-400 hover:!bg-yellow-400/20 text-sm py-2">Retirer</button>`;
            break;
        case 'verified':
            statusHtml = `<span class="font-semibold text-green-400">Vérifié</span>`;
            actionsHtml = `<button data-action="delete-vault-perf" data-lift-type="${liftType}" data-status="verified" class="secondary-btn !border-red-500 !text-red-400 hover:!bg-red-500/20 flex-1 text-sm py-2">Supprimer</button>
                           <button data-action="add-to-leaderboard" data-lift-type="${liftType}" data-status="verified" class="btn-primary flex-1 text-sm py-2">Publier</button>`;
            break;
        case 'pending_tribunal':
            statusHtml = `<span class="font-semibold text-orange-400">À faire vérifier</span>`;
            actionsHtml = `<button data-action="delete-vault-perf" data-lift-type="${liftType}" data-status="pending_tribunal" class="secondary-btn !border-red-500 !text-red-400 hover:!bg-red-500/20 flex-1 text-sm py-2">Supprimer</button>
                           <button data-action="submit-vault-video" data-lift-type="${liftType}" data-status="pending_tribunal" class="btn-primary flex-1 text-sm py-2">Soumettre la preuve</button>`;
            break;
        case 'processing':
            statusHtml = `<span class="font-semibold text-violet-400 animate-pulse">Traitement vidéo...</span>`;
            break;
        case 'pending':
            const approvals = perf.judgements?.filter(j => j.vote === 'legitime').length || 0;
            const rejections = perf.judgements?.filter(j => j.vote === 'invalide').length || 0;
            statusHtml = `<div class="flex items-center gap-4 text-sm">
                           <span class="font-semibold text-green-400 flex items-center gap-1.5"><i class="fa-solid fa-check"></i>${approvals}</span>
                           <span class="font-semibold text-red-400 flex items-center gap-1.5"><i class="fa-solid fa-xmark"></i>${rejections}</span>
                         </div>`;
            actionsHtml = `<button data-action="preview-pending-video" data-video-url="${perf.videoUrl}" class="secondary-btn flex-1 text-sm py-2"><i class="fa-solid fa-eye"></i></button>
                           <button data-action="delete-vault-perf" data-lift-type="${liftType}" data-status="pending" class="secondary-btn !border-red-500 !text-red-400 hover:!bg-red-500/20 flex-1 text-sm py-2"><i class="fa-solid fa-trash-can"></i></button>`;
            break;
    }

    return `
    <div class="glass-card p-4 rounded-xl">
        <div class="flex items-center justify-between">
            <p class="font-bold text-lg text-white">${perf.weight} kg ${bodyweightHtml}</p>
            <div class="text-sm">${statusHtml}</div>
        </div>
        ${actionsHtml ? `<div class="flex gap-3 mt-4 pt-3 border-t border-white/10">${actionsHtml}</div>` : ''}
    </div>`;
}

async function publishPerformanceToLeaderboard(liftType) {
    if (!currentUserId || !liftType) return;

    const perfToPublish = state.userProfile.sbdVault[liftType]?.verified;
    if (!perfToPublish) {
        showToast("Performance vérifiée introuvable.", "error");
        return;
    }

    const publicProfileRef = doc(db, 'publicProfiles', currentUserId);

    try {
        await runTransaction(db, async (transaction) => {
            const publicProfileDoc = await transaction.get(publicProfileRef);
            if (!publicProfileDoc.exists()) throw "Profil public introuvable.";

            const currentRanks = publicProfileDoc.data().sbd_ranks || {};
            const bodyweightForRank = perfToPublish.bodyweight || state.userGoals.bodyWeight;

            currentRanks[liftType] = { best_1rm: perfToPublish.weight, bodyweight: bodyweightForRank };

            const newTotal = (currentRanks.squat?.best_1rm || 0) + (currentRanks.bench?.best_1rm || 0) + (currentRanks.deadlift?.best_1rm || 0);
            if (!currentRanks.total) currentRanks.total = {};
            currentRanks.total.best_1rm = newTotal;

            transaction.update(publicProfileRef, { sbd_ranks: currentRanks });

            // Mise à jour de l'état local : on déplace la perf
            state.userProfile.sbd_ranks = currentRanks;
            state.userProfile.sbdVault[liftType].leaderboard = perfToPublish;
            state.userProfile.sbdVault[liftType].verified = null;
        });

        await saveState(); // Sauvegarde la nouvelle structure du coffre-fort
        showToast("Performance publiée avec succès !", "success");
        closeModal();
        navigate('Leaderboard');

    } catch (error) {
        console.error("Erreur lors de la publication de la performance :", error);
        showToast("Une erreur est survenue.", "error");
    }
}

// --- NOUVELLE FONCTION ---
// Gère les actions de la modale du coffre-fort
async function handleSbdVaultEvents(e) {
    const button = e.target.closest('button[data-action]');
    if (!button) return;

    const { action, liftType, status, videoUrl } = button.dataset;

    if (action === 'preview-pending-video') {
        showVideoPreviewModal(videoUrl);
        return;
    }
    
    if (action === 'select-vault-lift') {
        state.sbdVaultModal.activeLift = liftType; 
        document.querySelectorAll('.vault-lift-tab').forEach(tab => tab.classList.remove('active'));
        button.classList.add('active');
        document.getElementById('vault-slots-container').innerHTML = renderVaultSlots(liftType);
        return;
    }
    
    const perf = state.userProfile.sbdVault[liftType]?.[status];
    if (!perf) return;

    switch (action) {
        case 'delete-vault-perf':
            if (status === 'pending' || status === 'processing') {
                if (perf.validationId) await deletePendingPerformance(perf.validationId);
            }
            state.userProfile.sbdVault[liftType][status] = null;
            await saveState();
            showToast("Performance supprimée.", "info");
            // On rafraîchit juste le contenu de la modale
            document.getElementById('vault-slots-container').innerHTML = renderVaultSlots(liftType);
            break;
        
        case 'submit-vault-video':
            openSbdProofUploadModal(perf);
            break;

        case 'add-to-leaderboard':
            await publishPerformanceToLeaderboard(liftType);
            break;

        case 'remove-from-leaderboard':
            await removeFromLeaderboard(liftType);
            break;
    }
}

// --- NOUVELLE FONCTION ---
// Ouvre la modale pour envoyer une preuve vidéo depuis le coffre-fort
async function openSbdProofUploadModal(perf) {
    const liftType = { 'ex036': 'squat', 'ex001': 'bench', 'ex021': 'deadlift' }[perf.sourcePerf.exerciseId];
    if (!liftType) return;

    const vaultLift = state.userProfile.sbdVault[liftType];
    if (vaultLift.processing) {
        showToast("Une performance est déjà en cours de traitement pour ce mouvement.", "error");
        return;
    }
    if (vaultLift.pending) {
        showToast("Supprimez d'abord la performance en attente dans le Tribunal.", "error");
        return;
    }
    
    const liftLabel = {squat:'Squat', bench:'Bench', deadlift:'Deadlift'}[liftType];

    const modalContent = `
        <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col">
            <header class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold">Faire vérifier</h2>
                <button class="close-modal w-8 h-8 rounded-full bg-black/20 z-20">×</button>
            </header>
            <div id="sbd-submit-form" class="space-y-4">
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="font-semibold text-gray-400 text-sm">Mouvement</label>
                        <input type="text" class="input-glass mt-1 bg-black/30 text-gray-400" value="${liftLabel}" disabled>
                    </div>
                    <div>
                        <label class="font-semibold text-gray-400 text-sm">Poids à Valider</label>
                        <input type="text" class="input-glass mt-1 bg-black/30 text-gray-400" value="${perf.weight} kg" disabled>
                    </div>
                </div>
                <div>
                    <label class="font-semibold text-gray-400 text-sm">Preuve Vidéo</label>
                    <div class="mt-1 p-4 border-2 border-dashed border-gray-600 rounded-xl text-center cursor-pointer hover:border-violet-400" id="video-dropzone">
                        <i class="fa-solid fa-video text-3xl text-gray-500"></i>
                        <p id="video-file-label" class="text-sm text-gray-400 mt-2">Cliquez pour choisir votre preuve (<20s, <50MB)</p>
                    </div>
                    <input type="file" id="sbd-video-input" class="hidden" accept="video/*">
                </div>
            </div>
            <div id="upload-progress-container" class="text-center hidden">
                <p id="upload-progress-text" class="text-sm text-violet-300 font-semibold"></p>
                <div class="w-full bg-black/20 rounded-full h-2.5 mt-2">
                    <div id="upload-progress-bar" class="bg-violet-500 h-2.5 rounded-full transition-width duration-300" style="width: 0%"></div>
                </div>
            </div>
            <div class="flex gap-4 mt-6">
                <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
                <button id="confirm-sbd-submit-btn" class="w-full btn-primary" disabled>Soumettre au Tribunal</button>
            </div>
            <button id="cancel-upload-btn" class="w-full mt-2 glass-card p-3 rounded-lg font-bold hidden">Annuler l'envoi</button>
        </div>`;

    showModal(modalContent, (modalWrapper) => {
        let selectedFile = null;
        const confirmBtn = modalWrapper.querySelector('#confirm-sbd-submit-btn');
        const form = modalWrapper.querySelector('#sbd-submit-form');
        const closeBtn = modalWrapper.querySelector('.cancel');
        const cancelBtn = modalWrapper.querySelector('#cancel-upload-btn');
        const dropzone = modalWrapper.querySelector('#video-dropzone');
        const videoInput = modalWrapper.querySelector('#sbd-video-input');
        const videoLabel = modalWrapper.querySelector('#video-file-label');
        const progressContainer = modalWrapper.querySelector('#upload-progress-container');
        const progressText = modalWrapper.querySelector('#upload-progress-text');
        const progressBar = modalWrapper.querySelector('#upload-progress-bar');
        let uploadTask = null;

        const validateForm = () => { confirmBtn.disabled = !selectedFile; };

        const handleFile = (file) => {
            if (!file || !file.type.startsWith('video/')) {
                showToast("Veuillez sélectionner un fichier vidéo.", "error"); return;
            }
            if (file.size > 50 * 1024 * 1024) { // 50MB
                showToast("La vidéo est trop lourde (max 50MB).", "error"); return;
            }

            const video = document.createElement('video');
            video.preload = 'metadata';
            video.onloadedmetadata = function() {
                window.URL.revokeObjectURL(video.src);
                if (video.duration > 20) {
                    showToast("La vidéo doit faire moins de 20 secondes.", "error"); return;
                }
                if (video.videoWidth > video.videoHeight) {
                    showToast("La vidéo doit être au format vertical.", "error"); return;
                }
                selectedFile = file;
                videoLabel.textContent = file.name;
                videoLabel.classList.add('text-violet-300');
                validateForm();
            };
            video.src = URL.createObjectURL(file);
        };
        
        dropzone.addEventListener('click', () => videoInput.click());
        videoInput.addEventListener('change', (e) => { 
            if (e.target.files.length) handleFile(e.target.files[0]); 
        });
        dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('border-violet-400'); });
        dropzone.addEventListener('dragleave', () => dropzone.classList.remove('border-violet-400'));
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('border-violet-400');
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });

        confirmBtn.addEventListener('click', async () => {
    // Affiche la barre de progression et désactive les boutons
    confirmBtn.disabled = true;
    form.style.display = 'none';
    closeBtn.classList.add('hidden');
    confirmBtn.classList.add('hidden');
    progressContainer.classList.remove('hidden');
    cancelBtn.classList.remove('hidden');

    // Met à jour l'état local pour afficher "Envoi en cours..." dans le coffre-fort
    const liftType = perf.sourcePerf.exerciseId === 'ex036' ? 'squat' : (perf.sourcePerf.exerciseId === 'ex001' ? 'bench' : 'deadlift');
    state.userProfile.sbdVault[liftType].processing = { ...perf, status: 'uploading' };
    state.userProfile.sbdVault[liftType].pending_tribunal = null;
    await saveState();
    openSbdVaultModal(); // Rafraîchit le coffre-fort pour montrer l'état d'envoi

    let filePath = null; // Variable pour stocker le chemin du fichier pour la suppression en cas d'erreur

    try {
        // --- Étape 1 : Envoi de la vidéo ---
        const { task, promise } = uploadFile(selectedFile, (progress) => {
            progressText.textContent = `Envoi de la vidéo... ${progress.toFixed(0)}%`;
            progressBar.style.width = `${progress}%`;
        });
        uploadTask = task;
        const { downloadURL, filePath: returnedFilePath } = await promise; 
        filePath = returnedFilePath;

        // --- Étape 2 : Création des documents et attente du traitement ---
        progressText.textContent = 'Initialisation du traitement...';

        // Crée le document de validation en premier pour obtenir son ID
        const validationDocRef = await addDoc(collection(db, 'video_validations'), {
            sbdPerfId: perf.id,
            userId: currentUserId,
            videoUrl: downloadURL,
            videoPath: filePath,
            status: 'processing',
            judgements: []
        });
        
        // CORRECTION : Remplacer updateDoc par setDoc pour CRÉER le document
        const perfDocRef = doc(db, 'sbd_performances', perf.id);
        await setDoc(perfDocRef, {
            userId: currentUserId,
            liftType: liftType,
            weight: perf.weight,
            reps: 1, // Un 1RM est toujours 1 rep
            bodyweight: state.userGoals.bodyWeight,
            timestamp: perf.timestamp,
            status: 'pending_video',
            validationMethod: 'video',
            validationId: validationDocRef.id // On lie la validation qu'on vient de créer
        });

        progressText.textContent = 'Compression et traitement...';
        progressBar.classList.add('animate-pulse');
        cancelBtn.classList.add('hidden');

        // Mise en place de l'écouteur en temps réel
        const unsubscribe = onSnapshot(doc(db, "video_validations", validationDocRef.id), async (docSnapshot) => {
            if (docSnapshot.exists() && docSnapshot.data().status === 'pending') {
                unsubscribe();
                
                const videoData = docSnapshot.data();
                
                state.userProfile.sbdVault[liftType].pending = {
                    ...perf,
                    status: 'pending',
                    validationId: validationDocRef.id,
                    videoUrl: videoData.compressedVideoUrl || videoData.videoUrl,
                    judgements: videoData.judgements || []
                };
                state.userProfile.sbdVault[liftType].processing = null;

                await saveState();
                showToast("Vidéo soumise au Tribunal !", "success");
                
                closeModal();
            }
        });

    } catch (error) { 
        if (error.code !== 'storage/canceled') {
            showToast("Erreur lors de l'envoi.", "error");
            console.error("Erreur d'envoi SBD :", error);

            if (filePath) {
                try {
                    const storage = getStorage(app);
                    const fileRef = ref(storage, filePath);
                    await deleteObject(fileRef);
                    console.log("Fichier vidéo orphelin supprimé avec succès.");
                } catch (deleteError) {
                    console.error("Erreur lors de la suppression du fichier orphelin :", deleteError);
                }
            }
        }
        state.userProfile.sbdVault[liftType].processing = null;
        state.userProfile.sbdVault[liftType].pending_tribunal = perf;
        await saveState();
        closeModal();
    }
});

        cancelBtn.addEventListener('click', () => {
            if (uploadTask) uploadTask.cancel();
        });
    });
}

        // --- CORE APP LOGIC ---
        const pageContainer = document.getElementById('page-container');
        const navContainer = document.getElementById('bottom-nav-container');
        const modalContainer = document.getElementById('global-modal-container');

        function setState(newState) {
            Object.assign(state, newState);
            render();
        }

        function closeAllPopovers() {
    document.getElementById('friend-options-popover')?.remove();
}
        
        function navigate(page, params = {}) {
    const socialPages = ['Social', 'SearchUsers', 'Inbox'];
    const isLeavingSocialContext = socialPages.includes(state.activePage) && !socialPages.includes(page);
    const isEnteringSocialContext = !socialPages.includes(state.activePage) && socialPages.includes(page);

    if (isLeavingSocialContext) {
    stopClanMusic();
    if (clanListener) { // S'il y a un écouteur de clan actif, on le coupe
        clanListener();
        clanListener = null;
    }
}
if (gymListener) { // On fait de même pour le nouvel écouteur de salle
    gymListener();
    gymListener = null;
}
    if (isEnteringSocialContext && state.userProfile.clanId && state.currentClanData) {
        playClanMusic(state.currentClanData.clanMusic);
    }
    
    // Le reste de votre fonction navigate est identique
    if (state.activePage === 'Inbox') {
        markNotificationsAsReadAndDelete();
    }
    closeAllPopovers();
    if (state.activePage === 'Shop') {
        const shopContent = document.querySelector('.shop-content-scroll-area');
        if (shopContent) {
            state.shop.scrollPosition = shopContent.scrollTop;
        }
    }
    if (page === 'Onboarding') {
        state.tempUserProfile = { name: '', dob: '', sex: 'Sexe', country: 'Pays' };
    }
    if (page === 'Profil') {
        state.tempUserProfile = JSON.parse(JSON.stringify(state.userProfile));
    } else if (state.activePage === 'Profil' && page !== 'Profil') {
        state.tempUserProfile = null;
    }
    setState({ activePage: page, currentPageParams: params });
}

        // --- TEMPLATES & RENDERING ---
        function render() {
    // 1. Gère l'affichage de la barre de navigation
    const pagesWithoutNav = ['WorkoutEditor', 'MealEditor', 'WorkoutPlayer', 'WorkoutSummary', 'Tribunal', 'Onboarding', 'Login']; // ADD 'Tribunal' HERE
    navContainer.style.display = pagesWithoutNav.includes(state.activePage) ? 'none' : 'block';

    // 2. Met à jour le thème et l'état actif du conteneur principal
    const appContainer = document.getElementById('app-container');
    if (appContainer) {
        appContainer.classList.remove('workout-active', 'nutrition-active');
        appContainer.classList.add(state.activeSide === 'workout' ? 'workout-active' : 'nutrition-active');
        appContainer.classList.remove('workout-theme', 'nutrition-theme');
        appContainer.classList.add(`${state.activeSide}-theme`);
    }

    // 3. Met à jour l'état actif des boutons de la barre de navigation
    // NOTE : On redéfinit le HTML de la nav AVANT de l'utiliser
    navContainer.innerHTML = templates.BottomNav();
    const activePageId = state.activePage;
    const allNavButtons = navContainer.querySelectorAll('.bottom-nav-item');
    allNavButtons.forEach(btn => {
        const pageId = btn.dataset.navigate;
        btn.classList.remove('active');
        if (pageId === activePageId || (activePageId === 'Workouts' && pageId === 'Workouts') || (activePageId === 'Repas' && pageId === 'Repas') || (activePageId === 'Stats' && pageId === 'Stats') || (activePageId === 'Dashboard' && pageId === 'Dashboard') || (activePageId === 'Quêtes' && pageId === 'Quêtes') || (activePageId === 'Achievements' && pageId === 'Profil')) {
            btn.classList.add('active');
        }
    });

    // 4. Stocke la position de défilement pour la page "Shop"
    let currentScrollTop = 0;
    const scrollableElement = document.querySelector('.shop-content-scroll-area');
    if (state.activePage === 'Shop' && scrollableElement) {
        currentScrollTop = scrollableElement.scrollTop;
    }

    // 5. Rend le contenu de la page principale
    const template = templates[state.activePage] || templates.Accueil;
    pageContainer.innerHTML = template(state.currentPageParams);

    // 6. Restaure la position de défilement pour la page "Shop"
    if (state.activePage === 'Shop' && scrollableElement) {
        setTimeout(() => {
            const newScrollableElement = document.querySelector('.shop-content-scroll-area');
            if (newScrollableElement && currentScrollTop > 0) {
                newScrollableElement.scrollTop = currentScrollTop;
            }
        }, 10);
    }

    // 7. Gère les fonctions spécifiques aux pages
    if (state.activePage === 'Dashboard') {
        const stats = getNutritionDashboardStats(state.dashboard?.period || '30d');
        renderNutritionCharts(stats);
    }
    if (state.activePage === 'WorkoutPlayer' && state.activeWorkoutSession) {
        if (!sessionDurationTimer) {
            sessionDurationTimer = setInterval(() => {
                const timerEl = document.getElementById('session-duration-display');
                if (timerEl && state.activeWorkoutSession) {
                    timerEl.textContent = formatDuration(Date.now() - state.activeWorkoutSession.startTime);
                } else {
                    clearInterval(sessionDurationTimer);
                    sessionDurationTimer = null;
                }
            }, 1000);
        }
    } else {
        if (sessionDurationTimer) {
            clearInterval(sessionDurationTimer);
            sessionDurationTimer = null;
        }
    }
    if (state.activePage === 'WorkoutEditor') {
        setupWorkoutEditorDragAndDrop();
    }
    if (state.activePage === 'Dashboard') {
        renderProgressionChart();
    }
    if (state.activePage === 'WorkoutSummary') {
        launchConfetti();
    } else if (state.activePage === 'Calendrier') {
        setupCalendarDragAndDrop();
        applyRecurrenceToCalendar();
    }
    if (state.activePage === 'Inbox') {
                renderInboxMessages();
            }
    if (state.activePage === 'WorkoutEditor' && state.editingWorkout) {
        setupEditorDragAndDrop('exercise-list', state.editingWorkout.exercises);
    }
    if (state.activePage === 'MealEditor' && state.editingMeal) {
        setupEditorDragAndDrop('ingredient-list', state.editingMeal.ingredients);
    }
    if (state.activePage === 'Accueil' || state.activePage === 'Quêtes') {
        updateQuestBadge();
    }
    if (state.activePage === 'Social') {
        // On lance le rendu asynchrone du contenu de l'onglet
        setTimeout(() => renderSocialContent(), 0);
    }
    if (state.activePage === 'Leaderboard') {
    setTimeout(() => renderLeaderboardContent(state.leaderboard.activeTab), 0);
}
if (state.activePage === 'Tribunal') {
    setTimeout(() => loadNextJuryVideo(), 0);
}

    // 8. Ajoute les écouteurs d'événements
    addEventListeners();

    updateSocialNotificationBadge();
}

        function renderProgressionChart() {
            if (progressionChart) {
                progressionChart.destroy();
            }
            if (!state.selectedChartExerciseId) return;

            const canvas = document.getElementById('progression-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const chartData = getChartDataForExercise(state.selectedChartExerciseId);

            progressionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: '1RM Estimé (kg)',
                        data: chartData.data,
                        backgroundColor: 'rgba(167, 139, 250, 0.2)',
                        borderColor: 'rgba(167, 139, 250, 1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true,
                        pointBackgroundColor: 'rgba(167, 139, 250, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: false },
                        // === MODIFICATION ICI : On formate l'infobulle ===
                        tooltip: {
                            callbacks: {
                                label: (context) => formatVolume(context.raw)
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: false, 
                            // === MODIFICATION ICI : On formate les étiquettes de l'axe Y ===
                            ticks: { 
                                color: '#9CA3AF',
                                callback: (value) => formatVolume(value)
                            }, 
                            grid: { color: 'rgba(255,255,255,0.05)' } 
                        },
                        x: { ticks: { color: '#9CA3AF' }, grid: { display: false } }
                    }
                }
            });
        }

        function getDashboardStats() {
    const totalSessions = state.sessionHistory.length;
    let totalVolume = 0;
    let totalTimeMs = 0;
    let totalReps = 0;

    state.sessionHistory.forEach(session => {
        totalTimeMs += session.duration || 0;
        if (session.performance) {
            session.performance.forEach(perf => {
                // CORRECTION : On ignore les perfs rejetées
                if (perf.isRejected) return;

                const exercise = getExerciseById(perf.exerciseId);
                if (perf.sets) {
                        // On filtre les séries rejetées AVANT de faire le calcul
                        perf.sets.filter(s => !s.isRejected).forEach(set => {
                            let effectiveWeight = set.weight || 0;
                            if (exercise.bilateral) {
                                effectiveWeight *= 2;
                            }
                            totalVolume += effectiveWeight * (set.reps || 0);
                            totalReps += set.reps || 0;
                        });
                    }
            });
        }
    });

    return {
        totalSessions,
        totalVolume: formatVolume(totalVolume),
        totalTime: formatDuration(totalTimeMs),
        totalReps,
    };
}

function getFilteredNutritionData(period = '30d') {
    const now = new Date();
    const cutoffDate = new Date();

    switch (period) {
        case '7d':
            cutoffDate.setDate(now.getDate() - 7);
            break;
        case '30d':
            cutoffDate.setDate(now.getDate() - 30);
            break;
        case 'all':
            cutoffDate.setTime(0); // Début de l'époque Unix pour tout prendre
            break;
    }
    cutoffDate.setHours(0, 0, 0, 0);

    const periodEvents = state.calendarEvents.filter(e => {
        const eventDate = new Date(e.date);
        return e.type === 'meal' && e.validated && eventDate >= cutoffDate;
    });

    const mealIds = new Set(periodEvents.map(e => e.refId));
    const periodMeals = state.meals.filter(m => mealIds.has(m.id));

    return { periodEvents, periodMeals };
}

/**
 * Calcule toutes les statistiques nécessaires pour le tableau de bord nutrition.
 */
function getNutritionDashboardStats(period = '30d') {
    const { periodEvents, periodMeals } = getFilteredNutritionData(period);

    if (periodEvents.length === 0) {
        return {
            period,
            totalDays: 0, avgCalories: 0, avgProtein: 0, avgFitScore: 0,
            macros: { protein: 0, carbs: 0, fat: 0 },
            fitScoreTrend: { labels: [], data: [] },
            topIngredients: { protein: [], calories: [] },
            bestMeals: [], worstMeals: [], mealConsistency: 0,
            coachTip: "Commencez par planifier et valider des repas pour voir vos statistiques ici !"
        };
    }

    const dailyData = {};
    periodEvents.forEach(event => {
        const meal = periodMeals.find(m => m.id === event.refId);
        if (!meal) return;
        
        if (!dailyData[event.date]) {
            dailyData[event.date] = { calories: 0, protein: 0, carbs: 0, fat: 0, fitScoreSum: 0, mealCount: 0 };
        }
        dailyData[event.date].calories += meal.nutrition.calories || 0;
        dailyData[event.date].protein += meal.nutrition.protein || 0;
        dailyData[event.date].carbs += meal.nutrition.carbs || 0;
        dailyData[event.date].fat += meal.nutrition.fat || 0;
        if(meal.fitScore !== null) {
            dailyData[event.date].fitScoreSum += meal.fitScore;
            dailyData[event.date].mealCount++;
        }
    });

    const totalDays = Object.keys(dailyData).length;
    let totalCalories = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0, totalFitScore = 0, totalMealCount = 0;

    Object.values(dailyData).forEach(day => {
        totalCalories += day.calories;
        totalProtein += day.protein;
        totalCarbs += day.carbs;
        totalFat += day.fat;
        totalFitScore += day.fitScoreSum;
        totalMealCount += day.mealCount;
    });
    
    // Meal Consistency Calculation
    const firstDate = new Date(Object.keys(dailyData).sort()[0]);
    const today = new Date();
    const daysInPeriod = Math.round((today - firstDate) / (1000 * 60 * 60 * 24)) + 1;
    const mealConsistency = (totalDays / daysInPeriod) * 100;

    // FitScore Trend Calculation
    const sortedDates = Object.keys(dailyData).sort();
    const fitScoreTrend = {
        labels: sortedDates.map(d => new Date(d).toLocaleDateString('fr-FR', { month: 'short', day: 'numeric' })),
        data: sortedDates.map(d => {
            const day = dailyData[d];
            return day.mealCount > 0 ? (day.fitScoreSum / day.mealCount) : 0;
        })
    };
    
    // Top Ingredients Calculation
    const ingredientMap = {};
    periodMeals.forEach(meal => {
        meal.ingredients.forEach(ing => {
            if (!ingredientMap[ing.name]) {
                ingredientMap[ing.name] = { name: ing.name, protein: 0, calories: 0, count: 0 };
            }
            ingredientMap[ing.name].protein += ing.nutrition.protein || 0;
            ingredientMap[ing.name].calories += ing.nutrition.calories || 0;
            ingredientMap[ing.name].count++;
        });
    });
    const allIngredients = Object.values(ingredientMap);
    const topProteinIngredients = [...allIngredients].sort((a, b) => b.protein - a.protein).slice(0, 5);
    const topCalorieIngredients = [...allIngredients].sort((a, b) => b.calories - a.calories).slice(0, 5);

    // Best & Worst Meals
    const validScoreMeals = periodMeals.filter(m => m.fitScore !== null);
    const bestMeals = [...validScoreMeals].sort((a,b) => b.fitScore - a.fitScore).slice(0, 3);
    const worstMeals = [...validScoreMeals].sort((a,b) => a.fitScore - b.fitScore).slice(0, 3);
    
    const avgFitScore = totalMealCount > 0 ? totalFitScore / totalMealCount : 0;
    
    const coachTip = generateNutritionTip({
        avgProtein: totalProtein / totalDays,
        avgFitScore: avgFitScore,
        mealConsistency: mealConsistency,
        topProteinIngredients: topProteinIngredients
    });


    return {
        period,
        totalDays,
        totalCalories,
        avgCalories: totalCalories / totalDays,
        avgProtein: totalProtein / totalDays,
        avgFitScore: avgFitScore,
        macros: { protein: totalProtein, carbs: totalCarbs, fat: totalFat },
        fitScoreTrend,
        topIngredients: { protein: topProteinIngredients, calories: topCalorieIngredients },
        bestMeals,
        worstMeals,
        mealConsistency,
        coachTip
    };
}

/**
 * Génère un conseil dynamique basé sur les statistiques de l'utilisateur.
 */
function generateNutritionTip(stats) {
    if (stats.mealConsistency < 50) {
        return "La régularité est la clé. Essayez de valider vos repas chaque jour pour obtenir des statistiques plus précises !";
    }
    if (stats.avgProtein < state.userGoals.protein * 0.8) {
        const topProtein = stats.topProteinIngredients[0];
        if (topProtein) {
             return `Vous êtes proche de votre objectif de protéines ! Des aliments comme "${topProtein.name}" peuvent vous aider à l'atteindre.`;
        }
        return "Pensez à inclure une source de protéines à chaque repas pour atteindre plus facilement votre objectif quotidien.";
    }
    if (stats.avgFitScore < 50) {
        return "Votre FitScore moyen est un peu bas. Essayez d'intégrer plus d'aliments complets et moins transformés pour l'améliorer.";
    }
    if (stats.avgFitScore > 75) {
        return "Excellent FitScore moyen ! Votre alimentation semble très équilibrée. Continuez comme ça !";
    }
    return "Votre alimentation est sur la bonne voie. Continuez de suivre vos repas pour affiner vos habitudes !";
}


/**
 * Crée et affiche les graphiques du tableau de bord nutrition.
 */
function renderNutritionCharts(stats) {
    // Nettoyage des anciens graphiques pour éviter les superpositions
    if (window.macroChart) window.macroChart.destroy();
    if (window.fitScoreTrendChart) window.fitScoreTrendChart.destroy();

    // Graphique des Macros (Doughnut)
    const macroCtx = document.getElementById('macro-chart')?.getContext('2d');
    if (macroCtx) {
        const totalMacros = stats.macros.protein + stats.macros.carbs + stats.macros.fat;
        window.macroChart = new Chart(macroCtx, {
            type: 'doughnut',
            data: {
                labels: ['Protéines', 'Glucides', 'Lipides'],
                datasets: [{
                    data: [stats.macros.protein, stats.macros.carbs, stats.macros.fat],
                    backgroundColor: ['#60A5FA', '#8B5CF6', '#FBBF24'],
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '80%', // Anneau fin et moderne
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(context) {
                                let label = context.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed !== null && totalMacros > 0) {
                                    const percentage = (context.parsed / totalMacros * 100).toFixed(1);
                                    label += `${context.raw.toFixed(1)}g (${percentage}%)`;
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Graphique de tendance du FitScore (Line)
    const fitScoreCtx = document.getElementById('fitscore-trend-chart')?.getContext('2d');
    if (fitScoreCtx) {
        window.fitScoreTrendChart = new Chart(fitScoreCtx, {
            type: 'line',
            data: {
                labels: stats.fitScoreTrend.labels,
                datasets: [{
                    label: 'FitScore Moyen',
                    data: stats.fitScoreTrend.data,
                    backgroundColor: 'rgba(52, 211, 153, 0.2)', // Couleur de la zone de remplissage
                    borderColor: '#34D399', // Couleur de la ligne (utilisée pour les points au survol)
                    borderWidth: 0,         // Cache la ligne de bordure du dataset
                    pointRadius: 0,         // Cache les points sur le graphique par défaut
                    pointHoverRadius: 5,    // Fait apparaître les points au survol
                    tension: 0.3,
                    fill: true,
                    pointBackgroundColor: '#34D399'
                }]
            },
            options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: { legend: { display: false } },
                 scales: {
                    y: {
                        border: { display: false }, // Masque la ligne de l'axe Y
                        beginAtZero: false,
                        ticks: { color: '#9CA3AF' },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    },
                    x: {
                        border: { display: false }, // Masque la ligne de l'axe X
                        ticks: { color: '#9CA3AF' },
                        grid: { display: false }
                    }
                }
            }
        });
    }
}

        function filterSessionsByPeriod(period) {
            if (period === 'all') return state.sessionHistory;
            
            const now = new Date();
            const cutoffDate = new Date();

            if (period === '7d') cutoffDate.setDate(now.getDate() - 7);
            else if (period === '30d') cutoffDate.setDate(now.getDate() - 30);
            else if (period === '365d') cutoffDate.setFullYear(now.getFullYear() - 1);
            
            return state.sessionHistory.filter(s => new Date(s.date) >= cutoffDate);
        }

        function getVolumeDetails(period) {
    const sessions = filterSessionsByPeriod(period);
    
    const volumeByGroup = Object.keys(MUSCLE_GROUPS).reduce((acc, group) => {
        acc[group] = 0;
        return acc;
    }, {});

    sessions.forEach(session => {
        session.performance.forEach(perf => {
            // CORRECTION : On ignore les perfs rejetées
            if (perf.isRejected) return;

            const exo = getExerciseById(perf.exerciseId);
            // On calcule le volume total de l'exercice en tenant compte du bilatéral
            const exoVolume = perf.sets.filter(s => !s.isRejected).reduce((sum, set) => {
                let effectiveWeight = set.weight || 0;
                if (exo.bilateral) effectiveWeight *= 2;
                return sum + (effectiveWeight * (set.reps || 0));
            }, 0);
            
            if (exo && typeof exo.groups === 'object' && exo.groups !== null) {
                for (const [group, coefficient] of Object.entries(exo.groups)) {
                    if (volumeByGroup.hasOwnProperty(group)) {
                        volumeByGroup[group] += exoVolume * coefficient;
                    }
                }
            }
        });
    });
    return Object.entries(volumeByGroup).sort(([,a],[,b]) => b-a);
}

        function getTimeDetails(period) {
            const sessions = filterSessionsByPeriod(period);
            if (sessions.length === 0) return { total: '0s', avg: '0s', longest: '0s' };
            
            const totalMs = sessions.reduce((sum, s) => sum + s.duration, 0);
            const longestMs = Math.max(...sessions.map(s => s.duration));

            return {
                total: formatDuration(totalMs),
                avg: formatDuration(totalMs / sessions.length),
                longest: formatDuration(longestMs)
            };
        }

        function getSessionDetails(period) {
            const sessions = filterSessionsByPeriod(period);
            if (sessions.length === 0) return { total: 0, avgPerWeek: '0.0', mostFrequent: 'N/A' };

            let avgPerWeek;
            if (sessions.length < 2) {
                // Avec 1 seule séance, la fréquence est de 1 sur la plus petite période (1 semaine)
                avgPerWeek = 1;
            } else {
                // Trie pour trouver la première et dernière date de la période
                const sortedSessions = sessions.sort((a,b) => new Date(a.date) - new Date(b.date));
                const firstDate = new Date(sortedSessions[0].date);
                const lastDate = new Date(sortedSessions[sortedSessions.length - 1].date);
                // Calcule le nombre de jours entre la première et la dernière séance
                const daysInPeriod = Math.max(1, (lastDate - firstDate) / (1000 * 60 * 60 * 24));
                // Calcule la moyenne sur le nombre de semaines réelles d'activité
                avgPerWeek = sessions.length / (daysInPeriod / 7);
            }

            const workoutCounts = sessions.reduce((acc, session) => { /* ... (inchangé) ... */ });
            const mostFrequent = Object.keys(workoutCounts).reduce((a, b) => workoutCounts[a] > workoutCounts[b] ? a : b, 'N/A');

            return {
                total: sessions.length,
                avgPerWeek: avgPerWeek.toFixed(1),
                mostFrequent
            };
        }

function calculate1RM(set, exercise) {
    if (!set || !exercise) return { epley1RM: 0, brzycki1RM: 0, total1RM: 0 };
    
    // Si la série est de 1 répétition, le 1RM est simplement le poids soulevé.
    if (set.reps === 1) {
        const weight = set.weight || 0;
        return { epley1RM: weight, brzycki1RM: weight, total1RM: weight };
    }

    let weight = set.weight || 0;
    if (exercise.bilateral) {
        weight *= 2;
    }
    const reps = set.reps || 0;
    
    const epley1RM = reps > 1 ? weight * (1 + reps / 30) : weight;
    const brzycki1RM = reps > 1 ? weight / (1.0278 - 0.0278 * reps) : weight;
    
    const total1RM = Math.round(Math.max(epley1RM, brzycki1RM));
    return { epley1RM, brzycki1RM, total1RM };
}

function isPerformanceSetPlausible(set, exercise, userData) {
    // 1. On calcule le score de performance de la série que l'utilisateur vient de faire.
    const currentSetScore = calculatePerformanceScore({
        type: exercise.type,
        charge: set.weight,
        reps: set.reps,
        poidsDuCorps: userData.bodyweight,
        coefficient: exercise.coefficient,
        pdcPercent: exercise.pdcPercent
    });

    // 2. On récupère le score "cible" (niveau élite) pour CET exercice précis.
    const targetScore = exercise.targetScore;
    if (!targetScore || targetScore <= 0) {
        return true; // Si l'exercice n'a pas de cible, on ne peut pas le valider, on l'accepte.
    }

    // 3. On définit un multiplicateur de sécurité. 
    //    Une performance 3x supérieure au niveau élite est considérée comme impossible.
    //    Vous pouvez ajuster ce chiffre (ex: 2.5 ou 4) si vous le trouvez trop strict ou trop laxiste.
    const impossibilityMultiplier = 2;
    const impossibleScoreThreshold = targetScore * impossibilityMultiplier;

    // 4. On compare : le score de la série est-il inférieur ou égal au seuil d'impossibilité ?
    return currentSetScore <= impossibleScoreThreshold;
}

        function getChartDataForExercise(exerciseId) {
    const labels = [];
    const data = [];
    
    const exercise = getExerciseById(exerciseId); // On récupère les détails de l'exercice une seule fois

    const relevantSessions = state.sessionHistory
        .filter(session => session.performance.some(p => p.exerciseId === exerciseId))
        .sort((a,b) => new Date(a.date) - new Date(b.date));

    if (relevantSessions.length === 0) return { labels, data };

    const firstDate = new Date(relevantSessions[0].date);
    const lastDate = new Date(relevantSessions[relevantSessions.length - 1].date);
    const timeSpanDays = (lastDate - firstDate) / (1000 * 60 * 60 * 24);

    let dateFormatOptions = {};
    if (timeSpanDays < 90) { 
        dateFormatOptions = { day: 'numeric', month: 'short' };
    } else if (timeSpanDays < 730) {
        dateFormatOptions = { month: 'short', year: '2-digit' };
    } else {
        dateFormatOptions = { year: 'numeric' };
    }
    
    relevantSessions.forEach(session => {
        const perf = session.performance.find(p => p.exerciseId === exerciseId);
        if (perf && perf.bestSet) {
            const rmValues = calculate1RM(perf.bestSet, exercise);
            if(rmValues.total1RM > 0) {
                labels.push(new Date(session.date).toLocaleDateString('fr-FR', dateFormatOptions));
                
                // === CORRECTION APPLIQUÉE ICI ===
                let final1RM = rmValues.total1RM;
                if (exercise.bilateral) {
                    final1RM /= 2; // On divise par 2 pour n'afficher que le poids d'un haltère
                }
                data.push(final1RM.toFixed(1));
                // ================================
            }
        }
    });
    return { labels, data };
}

        function getAdvancedInsights() {
            if (state.sessionHistory.length < 3) return { bestDay: 'N/A', mostTrainedGroup: 'N/A' };

            const dayCounts = [0,0,0,0,0,0,0];
            const groupCounts = {};

            state.sessionHistory.forEach(session => {
                let day = new Date(session.date).getDay() -1;
                if (day === -1) day = 6;
                dayCounts[day]++;

                session.performance.forEach(perf => {
                    const exo = getExerciseById(perf.exerciseId);
                    if (exo && typeof exo.groups === 'object') {
                        // On parcourt les clés (pecs, dos, etc.) de l'objet `groups`
                        Object.keys(exo.groups).forEach(group => {
                            groupCounts[group] = (groupCounts[group] || 0) + 1;
                        });
                    }
                });
            });
            
            const dayNames = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
            const bestDayIndex = dayCounts.indexOf(Math.max(...dayCounts));
            const mostTrainedGroupKey = Object.keys(groupCounts).reduce((a, b) => groupCounts[a] > groupCounts[b] ? a : b, null);

            return {
                bestDay: dayNames[bestDayIndex],
                mostTrainedGroup: mostTrainedGroupKey ? MUSCLE_GROUPS[mostTrainedGroupKey] : 'N/A'
            }
        }

        function getWeeklyStats(weekOffset = 0) {
    const today = new Date();
    const dayOfWeek = today.getDay() === 0 ? 6 : today.getDay() - 1;
    const startDate = new Date(today);
    startDate.setDate(today.getDate() - dayOfWeek - (weekOffset * 7));
    startDate.setHours(0, 0, 0, 0);

    const endDate = new Date(startDate);
    endDate.setDate(startDate.getDate() + 7);

    const weeklySessions = state.sessionHistory.filter(session => {
        const sessionDate = new Date(session.date);
        return sessionDate >= startDate && sessionDate < endDate;
    });

    const sessionsCount = weeklySessions.length;
    const totalDurationMs = weeklySessions.reduce((sum, s) => sum + (s.duration || 0), 0);
    const totalHours = totalDurationMs / (1000 * 60 * 60);

    const totalVolume = weeklySessions.reduce((totalVol, session) => {
        const sessionVolume = session.performance.reduce((sessionVol, perf) => {
            // CORRECTION : On ignore les perfs rejetées
            if (perf.isRejected) return sessionVol;

            const exercise = getExerciseById(perf.exerciseId);
            const exerciseVolume = perf.sets.filter(s => !s.isRejected).reduce((vol, set) => {
                let effectiveWeight = set.weight || 0;
                if (exercise.bilateral) {
                    effectiveWeight *= 2;
                }
                return vol + (effectiveWeight * (set.reps || 0));
            }, 0);
            return sessionVol + exerciseVolume;
        }, 0);
        return totalVol + sessionVolume;
    }, 0);

    return {
        sessions: sessionsCount,
        hours: totalHours,
        volume: totalVolume,
    };
}

function renderCollectionList() {
    // ÉTAPE 1 : On filtre d'abord la base de données
    const filteredCollectibles = COLLECTIBLES_DATABASE.filter(item => {
        const isOwned = state.userProfile.inventory.collectibles.includes(item.id);
        // On garde l'objet s'il n'est PAS de rareté Créateur, OU s'il est de rareté Créateur ET que vous le possédez.
        return item.rarity !== 'Créateur' || isOwned;
    });

    // ÉTAPE 2 : On trie ensuite la liste filtrée
    const sortedCollectibles = [...filteredCollectibles].sort((a, b) => {
        const sortOrder = state.shop.collectiblesSortOrder || 'possession';
        const isOwnedA = state.userProfile.inventory.collectibles.includes(a.id);
        const isOwnedB = state.userProfile.inventory.collectibles.includes(b.id);
        
        if (sortOrder === 'possession') {
            if (isOwnedA && !isOwnedB) return -1;
            if (!isOwnedA && isOwnedB) return 1;
        }
        if (sortOrder === 'rarity_desc') {
            return RARITY_ORDER[b.rarity] - RARITY_ORDER[a.rarity] || a.name.localeCompare(b.name);
        }
        return RARITY_ORDER[a.rarity] - RARITY_ORDER[b.rarity] || a.name.localeCompare(b.name);
    });

    // Le reste de la fonction est inchangé
    return sortedCollectibles.map(item => {
        const isUnlocked = state.userProfile.inventory.collectibles.includes(item.id);
        return `
        <div class="glass-card p-3 rounded-xl flex items-center gap-4 transition-opacity ${isUnlocked ? 'opacity-100' : 'opacity-40'}" title="${item.name}">
            <div class="w-12 h-12 bg-black/20 rounded-full flex-shrink-0 flex items-center justify-center relative ${item.effect || ''}">
                <i class="fa-solid ${item.icon} text-2xl ${item.color} relative z-10"></i>
                ${!isUnlocked ? '<i class="fa-solid fa-lock text-xs text-gray-300 absolute bottom-1 right-1 bg-black/50 p-1 rounded-full z-20"></i>' : ''}
            </div>
            <div class="min-w-0">
                <p class="font-bold truncate ${'rarity-' + normalizeString(item.rarity) + '-text'}">${item.name}</p>
                <p class="text-sm text-gray-400">${item.rarity}</p>
            </div>
        </div>`
    }).join('');
}

        const templates = {
            Accueil: () => {
    const isWorkout = state.activeSide === 'workout';
    document.getElementById('app-container').classList.add(isWorkout ? 'workout-active' : 'nutrition-active');

    const totalClaimableAchievements = getClaimableRewardsCount();

    // ... (toute la logique de récupération de données reste la même) ...
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const nextWorkoutEvent = state.calendarEvents.find(event => event.type === 'workout' && new Date(event.date) >= today && !event.completed);
    let workoutTitle = 'Repos';
    let isTodayWorkout = !!nextWorkoutEvent && new Date(nextWorkoutEvent.date).toDateString() === new Date().toDateString();
    if (isTodayWorkout) {
        workoutTitle = nextWorkoutEvent.title;
    } else {
        const allTodayWorkouts = state.calendarEvents.filter(e => e.type === 'workout' && formatDateToYYYYMMDD(new Date(e.date)) === formatDateToYYYYMMDD(today));
        if (allTodayWorkouts.length > 0 && allTodayWorkouts.every(e => e.completed)) {
            workoutTitle = "Séances terminées !";
        }
    }
    const upcomingWorkouts = state.calendarEvents.filter(event => event.type === 'workout' && new Date(event.date) >= today && !event.completed).sort((a,b) => new Date(a.date) - new Date(b.date));
    const weeklyStats = getWeeklyStats();

    // --- LOGIQUE NUTRITION ---
    const todayStr = formatDateToYYYYMMDD(new Date());
    const todaysMealsEvents = state.calendarEvents.filter(e => e.type === 'meal' && e.date === todayStr);
    const validatedMealsEvents = todaysMealsEvents.filter(e => e.validated);
    const consumedMacros = validatedMealsEvents.reduce((acc, event) => {
        const meal = state.meals.find(m => m.id === event.refId);
        if (meal) {
            acc.calories += meal.nutrition.calories;
            acc.protein += meal.nutrition.protein;
        }
        return acc;
    }, { calories: 0, protein: 0 });
    const potentialMacros = todaysMealsEvents.reduce((acc, event) => {
         const meal = state.meals.find(m => m.id === event.refId);
        if (meal) {
            acc.calories += meal.nutrition.calories;
            acc.protein += meal.nutrition.protein;
        }
        return acc;
    }, { calories: 0, protein: 0 });

    const { leveling } = state.userProfile;
    const displayInfo = getDisplayLevelInfo(leveling.realLevel); 
    const levelColors = getLevelTierColors(leveling.realLevel);
    const xpPercentage = getExpPercentage();
    const xpGlowStyle = `width: ${xpPercentage}%; background-color: ${levelColors.color}; filter: drop-shadow(0 0 8px ${levelColors.color}); opacity: ${0.4 + (xpPercentage * 0.006)};`;
    const levelTextStyle = `background-color: ${levelColors.color}20; color: ${levelColors.color}; text-shadow: 0 0 ${displayInfo.displayLevel * 0.08}px ${levelColors.color};`;

    return `
    <div class="p-6 pb-28 h-full flex flex-col page-transition">
        
        <header class="pt-4 flex justify-between items-start flex-shrink-0">
            <div>
                <div class="flex items-center gap-3">
                    <h1 class="text-3xl font-bold tracking-tighter">FitFlow</h1>
                    <button id="open-guide-modal" class="text-gray-500 hover:text-white transition-colors">
                        <i class="fa-solid fa-circle-question text-2xl"></i>
                    </button>
                </div>
                <button id="open-level-details-btn" class="text-left">
                    <div class="flex items-center gap-3 mt-2 h-10">
                        ${leveling.isMaxedOut ? `<div class="flex items-center gap-3"><span class="font-bold text-lg px-2 py-1 rounded-md whitespace-nowrap max-level-animated-badge">Niv. MAX</span></div>` : `
                            <div class="flex items-center gap-4">
                                <div class="flex flex-col items-center relative">
                                    <span class="font-bold text-xs px-2 py-1 rounded-md whitespace-nowrap" style="${levelTextStyle}">Niv. ${displayInfo.displayLevel}</span>
                                    ${displayInfo.prestige > 0 ? `<div class="absolute -bottom-3 flex items-center gap-1">${Array.from({ length: displayInfo.prestige }, () => `<i class="fa-solid fa-star text-yellow-400 text-[10px]"></i>`).join('')}</div>` : ''}
                                </div>
                                <div class="translate-y-1">
                                    <div class="w-20 h-1.5 bg-black/20 rounded-full"><div class="h-full rounded-full" style="${xpGlowStyle}"></div></div>
                                    <div class="w-20 text-center -mt-1"><span class="text-[9px] text-gray-400 font-semibold tracking-tighter leading-none">${(() => { const exp = getExpValues(); return exp.isMax ? 'MAX' : `${formatXP(exp.current)} / ${formatXP(Math.ceil(exp.required))} XP`; })()}</span></div>
                                </div>
                            </div>
                        `}
                    </div>
                </button>
            </div>
            
            <div class="flex-grow flex justify-center pt-1">
                <button data-action="open-streak-info" data-type="${state.activeSide}" class="flex items-center gap-2 transition-transform hover:scale-110">
                    <i class="fa-solid fa-fire-flame-curved streak-flame-gradient"></i>
                    <span class="text-2xl font-bold">${state.activeSide === 'workout' ? state.streaks.workout.count : state.streaks.nutrition.count}</span>
                </button>
            </div>

            <div class="flex items-center gap-5 pt-1">
                <button data-navigate="Shop"><i class="fa-solid fa-store text-2xl text-gray-300"></i></button>
                <button id="open-quests-modal" class="relative">
                    <i class="fa-solid fa-scroll text-2xl text-gray-300"></i>
                    ${(() => { const claimableCount = getClaimableQuestsCount(); if (claimableCount > 0) { return `<span class="notification-badge">${claimableCount}</span>`; } return ''; })()}
                </button>
                
                <div class="relative">
                    <button data-navigate="Profil"><i class="fa-solid fa-user text-2xl text-gray-300"></i></button>
                    ${totalClaimableAchievements > 0 ? `<span class="notification-badge">${totalClaimableAchievements}</span>` : ''}
                </div>
            </div>
        </header>
        
        <div class="flex-grow flex flex-col justify-between mt-6 space-y-4">
            ${isWorkout ? `
                <div>
                    <p class="text-sm font-semibold text-gray-400 uppercase">SÉANCE DU JOUR</p>
                    ${(state.streaks.workout.lastChance) ? `<p class="text-xs text-yellow-400 font-semibold animate-pulse">Dernière chance pour la série !</p>` : ''}
                    <p class="text-4xl font-extrabold text-white leading-tight mt-1 truncate-ellipsis" title="${workoutTitle}">${truncateText(workoutTitle, 20)}</p>
                    <div class="text-left mt-2">
                        <button id="start-workout-btn" data-event-id="${nextWorkoutEvent?.id || ''}" class="text-violet-400 font-semibold text-lg group ${!isTodayWorkout ? 'opacity-30 cursor-not-allowed' : ''}">
                            Démarrer <i class="fa-solid fa-arrow-right ml-1 transform transition-transform group-hover:translate-x-1"></i>
                        </button>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-3">
                    <button data-action="open-stat-modal" data-stat-type="sessions" class="glass-card p-3 rounded-2xl text-center hover:bg-white/10 transition-colors">
                        <p class="text-lg font-bold whitespace-nowrap">${weeklyStats.sessions}</p><p class="text-xs text-gray-400">Séances/sem</p>
                    </button>
                    <button data-action="open-stat-modal" data-stat-type="volume" class="glass-card p-3 rounded-2xl text-center hover:bg-white/10 transition-colors">
                        <p class="text-lg font-bold whitespace-nowrap">${formatVolume(weeklyStats.volume)}</p><p class="text-xs text-gray-400">Volume/sem</p>
                    </button>
                    <button data-action="open-stat-modal" data-stat-type="hours" class="glass-card p-3 rounded-2xl text-center hover:bg-white/10 transition-colors">
                        <p class="text-lg font-bold whitespace-nowrap">${formatDuration(weeklyStats.hours * 3600000)}</p><p class="text-xs text-gray-400">Temps/sem</p>
                    </button>
                </div>
                <div class="glass-card p-6 rounded-3xl flex flex-col flex-grow min-h-0">
                    <div class="flex items-center gap-3 mb-4">
                        <h2 class="text-lg font-bold">Prochaines Séances</h2>
                        <button data-navigate="Calendrier" class="text-gray-400 hover:text-white transition-colors"><i class="fa-solid fa-calendar-days text-xl"></i></button>
                    </div>
                    <div class="space-y-5 overflow-y-auto scrollbar-hide flex-grow">
                        ${upcomingWorkouts.length > 0 ? upcomingWorkouts.slice(0, 4).map(event => { const eventDate = new Date(event.date + 'T00:00:00'); let dayString = eventDate.toLocaleDateString('fr-FR', { weekday: 'long' }); dayString = dayString.charAt(0).toUpperCase() + dayString.slice(1); return `<div class="${event.completed ? 'opacity-50' : ''}"><p class="text-xs text-gray-400 italic mb-1">${eventDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' })}</p><div class="flex items-center gap-4"><i class="fa-solid fa-dumbbell text-red-400 w-5 text-center"></i><p class="text-white font-semibold flex-grow truncate-ellipsis">${dayString} - ${event.title}</p>${event.completed ? '<i class="fa-solid fa-check text-green-400"></i>' : ''}</div></div>` }).join('') : `<div class="h-full flex items-center justify-start pt-4"><p class="text-sm text-gray-500">Aucun entraînement à venir.</p></div>`}
                    </div>
                    ${upcomingWorkouts.length > 4 ? `<button data-navigate="Calendrier" class="w-full text-center pt-4 mt-auto border-t border-white/10 text-sm font-semibold text-gray-400 hover:text-white flex-shrink-0">Afficher plus de séances</button>` : ''}
                </div>
            ` : `
                <div class="grid grid-cols-2 gap-4">
                    <div class="glass-card p-4 rounded-2xl"><p class="text-sm text-gray-400">Calories</p><p class="text-2xl font-bold ${consumedMacros.calories >= state.userGoals.calories ? 'text-green-400' : ''}">${consumedMacros.calories.toFixed(0)} <span class="text-lg text-gray-400">/ ${state.userGoals.calories}</span></p><p class="text-xs text-gray-500">Potentiel: ${potentialMacros.calories.toFixed(0)} kcal</p></div>
                    <div class="glass-card p-4 rounded-2xl"><p class="text-sm text-gray-400">Protéines</p><p class="text-2xl font-bold ${consumedMacros.protein >= state.userGoals.protein ? 'text-green-400' : ''}">${consumedMacros.protein.toFixed(1)} <span class="text-lg text-gray-400">/ ${state.userGoals.protein}g</span></p><p class="text-xs text-gray-500">Potentiel: ${potentialMacros.protein.toFixed(1)} g</p></div>
                </div>
                <div class="glass-card p-6 rounded-3xl flex flex-col flex-grow min-h-0">
                    <div class="flex justify-between items-center mb-4"><div class="flex items-center gap-3"><h2 class="text-lg font-bold">Repas du jour</h2><button data-navigate="Calendrier" class="text-gray-400 hover:text-white transition-colors"><i class="fa-solid fa-calendar-days text-xl"></i></button></div><button id="quick-add-food-btn" class="text-green-400 font-semibold text-sm group">Ajout Rapide <i class="fa-solid fa-plus ml-1"></i></button></div>
                    <div class="space-y-3 overflow-y-auto scrollbar-hide flex-grow">
                        ${todaysMealsEvents.length > 0 ? todaysMealsEvents.sort((a,b) => a.time.localeCompare(b.time)).map(event => `<div class="flex items-center gap-3"><input type="checkbox" id="meal-check-${event.id}" data-event-id="${event.id}" class="meal-checkbox h-5 w-5 rounded bg-transparent border-2 border-gray-500 text-green-500 focus:ring-0" ${event.validated ? 'checked' : ''}><label for="meal-check-${event.id}" class="text-white font-semibold ${event.validated ? 'line-through text-gray-500' : ''}">${event.title}</label></div>`).join('') : `<div class="h-full flex items-center justify-start pt-4"><p class="text-sm text-gray-500">Aucun repas planifié aujourd'hui.</p></div>`}
                    </div>
                </div>
            `}
        </div>
    </div>`;
},



Login: () => {
    // Ce template est affiché par défaut si l'utilisateur n'est pas connecté.
    return `
        <div class="p-6 h-full flex flex-col items-center justify-center text-center">
            <h1 class="text-4xl font-bold mb-4">Bienvenue sur FitFlow</h1>
            <p class="text-gray-400 mb-8">Votre compagnon pour la nutrition et l'entraînement.</p>
            <button id="google-login-btn" class="btn-primary flex items-center justify-center gap-2 px-6 py-3 rounded-lg mb-4">
                <i class="fa-brands fa-google"></i> Se connecter avec Google
            </button>
            <p class="text-sm text-gray-500">Ou connectez-vous avec votre email</p>
            <div class="space-y-4 mt-4 w-full max-w-xs">
                <input id="login-email" type="email" placeholder="Email" class="input-glass">
                <input id="login-password" type="password" placeholder="Mot de passe" class="input-glass">
            </div>
            <button id="email-login-btn" class="btn-primary w-full max-w-xs mt-4">Se connecter</button>
            <button id="register-btn" class="w-full max-w-xs text-gray-400 mt-4 hover:text-white transition-colors">Créer un compte</button>
            <p id="auth-error-message" class="standard-error-message mt-4"></p>
        </div>
    `;
},

Tribunal: () => {
    // On vérifie toujours si l'utilisateur est un juge
    if (!isUserAJudge(state.userProfile)) {
        return `<div class="p-6 text-center text-gray-500">Accès refusé.</div>`;
    }

    // NOUVELLE STRUCTURE : On crée l'en-tête et le conteneur une bonne fois pour toutes.
    return `
    <div class="h-full flex flex-col relative">
        <header class="flex-shrink-0 flex items-center justify-between p-6 pt-12 absolute top-0 left-0 right-0 z-30 bg-gradient-to-b from-black/60 via-black/30 to-transparent">
            <div class="w-24 flex justify-start">
                <button data-navigate="Leaderboard" class="text-white hover:text-gray-300 w-10 h-10 rounded-full bg-black/20 flex items-center justify-center">
                    <i class="fa-solid fa-arrow-left text-xl"></i>
                </button>
            </div>
            <h1 class="text-3xl font-bold text-white">Tribunal</h1>
            <div class="w-24 flex justify-end items-center gap-3">
            </div>
        </header>

        <div id="jury-card-container" class="h-full flex flex-col items-center justify-center relative">
            <p class="text-gray-500 z-10">Chargement...</p>
        </div>
    </div>
    `;
},

Onboarding: () => {
    // Ce template est affiché pour les nouveaux utilisateurs.
    return `
    <div class="p-6 h-full flex flex-col items-center text-center overflow-y-auto">
        <h1 class="text-3xl font-bold mb-4">Bienvenue sur FitFlow !</h1>
        <p class="text-gray-400 mb-8">Remplissez ces quelques informations pour commencer.</p>
        <div id="onboarding-form" class="space-y-4 w-full max-w-xs">
            <input id="onboarding-name" type="text" placeholder="Votre nom" class="input-glass">
            <input id="onboarding-dob" type="date" placeholder="Date de naissance" class="input-glass">
            
            <input id="onboarding-weight" type="number" placeholder="Poids corporel (kg)" class="input-glass">
            
            <div class="relative custom-select-container">
                <button id="onboarding-sex-select" class="custom-select-button">
                    <span>Sexe</span><i class="fa-solid fa-chevron-down text-gray-500"></i>
                </button>
                <div class="custom-select-options">
                    <div class="custom-select-option" data-value="Homme">Homme</div>
                    <div class="custom-select-option" data-value="Femme">Femme</div>
                </div>
            </div>
            <div class="relative custom-select-container">
                <button id="onboarding-country-select" class="custom-select-button">
                    <span>Pays</span><i class="fa-solid fa-chevron-down text-gray-500"></i>
                </button>
                <div class="custom-select-options max-h-40 overflow-y-auto">
                    ${COUNTRY_LIST.map(c => `<div class="custom-select-option flex items-center gap-3" data-value="${c.name}"><img src="https://flagcdn.com/${c.code}.svg" width="24" alt="${c.name}"><span>${c.name}</span></div>`).join('')}
                </div>
            </div>

            <p class="text-xs text-gray-500 pt-2">
                Toutes ces informations seront modifiables ultérieurement dans votre profil.
            </p>

        </div>
        <button id="complete-onboarding-btn" class="btn-primary w-full max-w-xs mt-8">Commencer !</button>
    </div>
`;
},
            
            Dashboard: () => {
                // On garde un état pour la période sélectionnée
                if (!state.dashboard) state.dashboard = { period: '30d' };
                const stats = getNutritionDashboardStats(state.dashboard.period);

                // Fonction pour rendre une liste d'ingrédients
                const renderIngredientList = (ingredients, unit) => {
                    if (ingredients.length === 0) return `<p class="text-sm text-gray-500 text-center italic">Pas de données.</p>`;
                    return ingredients.map(ing => `
                        <div class="flex justify-between items-center text-sm py-1">
                            <span class="truncate pr-2">${ing.name}</span>
                            <span class="font-bold text-gray-300 flex-shrink-0">${ing[unit].toFixed(0)} ${unit === 'protein' ? 'g' : 'kcal'}</span>
                        </div>
                    `).join('');
                };

                // Fonction pour rendre une liste de repas
                const renderMealList = (meals) => {
                    if (meals.length === 0) return `<p class="text-sm text-gray-500 text-center italic">Pas assez de données.</p>`;
                    return meals.map(meal => {
                        // On vérifie si le FitScore est un nombre avant de l'afficher.
                        const isScoreValid = typeof meal.fitScore === 'number';
                        const scoreDisplay = isScoreValid ? meal.fitScore.toFixed(0) : 'N/A';
                        const scoreColor = isScoreValid ? getFitScoreColor(meal.fitScore) : '#6B7280'; // Gris pour N/A

                        return `
                         <div class="flex justify-between items-center text-sm py-1">
                            <span class="truncate pr-2">${meal.name}</span>
                            <span class="font-bold" style="color: ${scoreColor}">${scoreDisplay}</span>
                        </div>
                        `;
                    }).join('');
                };

                return `
                <div class="p-6 pb-28 h-full flex flex-col">
                    <header class="flex justify-between items-center pt-2 mb-4">
                        <h1 class="text-3xl font-bold">Analyse Nutrition</h1>
                    </header>
                    
                    <div id="dashboard-period-filter" class="flex justify-between gap-2 mb-6 text-sm">
                        <button data-period="7d" class="flex-1 p-2 rounded-lg ${state.dashboard.period === '7d' ? 'btn-primary' : 'glass-card'}">7j</button>
                        <button data-period="30d" class="flex-1 p-2 rounded-lg ${state.dashboard.period === '30d' ? 'btn-primary' : 'glass-card'}">30j</button>
                        <button data-period="all" class="flex-1 p-2 rounded-lg ${state.dashboard.period === 'all' ? 'btn-primary' : 'glass-card'}">Total</button>
                    </div>

                    <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-5">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="stat-card text-center glass-card p-4 rounded-xl">
                                <p class="text-xs text-gray-400">Kcal / jour</p>
                                <p class="text-2xl font-bold">${stats.avgCalories.toFixed(0)}</p>
                            </div>
                            <div class="stat-card text-center glass-card p-4 rounded-xl">
                                <p class="text-xs text-gray-400">Protéines / jour</p>
                                <p class="text-2xl font-bold">${stats.avgProtein.toFixed(1)}g</p>
                            </div>
                            <div class="stat-card text-center glass-card p-4 rounded-xl">
                                <p class="text-xs text-gray-400">FitScore Moyen</p>
                                <p class="text-2xl font-bold" style="color: ${getFitScoreColor(stats.avgFitScore)}">${stats.avgFitScore.toFixed(0)}</p>
                            </div>
                            <div class="stat-card text-center glass-card p-4 rounded-xl">
                                <p class="text-xs text-gray-400">Consistance</p>
                                <p class="text-2xl font-bold">${stats.mealConsistency.toFixed(0)}%</p>
                            </div>
                        </div>

                        <div class="glass-card p-4 rounded-xl flex items-start gap-3">
                            <i class="fa-solid fa-lightbulb text-xl text-yellow-300 mt-1"></i>
                            <div>
                                <h4 class="font-bold text-sm text-yellow-300">Le conseil du coach</h4>
                                <p class="text-xs text-gray-300 leading-relaxed">${stats.coachTip}</p>
                            </div>
                        </div>

                        <div class="glass-card p-4 rounded-xl">
                            <h3 class="font-bold text-center mb-4">Répartition des Macros</h3>
                            
                            <div class="flex flex-col items-center">
                                
                                <div class="w-40 h-40 relative flex-shrink-0">
                                    <canvas id="macro-chart"></canvas>
                                    <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                                        <span class="text-2xl font-extrabold text-white">${stats.totalCalories > 0 ? stats.totalCalories.toFixed(0) : '0'}</span>
                                        <span class="text-xs font-semibold text-gray-400 -mt-1">Kcal</span>
                                    </div>
                                </div>

                                <div class="flex justify-around w-full mt-4">
                                    ${(() => {
                                        const totalCal = stats.totalCalories > 0 ? stats.totalCalories : 1;
                                        const macros = [
                                            { name: 'Protéines', value: stats.macros.protein, color: '#60A5FA', calPerGram: 4 },
                                            { name: 'Glucides', value: stats.macros.carbs, color: '#8B5CF6', calPerGram: 4 },
                                            { name: 'Lipides', value: stats.macros.fat, color: '#FBBF24', calPerGram: 9 }
                                        ];

                                        return macros.map(macro => {
                                            const percent = (macro.value * macro.calPerGram / totalCal * 100).toFixed(0);
                                            return `
                                            <div class="flex flex-col items-center text-center">
                                                <div class="flex items-center gap-1.5">
                                                    <span class="w-2.5 h-2.5 rounded-full" style="background-color: ${macro.color};"></span>
                                                    <span class="text-xs font-semibold text-gray-300">${macro.name}</span>
                                                </div>
                                                <p class="font-bold text-sm mt-1">${macro.value.toFixed(1)}g</p>
                                                <p class="text-xs text-gray-500">${percent}%</p>
                                            </div>
                                            `;
                                        }).join('');
                                    })()}
                                </div>
                            </div>
                        </div>
                        
                        <div class="glass-card p-4 rounded-xl">
                            <h3 class="font-bold text-center mb-4">Tendance du FitScore</h3>
                            <div class="h-40">
                                <canvas id="fitscore-trend-chart"></canvas>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 gap-4">
                            <div class="glass-card p-4 rounded-xl">
                                <h4 class="font-bold text-center text-sm mb-2">Top 5 Protéines</h4>
                                <div class="space-y-1">${renderIngredientList(stats.topIngredients.protein, 'protein')}</div>
                            </div>
                             <div class="glass-card p-4 rounded-xl">
                                <h4 class="font-bold text-center text-sm mb-2">Top 5 Calories</h4>
                                <div class="space-y-1">${renderIngredientList(stats.topIngredients.calories, 'calories')}</div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div class="glass-card p-4 rounded-xl">
                                <h4 class="font-bold text-center text-sm mb-2 text-green-400">🏆 Meilleurs Repas</h4>
                                <div class="space-y-1">${renderMealList(stats.bestMeals)}</div>
                            </div>
                             <div class="glass-card p-4 rounded-xl">
                                <h4 class="font-bold text-center text-sm mb-2 text-red-400">🤔 À Améliorer</h4>
                                <div class="space-y-1">${renderMealList(stats.worstMeals)}</div>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            },

Shop: () => {
    const tabs = [
        { id: 'box', name: 'Box Surprise' },
        { id: 'borders', name: 'Bordures' },
        { id: 'titles', name: 'Titres' }
    ];

    const sortLabels = {
        'possession': 'Par possession',
        'rarity_asc': 'Rareté croissante',
        'rarity_desc': 'Rareté décroissante'
    };

    const renderShopContent = () => {
        switch (state.shop.activeTab) {
            case 'box':
                const unlockedCount = state.userProfile.inventory.collectibles.length;
                return `
                    <div class="p-6 pt-8 flex flex-col items-center justify-start flex-grow">
                        <i class="fa-solid fa-box-open text-8xl animate-pulse" style="color: var(--theme-primary);"></i>
                        <h3 class="text-2xl font-bold mt-4">Box Surprise</h3>
                        <p class="text-gray-400 mt-2 mb-8 text-center max-w-xs">Contient un objet de collection aléatoire de rareté variable.</p>
                        <button id="buy-box-btn" class="btn-primary px-8 py-4 text-lg mb-12">
    Acheter pour 250 <i class="fa-solid fa-coins ml-2"></i>
</button>
                        <div class="w-full max-w-sm">
                            <div class="flex justify-between items-center mb-4">
                                <div>
                                    <h4 class="font-bold text-lg text-white">Collection</h4>
                                    <p class="text-sm text-gray-400 font-semibold">(${unlockedCount}/${COLLECTIBLES_DATABASE.length} débloqués)</p>
                                </div>
                                <div class="relative custom-select-container w-48">
            <button class="shop-sort-button custom-select-button !py-2 !text-sm" data-type="collectibles">
                <span>${sortLabels[state.shop.collectiblesSortOrder || 'possession']}</span>
                <i class="fa-solid fa-chevron-down text-gray-500"></i>
            </button>
            <div class="shop-sort-options custom-select-options">
                <div class="custom-select-option" data-type="collectibles" data-value="possession">${sortLabels['possession']}</div>
                <div class="custom-select-option" data-type="collectibles" data-value="rarity_asc">${sortLabels['rarity_asc']}</div>
                <div class="custom-select-option" data-type="collectibles" data-value="rarity_desc">${sortLabels['rarity_desc']}</div>
            </div>
        </div>
                            </div>
                            <div id="collection-list-container" class="flex flex-col space-y-3">${renderCollectionList()}</div>
                        </div>
                    </div>`;
            case 'borders':
                 const sortedBorders = [...BORDERS_DATABASE.filter(b => b.source !== 'achievement')].sort((a, b) => {
                    const sortOrder = state.shop.bordersSortOrder || 'possession';
                    const isOwnedA = state.userProfile.inventory.borders.includes(a.id);
                    const isOwnedB = state.userProfile.inventory.borders.includes(b.id);
                    if (sortOrder === 'possession') {
                        if (isOwnedA && !isOwnedB) return -1;
                        if (!isOwnedA && isOwnedB) return 1;
                    }
                    if (sortOrder === 'rarity_desc') {
                        return RARITY_ORDER[b.rarity] - RARITY_ORDER[a.rarity] || a.name.localeCompare(b.name);
                    }
                    return RARITY_ORDER[a.rarity] - RARITY_ORDER[b.rarity] || a.name.localeCompare(b.name);
                });

                return `
                    <div class="p-4">
                        <div class="relative custom-select-container w-full mb-4">
                            <button class="shop-sort-button custom-select-button" data-type="borders">
                                <span>${sortLabels[state.shop.bordersSortOrder || 'possession']}</span>
                                <i class="fa-solid fa-chevron-down text-gray-500"></i>
                            </button>
                            <div class="shop-sort-options custom-select-options">
                                <div class="custom-select-option" data-type="borders" data-value="possession">${sortLabels['possession']}</div>
                                <div class="custom-select-option" data-type="borders" data-value="rarity_asc">${sortLabels['rarity_asc']}</div>
                                <div class="custom-select-option" data-type="borders" data-value="rarity_desc">${sortLabels['rarity_desc']}</div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            ${sortedBorders.map(border => {
                                const isOwned = state.userProfile.inventory.borders.includes(border.id);
                                let buttonHtml = isOwned ? `<button class="w-full mt-3 glass-card text-sm py-2" disabled>Possédé</button>` : `<button data-item-id="${border.id}" class="buy-border-btn w-full mt-3 btn-primary text-sm py-2">${border.cost} <i class="fa-solid fa-coins"></i></button>`;
                                return `
                                <div class="glass-card p-3 rounded-xl text-center flex flex-col gap-1">
                                    <div class="w-20 h-20 rounded-full mx-auto mb-2 relative" style="${border.style}">
                                        <div class="w-full h-full rounded-full flex items-center justify-center" style="background-color: rgb(29, 31, 43);">
                                            <i class="fa-solid fa-user text-4xl text-gray-500"></i>
                                        </div>
                                    </div>
                                    <p class="font-bold flex-grow overflow-hidden whitespace-nowrap text-clip ${'rarity-' + normalizeString(border.rarity) + '-text'}" title="${border.name}">${border.name}</p>
                                    <p class="text-sm text-gray-400">${border.rarity}</p>
                                    ${buttonHtml}
                                </div>`;
                            }).join('')}
                        </div>
                    </div>`;
            case 'titles':
                const sortedTitles = [...TITLES_DATABASE.filter(t => t.source === 'shop')].sort((a, b) => {
                    const sortOrder = state.shop.titlesSortOrder || 'possession';
                    const isOwnedA = state.userProfile.inventory.titles.includes(a.id);
                    const isOwnedB = state.userProfile.inventory.titles.includes(b.id);
                    if (sortOrder === 'possession') {
                        if (isOwnedA && !isOwnedB) return -1;
                        if (!isOwnedA && isOwnedB) return 1;
                    }
                    if (sortOrder === 'rarity_desc') {
                        return RARITY_ORDER[b.rarity] - RARITY_ORDER[a.rarity] || a.name.localeCompare(b.name);
                    }
                    return RARITY_ORDER[a.rarity] - RARITY_ORDER[b.rarity] || a.name.localeCompare(b.name);
                });

                return `
                    <div class="p-4">
                        
                        <div class="relative custom-select-container w-full mb-4">
                            <button class="shop-sort-button custom-select-button" data-type="titles">
                                <span>${sortLabels[state.shop.titlesSortOrder || 'possession']}</span>
                                <i class="fa-solid fa-chevron-down text-gray-500"></i>
                            </button>
                            <div class="shop-sort-options custom-select-options">
                                <div class="custom-select-option" data-type="titles" data-value="possession">${sortLabels['possession']}</div>
                                <div class="custom-select-option" data-type="titles" data-value="rarity_asc">${sortLabels['rarity_asc']}</div>
                                <div class="custom-select-option" data-type="titles" data-value="rarity_desc">${sortLabels['rarity_desc']}</div>
                            </div>
                        </div>
                        <div class="space-y-3">
                            ${sortedTitles.map(title => {
                                const isOwned = state.userProfile.inventory.titles.includes(title.id);
                                let buttonHtml = isOwned ? `<button class="glass-card text-sm py-2 px-4" disabled>Possédé</button>` : `<button data-item-id="${title.id}" class="buy-title-btn btn-primary text-sm py-2 px-4">${title.cost} <i class="fa-solid fa-coins"></i></button>`;

                                // --- NOUVELLE LOGIQUE POUR LES TITRES SECRETS ---
                                let titleClass = '';
                                if (title.source === 'secret') {
                                    if (title.id === 't-gymbro-originel') titleClass = 'title-gymbro-originel';
                                    else if (title.id === 't-pompier-muscle' || title.id === 't-the-bench-monster') titleClass = 'title-pompier-muscle';
                                    else if (title.id === 't-createur-supreme') titleClass = 'title-createur-supreme';
                                    else titleClass = `rarity-${normalizeString(title.rarity)}-text`;
                                } else {
                                    titleClass = `rarity-${normalizeString(title.rarity)}-text`;
                                }
                                // --- FIN DE LA LOGIQUE ---

                                return `
                                <div class="glass-card p-4 rounded-xl flex items-center justify-between">
                                    <div>
                                        <p class="font-bold ${titleClass}">${title.name}</p>
                                        <p class="text-sm text-gray-400">${title.rarity}</p>
                                    </div>
                                    ${buttonHtml}
                                </div>`;
                            }).join('')}
                        </div>
                    </div>`;
            default: return `<div class="p-8 text-center text-gray-500">Onglet à venir</div>`;
        }
    };

    return `
    <div class="h-full flex flex-col">
        <header class="p-6 flex justify-between items-center flex-shrink-0">
    <button data-navigate="Accueil" class="text-gray-300 hover:text-white"><i class="fa-solid fa-arrow-left text-xl"></i></button>
    <h1 class="text-3xl font-bold flex items-center gap-3">
        Boutique
        <button id="open-rarity-info-btn" class="text-gray-400 hover:text-white transition-colors" title="Infos sur les raretés">
            <i class="fa-solid fa-circle-question text-xl"></i>
        </button>
    </h1>
    <div class="glass-card px-4 py-2 rounded-full font-bold text-yellow-300">
        ${state.userProfile.coins.toLocaleString('fr-FR')} <i class="fa-solid fa-coins ml-1"></i>
    </div>
</header>
        <nav class="flex justify-around border-b border-white/10 mx-6 flex-shrink-0">
            ${tabs.map(tab => `
                <button data-tab="${tab.id}" class="shop-tab-btn py-3 px-4 font-semibold ${state.shop.activeTab === tab.id ? 'active' : ''}">
                    ${tab.name}
                </button>
            `).join('')}
        </nav>
        <div class="flex-grow overflow-y-auto scrollbar-hide shop-content-scroll-area">
            ${renderShopContent()}
        </div>
    </div>
    `;
},

            Workouts: () => {
    const sortOrderLabels = {
        'alpha': 'Ordre Alphabétique', 'favorite': 'Favoris en premier',
        'exo_asc': 'Moins de blocs', 'exo_desc': 'Plus de blocs' // Texte mis à jour pour la clarté
    };
    // Tri en utilisant la nouvelle structure 'groups'
    const sortedWorkouts = [...state.workouts].sort((a, b) => {
        // On s'assure que 'groups' est un tableau, sinon on utilise 0 pour la longueur
        const aGroupsLength = a.groups?.length || 0;
        const bGroupsLength = b.groups?.length || 0;

        switch (state.workoutsSortOrder) {
            case 'favorite': return (b.isFavorite || 0) - (a.isFavorite || 0) || a.name.localeCompare(b.name);
            // MODIFIÉ : On utilise la longueur de 'groups'
            case 'exo_asc': return aGroupsLength - bGroupsLength || a.name.localeCompare(b.name);
            // MODIFIÉ : On utilise la longueur de 'groups'
            case 'exo_desc': return bGroupsLength - aGroupsLength || a.name.localeCompare(b.name);
            default: return a.name.localeCompare(b.name);
        }
    });

    return `
        <div class="p-6 pb-28">
            <header class="flex justify-between items-center pt-4 mb-4">
                <h1 class="text-3xl font-bold">Séances</h1>
                <button id="add-workout-btn" class="btn-primary rounded-full w-12 h-12 flex items-center justify-center shadow-lg">
                    <i class="fa-solid fa-plus text-xl"></i>
                </button>
            </header>
            <div class="relative custom-select-container mb-6">
                <button id="workout-sort-button" class="custom-select-button font-semibold text-base">
                    <span>${sortOrderLabels[state.workoutsSortOrder]}</span>
                    <i class="fa-solid fa-chevron-down text-gray-500"></i>
                </button>
                <div id="workout-sort-options" class="custom-select-options">
                    <div class="custom-select-option" data-value="alpha">${sortOrderLabels['alpha']}</div>
                    <div class="custom-select-option" data-value="favorite">${sortOrderLabels['favorite']}</div>
                    <div class="custom-select-option" data-value="exo_asc">${sortOrderLabels['exo_asc']}</div>
                    <div class="custom-select-option" data-value="exo_desc">${sortOrderLabels['exo_desc']}</div>
                </div>
            </div>
            ${sortedWorkouts.length > 0 ? `
                <div class="space-y-4">
                    ${sortedWorkouts.map(workout => `
                        <div class="glass-card p-4 rounded-2xl flex items-center gap-4">
                            <button class="toggle-favorite-btn text-2xl z-10" data-id="${workout.id}">
                                <i class="fa-solid fa-star transition-colors ${workout.isFavorite ? 'text-yellow-400' : 'text-gray-600 hover:text-gray-400'}"></i>
                            </button>
                            <div class="flex-grow min-w-0 cursor-pointer" data-navigate="WorkoutEditor" data-id="${workout.id}">
                                <h2 class="text-lg font-semibold truncate-ellipsis">${workout.name}</h2>
                                <p class="text-sm text-gray-400 mt-1">${workout.groups?.length || 0} blocs</p>
                                <div class="flex items-center gap-1.5 mt-1.5 flex-wrap min-h-6">
                                    ${(workout.tags && workout.tags.length > 0)
                                        ? workout.tags.map(tagId => {
                                            const tag = state.workoutTags.find(t => t.id === tagId);
                                            if (!tag) return '';
                                            return `<span class="text-xs font-semibold px-2 py-0.5 rounded-full" style="background-color:${tag.color}20; color:${tag.color};">${tag.name}</span>`
                                        }).join('')
                                        : '<span class="text-sm text-gray-500">-</span>'
                                    }
                                </div>
                            </div>
                            <button data-action="start-now" data-id="${workout.id}" class="btn-primary rounded-full w-11 h-11 flex-shrink-0 flex items-center justify-center">
                                <i class="fa-solid fa-play ml-0.5"></i>
                            </button>
                        </div>
                    `).join('')}
                </div>
            ` : `<div class="text-center py-16"><i class="fa-solid fa-folder-open text-5xl text-gray-600 mb-4"></i><p class="font-semibold text-lg">Aucune séance</p><p class="text-sm text-gray-500">Appuyez sur '+' pour en créer une.</p></div>`}
        </div>
    `;
},

            Repas: () => {
                const sortOrderLabels = {
                    'alpha': 'Ordre Alphabétique', 'favorite': 'Favoris en premier',
                    'cal_desc': 'Plus caloriques', 'cal_asc': 'Moins caloriques',
                    'prot_desc': 'Plus protéinés'
                };
                const sortedMeals = [...state.meals.filter(m => !m.isQuickAdd)].sort((a, b) => {
                    switch (state.mealsSortOrder) {
                        case 'favorite': return (b.isFavorite || 0) - (a.isFavorite || 0) || a.name.localeCompare(b.name);
                        case 'cal_desc': return b.nutrition.calories - a.nutrition.calories || a.name.localeCompare(b.name);
                        case 'cal_asc': return a.nutrition.calories - a.nutrition.calories || a.name.localeCompare(b.name);
                        case 'prot_desc': return b.nutrition.protein - a.nutrition.protein || a.name.localeCompare(b.name);
                        default: return a.name.localeCompare(b.name);
                    }
                });

                return `
                    <div class="p-6 pb-28">
                        
                        <header class="flex justify-between items-center pt-4 mb-4">
                            <h1 class="text-3xl font-bold">Repas</h1>
                            <div class="flex items-center gap-3">
                                <button data-action="open-goals-modal" class="glass-card rounded-full w-12 h-12 flex items-center justify-center text-gray-300 hover:text-white">
                                    <i class="fa-solid fa-pencil text-lg"></i>
                                </button>
                                <button id="add-meal-btn" class="btn-primary rounded-full w-12 h-12 flex items-center justify-center shadow-lg" style="background-color: var(--nutrition-primary);">
    <i class="fa-solid fa-plus text-xl"></i>
</button>
                            </div>
                        </header>
                        <div class="relative custom-select-container mb-6">
                            <button id="meal-sort-button" class="custom-select-button font-semibold text-base">
                                <span>${sortOrderLabels[state.mealsSortOrder]}</span>
                                <i class="fa-solid fa-chevron-down text-gray-500"></i>
                            </button>
                            <div id="meal-sort-options" class="custom-select-options">
                                <div class="custom-select-option" data-value="alpha">${sortOrderLabels['alpha']}</div>
                                <div class="custom-select-option" data-value="favorite">${sortOrderLabels['favorite']}</div>
                                <div class="custom-select-option" data-value="cal_desc">${sortOrderLabels['cal_desc']}</div>
                                <div class="custom-select-option" data-value="cal_asc">${sortOrderLabels['cal_asc']}</div>
                                <div class="custom-select-option" data-value="prot_desc">${sortOrderLabels['prot_desc']}</div>
                            </div>
                        </div>
                        ${sortedMeals.length > 0 ? `
                            <div class="space-y-4">
                                ${sortedMeals.map(meal => `
                                    <div class="glass-card p-4 rounded-2xl flex items-center gap-4">
                                        <div class="flex-shrink-0 text-center">
    ${meal.fitScore !== null ? `
        <p class="text-3xl font-bold" style="color: ${getFitScoreColor(meal.fitScore)};">${meal.fitScore.toFixed(0)}</p>
    ` : `
        <p class="text-3xl font-bold text-gray-500">N/A</p>
    `}
    <p class="text-xs font-semibold text-gray-500 -mt-1">FitScore</p>
</div>
                                        <button class="toggle-meal-favorite-btn text-2xl z-10" data-id="${meal.id}">
                                            <i class="fa-solid fa-star transition-colors ${meal.isFavorite ? 'text-yellow-400' : 'text-gray-600 hover:text-gray-400'}"></i>
                                        </button>
                                        <div class="flex-grow min-w-0 cursor-pointer" data-navigate="MealEditor" data-id="${meal.id}">
                                            <h2 class="text-lg font-semibold truncate-ellipsis">${meal.name}</h2>
                                            <p class="text-sm text-gray-400 mt-1">${(meal.nutrition.calories || 0).toFixed(0)} kcal | ${(meal.nutrition.protein || 0).toFixed(1)}g Prot.</p>
                                            <div class="flex items-center gap-1.5 mt-1.5 flex-wrap min-h-6">
                                                ${(meal.tags && meal.tags.length > 0)
                                                    ? meal.tags.map(tagId => {
                                                        const tag = state.mealTags.find(t => t.id === tagId);
                                                        if (!tag) return '';
                                                        return `<span class="text-xs font-semibold px-2 py-0.5 rounded-full" style="background-color:${tag.color}20; color:${tag.color};">${tag.name}</span>`
                                                    }).join('')
                                                    : '<span class="text-sm text-gray-500">-</span>'
                                                }
                                            </div>
                                        </div>
                                        <i class="fa-solid fa-chevron-right text-gray-500"></i>
                                    </div>
                                `).join('')}
                            </div>
                        ` : `<div class="text-center py-16"><i class="fa-solid fa-folder-open text-5xl text-gray-600 mb-4"></i><p class="font-semibold text-lg">Aucun repas</p><p class="text-sm text-gray-500">Appuyez sur '+' pour en créer un.</p></div>`}
                    </div>
                `;
            },

            WorkoutEditor: ({ id }) => {
    const workout = state.editingWorkout;
    if (!workout) return '<p class="p-6">Erreur</p>';

    const renderExerciseCard = (exercise, groupId, exerciseIndex, isMultiExerciseGroup) => {
        const exerciseInfo = getExerciseById(exercise.exerciseId);
        const totalSets = exercise.sets ? exercise.sets.length : 0;
        return `
        <div class="exercise-card-in-group glass-card rounded-xl flex items-center p-3 gap-2 draggable-exercise draggable" draggable="true" data-group-id="${groupId}" data-exercise-index="${exerciseIndex}">
            <i class="fa-solid fa-grip-vertical text-gray-600 handle cursor-grab text-lg pr-2"></i>
            <div class="flex-grow min-w-0">
                <p class="font-bold text-base truncate">${exerciseInfo.name}</p>
                <p class="text-xs text-gray-400 font-semibold">${totalSets} série${totalSets > 1 ? 's' : ''}</p>
            </div>
            <button data-action="open-exercise-editor" data-group-id="${groupId}" data-exercise-index="${exerciseIndex}" class="text-gray-400 hover:text-white w-9 h-9 rounded-full hover:bg-white/10 transition-colors"><i class="fa-solid fa-pencil text-sm"></i></button>
            <button data-action="remove-exercise-group" data-group-id="${groupId}" data-exercise-index="${exerciseIndex}" class="text-red-500 w-9 h-9 rounded-full hover:bg-red-500/20 transition-colors"><i class="fa-solid fa-trash-can text-sm"></i></button>
        </div>`;
    };

    const workoutGroupsHtml = (workout.groups || []).map((group, index) => {
        let groupHtml = `<div class="draggable-group draggable" draggable="true" data-group-id="${group.id}">`;
        
        if (group.type === 'single') {
            groupHtml += renderExerciseCard(group.exercises[0], group.id, 0, false);
        } else { // Superset
            groupHtml += `
            <div class="superset-container relative p-4 rounded-2xl border-2 border-dashed border-violet-800/80 space-y-3" data-group-id="${group.id}">
                <div class="flex items-center justify-between -mt-1 mb-1">
                    <div class="flex items-center gap-2"><i class="fa-solid fa-grip-vertical text-gray-600 handle cursor-grab text-lg"></i><span class="text-xs font-bold bg-[#1D1F2B] px-2 text-violet-400">SUPERSET</span></div>
                    <button data-action="unlink-group" data-group-id="${group.id}" class="text-violet-400 hover:text-white w-8 h-8 rounded-full" title="Délier"><i class="fa-solid fa-unlink"></i></button>
                </div>
                <div class="superset-exercises-list space-y-3">
                    ${group.exercises.map((ex, exIndex) => renderExerciseCard(ex, group.id, exIndex, true)).join('')}
                </div>
            </div>`;
        }
        groupHtml += `</div>`;

        const nextGroup = workout.groups[index + 1];
        const shouldShowLinker = (group.type === 'single' && nextGroup && nextGroup.type === 'single') || (group.type === 'single' && nextGroup && nextGroup.type === 'superset') || (group.type === 'superset' && nextGroup && nextGroup.type === 'single');

        if (shouldShowLinker) {
            groupHtml += `
            <div class="linker-container flex items-center my-2">
                <div class="flex-grow h-px bg-gray-700 border-t border-dashed border-gray-600"></div>
                <button data-action="link-groups" data-group1-id="${group.id}" data-group2-id="${nextGroup.id}" class="linker-button w-10 h-10 rounded-full bg-black/30 border border-gray-700 text-violet-400 hover:bg-violet-500 hover:text-black transition-all mx-4 flex-shrink-0" title="Lier en Superset">
                    <i class="fa-solid fa-link"></i>
                </button>
                <div class="flex-grow h-px bg-gray-700 border-t border-dashed border-gray-600"></div>
            </div>`;
        }
        return groupHtml;
    }).join('');

    return `
    <div id="editor-page" data-workout-id="${id}">
        <style>
            .draggable-group.drag-over { border-top: 3px solid var(--theme-primary); }
            .draggable-exercise.drag-over { margin-top: 8px; border-top: 3px solid var(--theme-light); padding-top: 8px; }
            .dragging { opacity: 0.5; background: rgba(var(--theme-primary), 0.1); }
            
            /* --- NOUVELLE ANIMATION SOBRE --- */
            @keyframes settle-in-anim {
                from {
                    opacity: 0;
                    transform: translateY(-8px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            .drop-settle {
                animation: settle-in-anim 0.4s cubic-bezier(0.2, 1, 0.2, 1);
            }
        </style>
        <header class="p-6 flex justify-between items-center sticky top-0 bg-[#1D1F2B]/80 backdrop-blur-md z-10 border-b border-white/10">
            <button data-action="cancel-workout" class="text-gray-300 hover:text-white"><i class="fa-solid fa-xmark text-2xl"></i></button>
            <h1 class="text-xl font-bold">Éditeur de Séance</h1>
            <button data-action="save-workout" class="btn-primary text-sm px-5 py-2">Sauvegarder</button>
        </header>
        <div class="p-6">
            <input id="workout-name-input" type="text" value="${workout.name}" class="text-4xl font-bold bg-transparent w-full focus:outline-none mb-6" />
            <div id="workout-editor-list" class="space-y-4 mb-8">${workoutGroupsHtml || `<div class="text-center py-16"><p class="font-semibold text-lg">Séance vide</p></div>`}</div>
            <button data-action="add-exercise" class="w-full glass-card hover:bg-white/10 p-4 rounded-xl flex items-center justify-center gap-3 font-semibold"><i class="fa-solid fa-plus"></i> Ajouter un exercice</button>
        </div>
    </div>`;
},

            WorkoutPlayer: ({ eventId }) => {
    if (!state.activeWorkoutSession) return `<div class="p-6">Erreur: Aucune séance active.</div>`;

    const { workout, currentExerciseIndex, isResting, restTime, startTime, sessionBestSets } = state.activeWorkoutSession;
    const elapsedSessionTime = formatDuration(Date.now() - startTime);
    const currentExercisePlan = workout.exercises[currentExerciseIndex];
    const exerciseDetails = getExerciseById(currentExercisePlan.exerciseId);
    const allTimeBest = state.exerciseStats[exerciseDetails.id]?.allTimeBest;
    const allTimeBestSet = allTimeBest?.bestSet;
    const sessionBest = sessionBestSets[exerciseDetails.id];
    const sessionBestSet = sessionBest ? { weight: sessionBest.weight, reps: sessionBest.reps } : null;

    let bestSetToShow = allTimeBestSet;
    if (sessionBestSet) {
        const params = { type: exerciseDetails.type, coefficient: exerciseDetails.coefficient, pdcPercent: exerciseDetails.pdcPercent };
        const allTimeScore = allTimeBestSet ? calculateAbsolutePerformance({ ...params, charge: allTimeBestSet.weight, reps: allTimeBestSet.reps }) : 0;
        const sessionScore = calculateAbsolutePerformance({ ...params, charge: sessionBestSet.weight, reps: sessionBestSet.reps });
        if (sessionScore > allTimeScore) bestSetToShow = sessionBestSet;
    }
    
    let prText = 'Aucun record';
    if (bestSetToShow) prText = `${bestSetToShow.weight} kg x ${bestSetToShow.reps} reps`;

    const rankPrScore = state.exerciseStats[exerciseDetails.id]?.rankPr?.score || 0;
    const sessionPrScore = sessionBestSets[exerciseDetails.id]?.score || 0;
    const scoreForRank = Math.max(rankPrScore, sessionPrScore);
    const rankInfo = getRankFromScore(scoreForRank, exerciseDetails.id);
    let inputLabel = exerciseDetails.type.includes('bodyweight') ? 'Lest (kg)' : 'Charge (kg)';

    return `
        <div class="p-6 h-full flex flex-col text-white bg-gradient-to-b from-[#23253A] to-[#1D1F2B] relative">
             <div class="absolute top-6 right-24 text-lg font-mono font-semibold bg-black/20 px-3 py-1 rounded-lg">
                <span id="session-duration-display">${elapsedSessionTime}</span>
             </div>
             <header class="flex justify-between items-center pt-4 mb-4 flex-shrink-0">
                <h1 class="text-2xl font-bold truncate-ellipsis">${workout.name}</h1>
                <div class="flex items-center gap-4">
                    <button id="view-session-recap" class="text-gray-300 hover:text-white"><i class="fa-solid fa-list-check text-xl"></i></button>
                    <button id="end-workout-btn" class="text-gray-300 hover:text-white"><i class="fa-solid fa-xmark text-2xl"></i></button>
                </div>
            </header>
            <div class="flex-grow flex flex-col items-center justify-center text-center">
                ${isResting ? `
                    <p class="text-2xl font-bold mb-2">Repos</p>
                    <p id="rest-timer-display" class="text-8xl font-thin tracking-tighter">${formatDuration(restTime * 1000)}</p>
                    <p class="text-lg text-gray-400 mt-4">Prochain: ${workout.exercises[currentExerciseIndex + 1] ? getExerciseById(workout.exercises[currentExerciseIndex + 1].exerciseId)?.name : 'Fin de la séance'}</p>
                    <div class="mt-8 flex gap-4"><button id="skip-rest-btn" class="bg-white/20 hover:bg-white/30 py-3 px-6 rounded-full font-bold">Passer</button></div>
                ` : `
                    <p class="text-lg text-gray-400">Exercice ${currentExerciseIndex + 1} / ${workout.exercises.length}</p>
                    <p class="text-3xl font-bold my-2 text-center">${exerciseDetails.name}</p>
                    <p class="text-lg font-semibold" style="color: ${rankInfo.color.main};">${rankInfo.name}</p>
                    <p class="text-2xl text-gray-300 my-4">Série ${state.activeWorkoutSession.currentSet} / ${currentExercisePlan.sets}</p>
                    <div class="w-full max-w-xs space-y-3 mb-6">
                        <div class="glass-card p-3 rounded-lg flex justify-between items-center text-sm">
                            <span>Meilleure Perf:</span><span class="font-bold">${prText}</span>
                        </div>
                    </div>
                    <div class="bg-white/5 p-6 rounded-2xl w-full max-w-xs">
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="reps-input" class="text-sm text-gray-400">Répétitions</label>
                                <input id="reps-input" type="text" inputmode="numeric" oninput="this.value = Math.max(1, parseInt(this.value) || 1);" class="input-glass text-center text-2xl font-bold mt-1" value="${currentExercisePlan.reps}">
                            </div>
                            <div>
                                <label for="weight-input" class="text-sm text-gray-400">${inputLabel}</label>
                                <div class="input-stepper-wrapper mt-1">
                                    <input id="weight-input" type="text" inputmode="decimal" onfocus="this.select()" class="input-glass text-center text-2xl font-bold pr-8" placeholder="0" oninput="this.value = this.value.replace(/[^0-9.]/g, '').replace(/(\\..*?)\\..*/g, '$1')">
                                    <div class="input-stepper-arrows">
                                        <button data-action="increment-weight"><i class="fa-solid fa-chevron-up text-xs"></i></button>
                                        <button data-action="decrement-weight"><i class="fa-solid fa-chevron-down text-xs"></i></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="humorous-message-container" class="standard-error-message hidden"></div>
                    </div>
                    <button id="finish-set-btn" class="mt-8 bg-green-500 hover:bg-green-400 py-4 w-full max-w-xs rounded-full font-bold text-xl">Série Terminée</button>
                `}
            </div>
        </div>
    `;
},

            Calendrier: () => {
                const displayDate = state.calendarDate;
                const month = displayDate.getMonth();
                const year = displayDate.getFullYear();
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const dayLabels = ['Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa', 'Di'];

                let daysHtml = '';
                const paddingDays = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1;
                for(let i=0; i < paddingDays; i++) { daysHtml += `<div></div>`; }

                const today = new Date();
                today.setHours(0,0,0,0);

                for(let day=1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    date.setHours(0,0,0,0);
                    const dateStr = formatDateToYYYYMMDD(date);
                    
                    // Affiche les événements en fonction du mode actif
                    const eventsOnDay = state.calendarEvents.filter(e => e.date === dateStr && e.type === state.activeSide);
                    
                    const isToday = date.getTime() === today.getTime();
                    const isPast = date < today;

                    daysHtml += `
                        <div class="calendar-day relative flex flex-col items-center justify-center p-1 rounded-lg transition-colors ${isPast ? 'past-day' : ''} ${eventsOnDay.length > 0 && !isPast ? 'cursor-pointer' : ''} ${isToday ? 'border-2 border-white/50' : 'border-t border-gray-700/50'}" data-date="${dateStr}">
        <span class="${isToday ? 'font-bold' : ''}" style="${isToday ? 'color: var(--theme-light);' : ''}">${day}</span>
        ${eventsOnDay.length > 0 ? `<span class="calendar-event-badge">${eventsOnDay.length}</span>` : ''}
    </div>`;
                }
                
                const monthYearString = displayDate.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' });
                const capitalizedMonthYear = monthYearString.charAt(0).toUpperCase() + monthYearString.slice(1);
                
                // Affiche les modèles de séances ou de repas en fonction du mode actif
                const plannerItems = state.activeSide === 'workout' 
                    ? state.workouts.map(w => ({...w, itemType: 'workout'}))
                    : state.meals.filter(m => !m.isQuickAdd).map(m => ({...m, itemType: 'meal'}));

                return `
                    <div class="p-6 h-full flex flex-col pb-28">
                        
                        <header class="pt-4 mb-4 flex justify-between items-center flex-shrink-0">
    <div class="flex items-center gap-3">
        <h1 class="text-3xl font-bold">Planifier</h1>
        <button id="open-recurrence-btn" class="text-gray-400 hover:text-white transition-colors" title="Créer une récurrence">
            <i class="fa-solid fa-repeat text-xl"></i>
        </button>
    </div>
</header>
                        
                        <div id="story-container-wrapper" class="h-32 flex-shrink-0 relative">
                             <div id="story-container" class="h-full flex items-center gap-3 overflow-x-auto scrollbar-hide pr-4" style="scroll-behavior: smooth;">
                                ${plannerItems.length > 0 ? plannerItems.map(item => {
                                    const icon = item.itemType === 'workout' ? 'fa-dumbbell' : 'fa-utensils';
                                    const tagId = item.tags && item.tags[0];
                                    const tagList = item.itemType === 'workout' ? state.workoutTags : state.mealTags;
                                    const tag = tagId ? tagList.find(t => t.id === tagId) : null;

                                    return `
                                    <div class="flex-shrink-0 w-48 glass-card p-3 rounded-xl flex items-center gap-3 draggable" draggable="true" data-item-id="${item.id}" data-item-type="${item.itemType}">
                                        <i class="fa-solid ${icon} text-2xl text-gray-400 w-8 text-center"></i>
                                        <div class="flex-grow min-w-0 h-10 flex flex-col justify-center">
                                            <p class="text-sm font-semibold truncate">${item.name}</p>
                                            ${tag ? 
                                                `<span class="text-xs font-bold px-2 py-0.5 rounded-full mt-1 inline-block" style="background-color:${tag.color}30; color:${tag.color};">${tag.name}</span>`
                                                : ''
                                            }
                                        </div>
                                    </div>
                                    `
                                }).join('') :  
                                `<div class="w-full text-center text-gray-500 text-sm flex items-center justify-center">
                                    <span>Aucun ${state.activeSide === 'workout' ? 'modèle de séance' : 'repas'} créé.</span>
                                </div>`
                                }
                            </div>
                            <button id="scroll-story-left-btn" class="absolute left-2 top-0 z-10 w-8 h-8 rounded-md flex items-center justify-center text-gray-400 hover:text-white transition-opacity opacity-0 pointer-events-none">
                                <i class="fa-solid fa-chevron-left"></i>
                            </button>
                            <button id="scroll-story-right-btn" class="absolute right-2 top-0 z-10 w-8 h-8 rounded-md flex items-center justify-center text-gray-400 hover:text-white transition-opacity opacity-0 pointer-events-none">
                                <i class="fa-solid fa-chevron-right"></i>
                            </button>
                        </div>
                        
                        <div class="flex-grow mt-2 flex flex-col">
                            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                                <button id="prev-month-btn" class="glass-card w-10 h-10 rounded-full"><i class="fa-solid fa-chevron-left"></i></button>
                                <h2 class="text-xl font-bold text-center">${capitalizedMonthYear}</h2>
                                <button id="next-month-btn" class="glass-card w-10 h-10 rounded-full"><i class="fa-solid fa-chevron-right"></i></button>
                            </div>
                            <div class="grid grid-cols-7 text-center text-xs text-gray-400 mb-2 flex-shrink-0">${dayLabels.map(d => `<div>${d}</div>`).join('')}</div>
                            <div id="calendar-grid" class="grid grid-cols-7 bg-black/10 rounded-lg p-2 flex-grow">${daysHtml}</div>
                        </div>
                    </div>
                `;
            },
            
            Stats: () => {
    const { globalRank, globalRankColor, totalSr } = calculateGlobalRank();
    return `
    <div class="p-6 pb-28">
        <header class="flex justify-between items-center pt-4 mb-6">
            <div class="flex items-center gap-3">
                <h1 class="text-3xl font-bold">Mes Rangs</h1>
                <button data-action="open-rank-info" class="text-gray-400 hover:text-white transition-colors">
                    <i class="fa-solid fa-circle-question text-2xl"></i>
                </button>
            </div>
            <div class="flex items-center gap-4">
                <button data-action="open-sbd-vault" class="text-gray-300 hover:text-white transition-colors" title="Coffre-fort SBD">
                    <i class="fa-solid fa-trophy text-2xl"></i>
                </button>
                <button data-action="open-dashboard-modal" class="text-gray-300 hover:text-white transition-colors" title="Statistiques Détaillées">
                    <i class="fa-solid fa-chart-line text-2xl"></i>
                </button>
            </div>
        </header>
        
        <div class="grid grid-cols-2 gap-4 mb-6">
             <button data-action="open-global-rank-details" class="glass-card p-4 rounded-2xl text-center hover:bg-white/10 transition-colors">
                <p class="text-sm font-semibold text-gray-400">Rank Global</p>
                <p class="text-2xl font-bold" style="color: ${globalRankColor.main};">
    ${globalRank} ${totalSr > 0 ? `<span class="text-yellow-300 text-xl">+${totalSr} SR</span>` : ''}
</p>
            </button>
            <div class="relative custom-select-container">
                <button id="custom-select-button" class="custom-select-button font-semibold text-base h-full !rounded-2xl">
                    <span id="custom-select-value">${state.sortOrderLabels[state.statsSortOrder]}</span>
                    <i class="fa-solid fa-chevron-down text-gray-500"></i>
                </button>
                <div id="custom-select-options" class="custom-select-options">
                    <div class="custom-select-option" data-value="rank_desc">${state.sortOrderLabels['rank_desc']}</div>
                    <div class="custom-select-option" data-value="rank_asc">${state.sortOrderLabels['rank_asc']}</div>
                    <div class="custom-select-option" data-value="alpha">${state.sortOrderLabels['alpha']}</div>
                </div>
            </div>
        </div>

        <div id="stats-list-container" class="space-y-3">
            ${renderStatsList()}
        </div>
    </div>
    `;
},

CreatorSpace: () => {
            const creatorName = state.userProfile.name;
            const drafts = state.creatorPrograms;

            return `
            <div class="p-6 pb-28 h-full flex flex-col">
                <header class="flex items-center justify-between pt-4 mb-6">
                    <h1 class="text-3xl font-bold">Espace Créateur</h1>
                    <button data-navigate="Profil" class="text-gray-300 hover:text-white" title="Retour au profil"><i class="fa-solid fa-user-circle text-2xl"></i></button>
                </header>
                
                <div class="glass-card p-4 rounded-2xl flex items-center gap-4">
                    ${renderAvatar(state.userProfile.profilePicUrl, 'w-12 h-12')}
                    <div>
                        <p class="font-bold text-lg">${creatorName}</p>
                        <p class="text-sm text-gray-400">Prêt à inspirer la communauté.</p>
                    </div>
                </div>

                <div class="flex justify-between items-center mt-8 mb-4">
                    <h2 class="text-xl font-bold">Mes Programmes</h2>
                    <button id="create-new-program-btn" class="btn-primary !py-2 !px-4 !text-sm"><i class="fa-solid fa-plus mr-2"></i>Nouveau</button>
                </div>

                <div id="creator-programs-list" class="flex-grow overflow-y-auto pr-2 space-y-3">
                    ${drafts.length > 0 ? drafts.map(program => `
                        <button data-action="edit-draft" data-program-id="${program.id}" class="w-full text-left glass-card p-4 rounded-xl hover:bg-white/10 transition-colors flex items-center gap-4">
                            <div class="w-16 h-16 rounded-lg bg-cover bg-center flex-shrink-0" style="background-color: ${program.themeColor}; ${program.bannerImageUrl ? `background-image: url(${program.bannerImageUrl})` : ''}">
                                ${!program.bannerImageUrl ? `<i class="fa-solid fa-pen-ruler text-3xl text-white/50 w-full h-full flex items-center justify-center"></i>` : ''}
                            </div>
                            <div class="min-w-0">
                                <p class="font-bold truncate">${program.title}</p>
                                <p class="text-xs font-semibold uppercase rounded-full px-2 py-0.5 inline-block mt-1 bg-yellow-400/20 text-yellow-300">Brouillon</p>
                            </div>
                            <i class="fa-solid fa-chevron-right text-gray-500 ml-auto"></i>
                        </button>
                    `).join('') : `
                        <div class="text-center text-gray-500 pt-16">
                            <i class="fa-solid fa-folder-open text-5xl mb-4"></i>
                            <p>Aucun programme créé pour le moment.</p>
                        </div>
                    `}
                </div>
            </div>
            `;
        },

        renderProgramStudioStructureTab: () => {
    const program = state.editingProgram;
    if (!program || !program.content) return '';

    return `
    <div id="studio-canvas" class="p-4 md:p-6 space-y-6">
        ${program.content.map(phase => `
            <div class="phase-block" data-phase-id="${phase.id}">
                <div class="phase-header flex justify-between items-center mb-4">
                    <input type="text" data-phase-id="${phase.id}" data-action="edit-phase-title" value="${phase.title}" class="text-2xl font-bold bg-transparent focus:outline-none w-full -ml-2 px-2 py-1 rounded-lg hover:bg-white/5 focus:bg-white/10">
                    <button data-action="delete-phase" data-phase-id="${phase.id}" class="text-gray-500 hover:text-red-400 w-9 h-9 rounded-full hover:bg-red-500/10 transition-colors"><i class="fa-solid fa-trash-can"></i></button>
                </div>
                
                <div class="weeks-container space-y-5">
                    ${phase.weeks.map(week => `
                        <div class="week-block" data-week-id="${week.id}">
                            <div class="flex justify-between items-center mb-3">
                                <input type="text" data-field="week-title" data-week-id="${week.id}" value="${week.title}" class="font-semibold text-violet-300 bg-transparent focus:outline-none w-full -ml-2 px-2 rounded-lg hover:bg-white/5 focus:bg-white/10">
                                <button data-action="delete-week" data-week-id="${week.id}" class="text-gray-600 hover:text-red-400 w-8 h-8 rounded-full hover:bg-red-500/10 transition-colors"><i class="fa-solid fa-trash-can text-sm"></i></button>
                            </div>
                            
                            <div class="days-grid">
                                ${week.days.map((day, dayIndex) => `
                                    <button data-action="edit-day" data-day-id="${day.id}" class="day-card relative">
                                        <span class="day-title">${day.title}</span>
                                        <div class="blocks-preview text-xs text-gray-400">${day.blocks.length} bloc(s)</div>
                                        <div class="day-card-delete-btn" data-action="delete-day" data-day-id="${day.id}" data-week-id="${week.id}">
                                            <i class="fa-solid fa-times"></i>
                                        </div>
                                    </button>
                                `).join('')}
                                
                                <button data-action="add-day-to-week" data-week-id="${week.id}" class="w-full h-full border-2 border-dashed border-gray-700 text-gray-600 rounded-lg hover:border-violet-500 hover:text-violet-500 transition-colors flex items-center justify-center">
                                    <i class="fa-solid fa-plus text-2xl"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}

                    <button data-action="add-week-to-phase" data-phase-id="${phase.id}" class="w-full text-center p-3 mt-2 rounded-lg border-2 border-dashed border-gray-700 text-gray-500 hover:border-violet-500 hover:text-violet-400 font-semibold transition-colors">
                        + Ajouter une Semaine
                    </button>
                </div>
            </div>
        `).join('')}
        
        <button data-action="add-phase" class="w-full p-4 rounded-xl border-2 border-dashed border-gray-700 text-gray-500 hover:border-violet-500 hover:text-violet-400 font-bold transition-colors">
            + Ajouter une Phase
        </button>
    </div>
    `;
},

        renderProgramStudioInfoTab: function() {
        const program = state.editingProgram;
        return `
        <div class="p-6 space-y-6 animate-fadeIn">
            <div class="glass-card p-4 rounded-xl">
                <label class="font-semibold text-gray-400">Titre du Programme</label>
                <input data-field="title" type="text" class="input-glass mt-1 text-xl" value="${program.title || ''}" placeholder="Ex: Prise de Masse Ultime">
            </div>
            <div class="glass-card p-4 rounded-xl">
                <label class="font-semibold text-gray-400">Description</label>
                <textarea data-field="description" class="input-glass mt-1 h-32 resize-none" placeholder="Décrivez votre programme...">${program.description || ''}</textarea>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div class="glass-card p-4 rounded-xl">
                    <label class="font-semibold text-gray-400">Prix (pièces)</label>
                    <input data-field="price" type="number" class="input-glass mt-1" value="${program.price || 0}">
                </div>
                <div class="glass-card p-4 rounded-xl">
                    <label class="font-semibold text-gray-400">Couleur thème</label>
                    <input data-field="themeColor" type="color" class="w-full h-12 mt-1 bg-transparent p-1 rounded-lg" value="${program.themeColor || '#A78BFA'}">
                </div>
            </div>
            <div class="glass-card p-4 rounded-xl">
                <label class="font-semibold text-gray-400">Bannière (URL)</label>
                <input data-field="bannerImageUrl" type="text" class="input-glass mt-1" value="${program.bannerImageUrl || ''}" placeholder="https://exemple.com/image.png">
            </div>
        </div>
        `;
    },

            // Remplacez la fonction templates.Profil
// Remplacez la fonction templates.Profil
Profil: () => {
    const profile = state.tempUserProfile || state.userProfile;
    const equipped = profile.equipped;
    
    const totalClaimable = getClaimableRewardsCount();

    const country = COUNTRY_LIST.find(c => c.name === profile.country) || { name: 'Sélectionner', code: '' };
    const equippedTitle = TITLES_DATABASE.find(t => t.id === equipped.title) || { name: 'Aucun titre', rarity: 'Commun' };
    const equippedBorder = BORDERS_DATABASE.find(b => b.id === equipped.border) || { style: '' };

    let titleClass = '';
    if (equippedTitle.source === 'secret') {
        if (equippedTitle.id === 't-gymbro-originel') {
            titleClass = 'title-gymbro-originel';
        } else if (equippedTitle.id === 't-pompier-muscle' || equippedTitle.id === 't-the-bench-monster') {
            titleClass = 'title-pompier-muscle';
        } else if (equippedTitle.id === 't-createur-supreme') {
            titleClass = 'title-createur-supreme';
        } else {
            titleClass = `rarity-${normalizeString(equippedTitle.rarity)}-text`;
        }
    } else {
        titleClass = `rarity-${normalizeString(equippedTitle.rarity)}-text`;
    }

    return `
    <div class="p-6 pb-28">
        
        <header class="flex justify-between items-center pt-2 mb-6">
            <div class="flex items-center gap-4">
                <button data-action="cancel-profile-edit" class="text-gray-300 hover:text-white"><i class="fa-solid fa-arrow-left text-xl"></i></button>
                <h1 class="text-3xl font-bold">Mon Profil</h1>
                
                <button data-navigate="Achievements" class="relative text-gray-300 transition-colors">
                    <i class="fa-solid fa-trophy text-2xl text-yellow-400"></i>
                    ${totalClaimable > 0 ? `<span class="notification-badge">${totalClaimable}</span>` : ''}
                </button>
            </div>
            <button id="save-profile-btn" class="btn-primary !px-5 !py-2 !text-sm">Sauvegarder</button>
        </header>
        
        <div class="flex gap-4 mb-4 items-center">
            <div class="w-1/3 flex flex-col items-center text-center">
                <div class="relative w-24 h-24">
                    <div class="w-full h-full rounded-full" style="${equippedBorder.style}">
                        <div class="w-full h-full rounded-full flex items-center justify-center" style="background-color: rgb(29, 31, 43);">
                            <div id="profile-pic-container" class="w-full h-full rounded-full bg-black/20 flex items-center justify-center relative group cursor-pointer" style="background-image: url(${profile.profilePicUrl || ''}); background-size: cover; background-position: center;">
                                ${!profile.profilePicUrl ? '<i class="fa-solid fa-user text-4xl text-gray-500"></i>' : ''}
                                <div class="absolute inset-0 bg-black/60 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                    <i class="fa-solid fa-camera text-xl text-white"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button id="change-border-btn" class="absolute bottom-0 -right-1 w-8 h-8 bg-gray-800 border-2 border-gray-900 rounded-full flex items-center justify-center text-white hover:bg-violet-500 transition-colors">
                        <i class="fa-solid fa-border-all text-sm"></i>
                    </button>
                    ${profile.profilePicUrl ? `
                        <button id="remove-profile-pic-btn" class="absolute top-0 -right-1 w-8 h-8 bg-red-600 border-2 border-gray-900 rounded-full flex items-center justify-center text-white hover:bg-red-500 transition-colors">
                            <i class="fa-solid fa-trash-can text-sm"></i>
                        </button>
                    ` : ''}
                </div>
                <div class="mt-3 text-center">
                    <p class="text-sm text-gray-500 italic">#0000</p>
                </div>
                <input type="file" id="profile-pic-input" class="hidden" accept="image/*">
            </div>

            <div class="w-7/12 showcase-container ml-2">
                <div class="showcase-title-wrapper -mt-2 mb-4">
                    <p class="font-bold text-xl truncate ${titleClass}" title="${equippedTitle.name}">
                        ${equippedTitle.name}
                    </p>
                    <button id="equip-title-btn" class="text-gray-400 hover:text-white" title="Changer le titre">
                        <i class="fa-solid fa-pencil text-sm"></i>
                    </button>
                </div>
                <div class="grid grid-cols-3 gap-3 px-1">
                    ${equipped.showcase.map((itemId, index) => {
                        const item = COLLECTIBLES_DATABASE.find(c => c.id === itemId);
                        const rarityBorderClass = item ? `rarity-${normalizeString(item.rarity)}-border` : '';
                        
                        return `
                        <button data-action="equip-showcase" data-slot-index="${index}" class="showcase-item flex items-center justify-center ${rarityBorderClass}">
                            ${item ? 
                                `<i class="fa-solid ${item.icon} text-3xl ${item.color} relative z-20"></i>` 
                                : 
                                '<i class="fa-solid fa-plus text-2xl text-gray-600"></i>'
                            }
                        </button>
                        `;
                    }).join('')}
                </div>
            </div>
        </div>
        
        <div>
            <div id="info-card" class="glass-card p-5 rounded-2xl mb-5">
                <h2 class="text-lg font-bold mb-4">Informations</h2>
                <div class="space-y-4">
                    <div>
                        <label for="profile-name" class="text-sm font-semibold text-gray-400">Nom d'utilisateur</label>
                        <input id="profile-name" type="text" class="input-glass mt-1" value="${profile.name || ''}" placeholder="Votre nom" maxlength="25">
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="profile-dob" class="text-sm font-semibold text-gray-400">Naissance</label>
                            <input id="profile-dob" type="date" class="input-glass mt-1" value="${profile.dob || ''}">
                        </div>
                        <div id="sex-select-wrapper">
                            <label for="sex-select-button" class="text-sm font-semibold text-gray-400">Sexe</label>
                            <div class="relative custom-select-container mt-1">
                                <button id="sex-select-button" class="custom-select-button">
                                    <span>${profile.sex}</span>
                                    <i class="fa-solid fa-chevron-down text-gray-500"></i>
                                </button>
                                <div id="sex-select-options" class="custom-select-options">
                                    <div class="custom-select-option" data-value="Homme">Homme</div>
                                    <div class="custom-select-option" data-value="Femme">Femme</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="country-select-wrapper">
                        <label for="country-select-button" class="text-sm font-semibold text-gray-400">Pays</label>
                        <div class="relative custom-select-container mt-1">
                            <button id="country-select-button" class="custom-select-button">
                                <span class="flex items-center gap-3">
                                    ${country.code ? `<img src="https://flagcdn.com/${country.code}.svg" width="24" alt="${country.name}">` : '🏳️'}
                                    <span>${country.name}</span>
                                </span>
                                <i class="fa-solid fa-chevron-down text-gray-500"></i>
                            </button>
                            <div id="country-select-options" class="custom-select-options max-h-60 overflow-y-auto scrollbar-hide">
                                ${COUNTRY_LIST.map(c => `<div class="custom-select-option flex items-center gap-3" data-value="${c.name}"><img src="https://flagcdn.com/${c.code}.svg" width="24" alt="${c.name}"><span>${c.name}</span></div>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="glass-card p-5 rounded-2xl" style="background: var(--theme-gradient);">
                <div class="flex justify-between items-center">
                    <label for="goal-bodyweight" class="text-lg font-bold">Poids Corporel (kg)</label>
                    <button id="weight-info-btn" class="text-gray-500 hover:text-violet-400 transition-colors">
                        <i class="fa-solid fa-circle-question text-xl"></i>
                    </button>
                </div>
                <input id="goal-bodyweight" type="number" step="0.01" min="1" max="999.99" class="input-glass text-2xl font-bold text-center mt-2 h-14" value="${state.userGoals.bodyWeight || ''}" placeholder="Ex: 75">
                
                <div id="weight-error-message" class="profile-weight-error-message"></div>
            </div>
        </div>

        <div class="mt-6 text-center">
            ${
                profile.isCreator
                ? `<button data-navigate="CreatorSpace" class="secondary-btn w-full max-w-xs">
                        <i class="fa-solid fa-store mr-2"></i> Accéder à mon espace
                   </button>`
                : `<button id="become-creator-btn" class="secondary-btn w-full max-w-xs">
                        <i class="fa-solid fa-rocket mr-2"></i> Devenir un Vendeur
                   </button>`
            }
        </div>
        
    </div>
    `;
},

ProgramStudio: function() { 
    if (!state.editingProgram) return `...`;
    
    const tabs = ['info', 'structure', 'publish'];
    const activeTab = state.programStudio.activeTab || 'info';
    const currentIndex = tabs.indexOf(activeTab);

    let tabContent = '';
    switch (activeTab) {
        case 'info': tabContent = templates.renderProgramStudioInfoTab(); break;
        case 'structure': tabContent = templates.renderProgramStudioStructureTab(); break;
        case 'publish': tabContent = `<div class="p-8 text-center text-gray-500">Étape de publication à venir.</div>`; break;
    }

    return `
    <div id="program-studio-page" class="h-full flex flex-col">
        <header class="p-4 flex justify-between items-center flex-shrink-0 border-b border-white/10 bg-[#1D1F2B]/80 backdrop-blur-md sticky top-0 z-20">
            <div class="flex items-center gap-2">
                <button data-action="go-back" class="text-gray-300 hover:text-white w-10 h-10 rounded-full hover:bg-white/10"><i class="fa-solid fa-arrow-left text-lg"></i></button>
            </div>
            
            <div class="flex items-center gap-2">
                <button data-action="prev-step" class="text-gray-300 hover:text-white w-10 h-10 rounded-full hover:bg-white/10 ${currentIndex === 0 ? 'opacity-30 cursor-not-allowed' : ''}" ${currentIndex === 0 ? 'disabled' : ''}>
                    <i class="fa-solid fa-chevron-left text-lg"></i>
                </button>
                <button data-action="next-step" class="text-gray-300 hover:text-white w-10 h-10 rounded-full hover:bg-white/10 ${currentIndex === tabs.length - 1 ? 'opacity-30 cursor-not-allowed' : ''}" ${currentIndex === tabs.length - 1 ? 'disabled' : ''}>
                    <i class="fa-solid fa-chevron-right text-lg"></i>
                </button>
            </div>
            
            <button data-action="save-draft" class="text-violet-300 hover:text-white w-10 h-10 rounded-full hover:bg-white/10" title="Sauvegarder le brouillon">
                <i class="fa-solid fa-save text-lg"></i>
            </button>
        </header>
        
        <nav class="flex-shrink-0 flex justify-around border-b border-white/10 mx-6">
            <button data-tab="info" class="studio-tab-btn py-3 px-4 font-semibold ${activeTab === 'info' ? 'text-violet-300 border-b-2 border-violet-300' : 'text-gray-500'}">1. Infos</button>
            <button data-tab="structure" class="studio-tab-btn py-3 px-4 font-semibold ${activeTab === 'structure' ? 'text-violet-300 border-b-2 border-violet-300' : 'text-gray-500'}">2. Structure</button>
            <button data-tab="publish" class="studio-tab-btn py-3 px-4 font-semibold ${activeTab === 'publish' ? 'text-violet-300 border-b-2 border-violet-300' : 'text-gray-500'}">3. Publier</button>
        </nav>
        
        <main id="studio-tab-content" class="flex-grow overflow-y-auto">
            ${tabContent}
        </main>
    </div>
    `;
},

Leaderboard: () => {
    if (!state.leaderboard) {
        state.leaderboard = { activeTab: 'total', genderFilter: 'tout', weightClassFilter: 'open' };
    }
    const userIsJudge = isUserAJudge(state.userProfile);

    return `
    <div class="h-full flex flex-col relative bg-[#161823]">
        <div class="absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre-v2.png')] opacity-20"></div>
        <div class="absolute inset-0 bg-gradient-to-t from-[#1D1F2B] via-[#1D1F2B]/90 to-transparent"></div>
        <div class="p-6 pb-28 h-full flex flex-col relative z-10">
            <header class="flex items-center justify-between pt-2 mb-4">
                <div class="w-16"><button data-navigate="Social" class="text-gray-300 hover:text-white"><i class="fa-solid fa-arrow-left text-xl"></i></button></div>
                <h1 class="text-3xl font-bold">Classement</h1>
                <div class="w-16 text-right">
                    ${userIsJudge ? `<button data-navigate="Tribunal" class="text-gray-300 hover:text-white" title="Accéder au Tribunal"><i class="fa-solid fa-gavel text-xl"></i></button>` : ''}
                </div>
            </header>
            <div class="flex-shrink-0 mb-4 flex items-center justify-center">
                <button id="open-leaderboard-filters-v3" class="w-full btn-primary !py-3 !text-base flex items-center justify-center gap-3 bg-white/5 border-2 border-white/10 hover:bg-white/10">
                    <i class="fa-solid fa-filter text-violet-300"></i>
                    <span id="leaderboard-filter-summary" class="font-semibold text-white">Total SBD - Open (Tous poids)</span>
                    <i class="fa-solid fa-chevron-down text-gray-500 text-sm"></i>
                </button>
            </div>
            <div id="leaderboard-hero" class="flex-shrink-0 h-40 mb-4"></div>
            <div id="leaderboard-list" class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-2 min-h-0"></div>
        </div>
        <div id="myleaderboard-rank" class="absolute bottom-28 left-6 right-6 z-20"></div>
    </div>`;
},

Social: () => {
    const activeTab = state.social.activeTab;

    return `
    <div class="p-6 pb-28 h-full flex flex-col">
        <header class="flex justify-between items-center pt-4 mb-6 relative">
    <h1 class="text-3xl font-bold">Social</h1>

    <button data-navigate="Leaderboard" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center justify-center w-14 h-14 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 shadow-lg" style="filter: drop-shadow(0 0 10px #FBBF24);">
        <i class="fa-solid fa-trophy text-2xl text-white"></i>
    </button>

    <div class="flex items-center gap-4">
        <button data-action="open-friend-list" class="text-gray-300 hover:text-white"><i class="fa-solid fa-user-group text-2xl"></i></button>
        <button data-navigate="SearchUsers" class="text-green-400"><i class="fa-solid fa-user-plus text-2xl"></i></button>
        <button id="social-inbox-btn" data-navigate="Inbox" class="relative text-gray-300 hover:text-white"><i class="fa-solid fa-inbox text-2xl"></i></button>
    </div>
</header>

<div class="flex-shrink-0 mb-6 p-1 bg-black/20 rounded-lg flex gap-1">
    <button data-tab="gym" class="social-tab-btn flex-1 p-2 rounded-md font-semibold ...">
        <i class="fa-solid fa-dumbbell"></i> Ma Salle
    </button>
    <button data-tab="clan" class="social-tab-btn flex-1 p-2 rounded-md font-semibold ...">
        <i class="fa-solid fa-users"></i> Mon Équipe
    </button>
</div>


        <div id="social-content-container" class="flex-grow flex flex-col min-h-0">
            <div class="flex-grow flex items-center justify-center">
                <i class="fa-solid fa-spinner fa-spin text-4xl text-gray-500"></i>
            </div>
        </div>
    </div>
    `;
},

SearchUsers: () => `
    <div class="p-6 pb-28 h-full flex flex-col">
        <header class="flex items-center gap-4 pt-4 mb-4">
             <button data-navigate="Social" class="text-gray-300 hover:text-white">
                <i class="fa-solid fa-arrow-left text-xl"></i>
            </button>
            <div class="relative flex-grow">
                <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                <input id="user-search-input" type="text" placeholder="Rechercher par pseudo..." class="input-glass pl-12 w-full">
            </div>
        </header>
        <div id="user-search-results" class="flex-grow overflow-y-auto space-y-3 pr-2 scrollbar-hide">
             <p class="text-center text-gray-500 pt-16">Recherchez un utilisateur pour commencer.</p>
        </div>
    </div>
`,

Inbox: () => `
    <div class="p-6 pb-28 h-full flex flex-col">
        <header class="flex items-center gap-4 pt-4 mb-4">
             <button data-navigate="Social" class="text-gray-300 hover:text-white">
                <i class="fa-solid fa-arrow-left text-xl"></i>
            </button>
            <h1 class="text-3xl font-bold">Boîte de réception</h1>
        </header>
        <div id="inbox-messages-container" class="flex-grow overflow-y-auto space-y-3 pr-2 scrollbar-hide">
             <p class="text-center text-gray-500 pt-16">Chargement des messages...</p>
        </div>
    </div>
`,

// Remplacez ce modèle
Achievements: () => {
    // Labels pour notre menu déroulant
    const sortLabels = {
        'progress_desc': 'Plus avancés',
        'progress_asc': 'Moins avancés',
        'alpha': 'Alphabétique'
    };

    const userAchievements = state.userProfile.achievements;
    const globalProgress = calculateGlobalAchievementProgress();

    // Logique de tri (inchangée)
    const sortedAchievements = ACHIEVEMENTS_DATABASE
    .filter(ach => !ach.isHidden || state.userProfile.inventory.titles.includes('t-createur-supreme'))
    .sort((a, b) => {

        const scoreA = calculateComprehensiveAchievementScore(a);
        const scoreB = calculateComprehensiveAchievementScore(b);

        switch (state.achievementsSortOrder) {
            case 'progress_desc':
                // On trie maintenant sur le score complet, pas juste le pourcentage
                return scoreB - scoreA; 
            case 'progress_asc':
                return scoreA - scoreB;
            case 'alpha':
            default:
                return a.name.localeCompare(b.name);
        }
    });

    return `
    <div class="p-6 pb-32 flex flex-col">
        
        <header class="flex items-center justify-between pt-2 mb-4">
            <div class="flex items-center gap-3">
                <button data-navigate="Profil" class="text-gray-300 hover:text-white self-start pt-1">
                    <i class="fa-solid fa-arrow-left text-xl"></i>
                </button>
                <div>
                    <h1 class="text-3xl font-bold">Succès</h1>
                    <p class="text-sm text-gray-400 font-semibold">${globalProgress.fullyCompletedCount} sur ${globalProgress.total} terminés</p>
                </div>
            </div>
            <div class="w-1/2">
                <div class="flex justify-between items-center mb-1">
                    <p class="text-xs text-gray-400 font-semibold">Total</p>
                    <span class="font-sans text-xs text-gray-300">${globalProgress.percentage}%</span>
                </div>
                <div class="w-full bg-black/20 rounded-full h-2">
                    <div class="bg-gradient-to-r from-yellow-400 to-orange-500 h-2 rounded-full" style="width: ${globalProgress.percentage}%"></div>
                </div>
            </div>
        </header>

        <div class="relative custom-select-container w-full mb-6">
            <button class="shop-sort-button custom-select-button !py-2 !text-sm" data-type="achievements-sort">
                <span>${sortLabels[state.achievementsSortOrder]}</span>
                <i class="fa-solid fa-chevron-down text-gray-500"></i>
            </button>
            <div class="shop-sort-options custom-select-options">
                <div class="custom-select-option" data-type="achievements-sort" data-value="progress_desc">${sortLabels['progress_desc']}</div>
                <div class="custom-select-option" data-type="achievements-sort" data-value="progress_asc">${sortLabels['progress_asc']}</div>
                <div class="custom-select-option" data-type="achievements-sort" data-value="alpha">${sortLabels['alpha']}</div>
            </div>
        </div>
        
        <div class="space-y-3">
            ${sortedAchievements.map(ach => {
                const currentValue = userAchievements[ach.id]?.progress || 0;
                const claimableCount = getClaimableRewardsCount(ach.id);
                const progressPercent = getAchievementProgressPercent(ach);
                
                let currentTierIndex = -1;
                for (let i = ach.tiers.length - 1; i >= 0; i--) {
                    if (currentValue >= ach.tiers[i].goal) {
                        currentTierIndex = i;
                        break;
                    }
                }
                const isUnlocked = currentTierIndex > -1;
                const cardStyle = !isUnlocked ? 'filter: grayscale(1); opacity: 0.6;' : '';
                const hasRewardsClass = claimableCount > 0 ? 'has-rewards' : '';

                return `
                <button data-action="view-achievement" data-id="${ach.id}" class="achievement-card ${hasRewardsClass}" style="${cardStyle}">
                    <div class="achievement-icon-wrapper">
                        <i class="fa-solid ${ach.icon} text-2xl" style="color: ${ach.color};"></i>
                        ${!isUnlocked ? '<div class="lock-overlay"><i class="fa-solid fa-lock"></i></div>' : ''}
                    </div>
                    <div class="flex-grow min-w-0">
                        <h3 class="font-bold text-base leading-tight">${ach.name} ${isUnlocked ? `(Niv. ${currentTierIndex + 1})` : ''}</h3>
                        <div class="flex items-center gap-2 mt-2">
                            <div class="flex-grow bg-black/20 rounded-full h-1.5">
                                <div class="bg-yellow-400 h-1.5 rounded-full" style="width: ${progressPercent.toFixed(0)}%"></div>
                            </div>
                            <span class="text-xs font-sans text-gray-400 w-8 text-right">${progressPercent.toFixed(0)}%</span>
                        </div>
                    </div>
                    ${claimableCount > 0 ? `<span class="notification-badge">${claimableCount}</span>` : ''}
                </button>
                `
            }).join('')}
        </div>
    </div>
    `;
},
            
            WorkoutSummary: ({ sessionId }) => {
        const session = state.sessionHistory.find(s => s.sessionId === sessionId);
        if (!session) return `<div class="p-6 text-center">Erreur: Résumé de la séance introuvable.</div>`;

        const workout = state.workouts.find(w => w.id === session.workoutId);
        const volumeTotal = session.totalVolume || 0; 
        const nouveauxRecords = session.prBeatenCount || 0;
        const formattedDuration = formatDuration(session.duration);
        const formattedVolume = formatVolume(volumeTotal);
        const rewards = session.rewards || { xp: 0, gold: 0 };

        let summaryHtml = '';
        if (Array.isArray(session?.performance) && session.performance.length > 0) {
            summaryHtml = session.performance.map((perf, index) => {
                const exercise = getExerciseById(perf?.exerciseId);
                const exerciseName = exercise?.name ?? 'Exercice Inconnu';
                
                // === CORRECTION APPLIQUÉE ICI ===
                // On calcule le rang basé sur la meilleure performance de CETTE séance, et non le rang global.
                let rankInfo, rankName, rankColor;

                if (perf.isRejected) {
                    rankName = 'Invalidé';
                    rankColor = '#EF4444'; // Rouge
                } else if (perf.bestSet) {
                    const bodyWeight = session.bodyWeightAtCompletion || state.userGoals.bodyWeight;
                    const sessionBestScore = calculatePerformanceScore({
                        ...exercise,
                        charge: perf.bestSet.weight,
                        reps: perf.bestSet.reps,
                        poidsDuCorps: bodyWeight
                    });
                    rankInfo = getRankFromScore(sessionBestScore, perf.exerciseId);
                    rankName = rankInfo?.name ?? 'Non classé';
                    rankColor = rankInfo?.color?.main ?? '#6B7280';
                } else {
                    rankName = 'Non classé';
                    rankColor = '#6B7280'; // Gris
                }
                // === FIN DE LA CORRECTION ===

                const weight = perf?.bestSet?.weight ?? 0;
                const reps = perf?.bestSet?.reps ?? 0;
                const isNewPr = perf?.isNewPr ?? false;
                
                const recordHtml = (() => {
                    if (perf.isRejected) {
                        return `
                        <div class="text-center bg-red-900/50 p-3 rounded-lg border border-red-500">
                            <span class="text-sm font-semibold text-red-400">
                                EXERCICE INVALIDÉ <i class="fa-solid fa-triangle-exclamation text-xs ml-1"></i>
                            </span>
                            <p class="text-gray-400 text-xs mt-1">Toutes les séries étaient irréalistes.</p>
                        </div>`;
                    } else if (isNewPr) {
                        return `
                        <div class="text-center bg-black/20 p-3 rounded-lg">
                            <span class="text-sm font-semibold text-yellow-300">
                                Nouveau Record <i class="fa-solid fa-star text-xs ml-1"></i>
                            </span>
                            <p class="text-2xl font-bold mt-1">${weight} kg × ${reps} reps</p>
                        </div>`;
                    }
                    return '';
                })();

                let setsHistoryHtml = '';
                if (Array.isArray(perf?.sets) && perf.sets.length > 0) {
                    setsHistoryHtml = `
                        <div class="mt-4 pt-4 border-t border-white/10">
                            <h4 class="font-semibold text-sm text-gray-300 mb-2">Historique des séries :</h4>
                            <ul class="space-y-1 pl-1">
                                ${perf.sets.map((set, setIndex) => {
                                    const setStyle = set.isRejected ? 'text-red-500/60 line-through' : 'text-gray-400';
                                    const rejectedLabel = set.isRejected ? ' <span class="text-xs font-bold text-red-500/60">(Ignorée)</span>' : '';
                                    return `<li class="${setStyle} text-sm">Série ${setIndex + 1}: <span class="font-semibold text-gray-300/80">${set.weight ?? 0} kg × ${set.reps ?? 0} reps</span>${rejectedLabel}</li>`
                                }).join('')}
                            </ul>
                        </div>
                    `;
                }

                return `
                    <div class="summary-card glass-card p-4 rounded-xl" style="animation-delay: ${index * 150 + 400}ms; opacity: 0; animation: fadeInModal 0.5s forwards; animation-fill-mode: forwards;">
                        <div class="flex items-center justify-between mb-3">
                            <span class="font-semibold text-base flex-1 truncate mr-2">${exerciseName}</span>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <i class="fa-solid fa-shield-halved text-lg" style="color: ${rankColor};"></i>
                                <span class="font-bold text-sm" style="color: ${rankColor};">${rankName}</span>
                            </div>
                        </div>
                        ${recordHtml}
                        ${setsHistoryHtml}
                    </div>
                `;
            }).join('');
        } else {
            summaryHtml = `<div class="glass-card p-4 rounded-xl text-center text-gray-400">Aucun exercice n'a été enregistré pour cette séance.</div>`;
        }
        
        return `
            <div class="p-6 h-full flex flex-col relative overflow-hidden">
                <header class="pt-4 mb-4 text-center summary-card flex-shrink-0" style="animation-delay: 0ms; opacity: 0; animation: fadeInModal 0.5s forwards; animation-fill-mode: forwards;">
                    <h1 class="text-4xl font-extrabold tracking-tight">Séance Terminée !</h1>
                    <p class="text-gray-300 text-lg mt-1">${workout?.name || 'Bravo !'} 💪</p>
                </header>
                <div class="summary-card glass-card p-4 rounded-xl mb-4" style="animation-delay: 200ms; opacity: 0; animation: fadeInModal 0.5s forwards; animation-fill-mode: forwards;">
                    <h2 class="font-bold text-center text-lg mb-3">Résumé Global</h2>
                    <div class="grid grid-cols-3 gap-3 text-center">
                        <div><p class="text-2xl font-bold">${formattedDuration}</p><p class="text-xs text-gray-400">Durée ⏱️</p></div>
                        <div><p class="text-2xl font-bold">${formattedVolume}</p><p class="text-xs text-gray-400">Volume (kg) 🏋️</p></div>
                        <div><p class="text-2xl font-bold text-yellow-400">${nouveauxRecords}</p><p class="text-xs text-gray-400">Nouveaux PR 🔥</p></div>
                    </div>
                    <div class="mt-4 pt-3 border-t border-white/10 flex justify-center items-center gap-6 text-sm">
                        <span class="font-semibold text-violet-400">+${rewards.xp.toLocaleString('fr-FR')} XP ✨</span>
                        <span class="font-semibold text-yellow-400">+${rewards.gold.toLocaleString('fr-FR')} 💰</span>
                    </div>
                </div>
                <div class="flex-grow space-y-3 overflow-y-auto scrollbar-hide p-1 min-h-0">
                    <h2 class="summary-card font-bold text-center text-lg mb-3 text-gray-300" style="animation-delay: 300ms; opacity: 0; animation: fadeInModal 0.5s forwards; animation-fill-mode: forwards;">Récapitulatif Détaillé</h2>
                    ${summaryHtml}
                </div>
                <button data-navigate="Accueil" class="w-full btn-primary mt-6 summary-card flex-shrink-0" style="animation-delay: ${(session.performance?.length ?? 0) * 150 + 500}ms; opacity: 0; animation: fadeInModal 0.5s forwards; animation-fill-mode: forwards;">Retour à l'accueil</button>
            </div>
        `;
    },

BottomNav: () => {
                const isWorkout = state.activeSide === 'workout';
                
                // --- Définition des icônes ---
                const homeIcon = { id: 'Accueil', icon: 'fa-house' };
                // L'icône de la bibliothèque est maintenant la même pour les deux modes
                const libraryIcon = isWorkout 
                    ? { id: 'Workouts', icon: 'fa-book-bookmark' } 
                    : { id: 'Repas', icon: 'fa-book-bookmark' }; 
                
                // CORRECTION ICI : Remplacement du deuxième '?' par un ':'
                const contextualIcon = isWorkout
                    ? { id: 'Stats', icon: 'fa-ranking-star' } 
                    : { id: 'Dashboard', icon: 'fa-chart-pie' };
                
                // La nouvelle icône Sociale
                const socialIcon = { id: 'Social', icon: 'fa-users' };

                const renderNavItem = (item) => `
                    <button data-navigate="${item.id}" class="bottom-nav-item relative flex flex-col items-center justify-center gap-1 w-16 h-full transition-colors ${state.activePage === item.id ? 'active' : ''}">
                        <i class="fa-solid ${item.icon} text-xl text-gray-400"></i>
                    </button>
                `;

                return `
                    <div class="glass-card flex justify-around items-center h-full rounded-full relative">
                        <div class="flex justify-around flex-1">
                            ${renderNavItem(homeIcon)}
                            ${renderNavItem(libraryIcon)}
                        </div>
                        
                        <div class="w-20"></div>

                        <div class="flex justify-around flex-1">
                            ${renderNavItem(contextualIcon)}
                            ${renderNavItem(socialIcon)}
                        </div>
                        
                        <button id="flow-switcher" title="Changer de mode">
                            <div class="icon-wrapper workout-icon"><i class="fa-solid fa-dumbbell text-2xl text-white"></i></div>
                            <div class="icon-wrapper nutrition-icon"><i class="fa-solid fa-utensils text-2xl text-white"></i></div>
                        </button>
                    </div>
                `;
            }
            }

            function renderNoClanView() {
                stopClanMusic()
    return `
    <div class="p-6 pb-28 h-full flex flex-col">
        <header class="flex justify-between items-center pt-4 mb-6">
            <h1 class="text-3xl font-bold">Équipes</h1>
        </header>
        <div class="flex-grow flex flex-col items-center justify-center text-center">
            <i class="fa-solid fa-users-slash text-6xl text-gray-600 mb-4"></i>
            <p class="font-semibold text-lg">Vous n'êtes dans aucune équipe.</p>
            <p class="text-sm text-gray-500 max-w-xs mx-auto">Recherchez une équipe à rejoindre ou créez la vôtre pour commencer à collaborer.</p>
            <div class="w-full max-w-sm mt-8 space-y-4">
                <div class="relative">
                    <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                    <input id="clan-search-input" type="text" placeholder="Rechercher une équipe..." class="input-glass pl-12 w-full">
                </div>
                <button id="open-create-clan-modal" class="btn-primary w-full">Créer une Équipe</button>
            </div>
            <div id="clan-search-results" class="w-full max-w-sm mt-4 space-y-2"></div>
        </div>
    </div>
    `;
}

function renderNoGymView() {
    return `
    <div class="p-6 pb-28 h-full flex flex-col">
        <header class="flex justify-between items-center pt-4 mb-6">
            <h1 class="text-3xl font-bold">Salles de Sport</h1>
        </header>
        <div class="flex-grow flex flex-col text-center">
            <p class="text-sm text-gray-500 max-w-xs mx-auto mb-4">Recherchez une ville pour trouver des salles de sport.</p>
            
            <div class="w-full max-w-sm mx-auto space-y-4 relative">
    <div class="relative">
        <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
        <input id="city-search-input" type="text" placeholder="Entrez une ville, une adresse..." class="input-glass pl-12 w-full">
    </div>
    <div id="autocomplete-results-container" class="absolute top-full left-0 right-0 z-10 bg-[#23253A] border border-white/10 rounded-xl overflow-hidden max-h-60 overflow-y-auto"></div>
</div>

            <div id="map" class="w-full flex-grow rounded-xl my-4 min-h-[300px]"></div>
            <div id="gym-results-list" class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide"></div>

        </div>
    </div>
    `;
}

function renderClanSearchView(message = '') {
    return `
    <div class="flex-grow flex flex-col items-center justify-center text-center animate-fadeIn">
        <i class="fa-solid fa-users-slash text-6xl text-gray-600 mb-4"></i>
        ${message || `
            <p class="font-semibold text-lg">Vous n'êtes dans aucune équipe.</p>
            <p class="text-sm text-gray-500 max-w-xs mx-auto">Recherchez une équipe à rejoindre ou créez la vôtre.</p>
        `}
        <div class="w-full max-w-sm mt-8 space-y-4">
            <div class="relative"><i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i><input id="clan-search-input" type="text" placeholder="Rechercher une équipe..." class="input-glass pl-12 w-full"></div>
            <button id="open-create-clan-modal" class="btn-primary w-full">Créer une Équipe</button>
        </div>
        <div id="clan-search-results" class="w-full max-w-sm mt-4 space-y-2"></div>
    </div>`;
}

// Fonction placeholder pour la vue du clan (on la remplira plus tard)
function renderMyClanView(clanId) {
    const socialContentContainer = document.getElementById('social-content-container');
    if (!socialContentContainer) return;

    // On s'assure de couper l'ancien écouteur avant d'en créer un nouveau
    if (clanListener) clanListener();

    clanListener = onSnapshot(doc(db, 'clans', clanId), async (clanSnap) => {
        if (!clanSnap.exists()) {
            socialContentContainer.innerHTML = renderClanSearchView('<p class="text-red-400 text-center">Erreur: Équipe introuvable.</p>');
            return;
        }
        
        const clanData = { id: clanSnap.id, ...clanSnap.data() };
        state.currentClanData = clanData;

        const memberPromises = clanData.members.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
        const memberDocs = await Promise.all(memberPromises);
        const membersData = memberDocs.map(d => d.exists() ? d.data() : null).filter(Boolean);
        state.currentClanMembersData = membersData;
        
        // On met à jour directement le contenu de la page sans recharger toute l'application
        socialContentContainer.innerHTML = renderMyClanViewFromData(clanData, membersData);
    });

    // On retourne un spinner de chargement initial
    return `<div class="flex-grow flex items-center justify-center"><i class="fa-solid fa-spinner fa-spin text-4xl text-gray-500"></i></div>`;
}

function renderMyClanViewFromData(clanData, membersData) {
    // ... Logique de calcul inchangée ...
    const isCurrentUserChef = clanData.chefUid === currentUserId;
    const canInvite = isCurrentUserChef && clanData.members.length < 10;
    const clanIcon = CLAN_ICONS.find(icon => icon.id === clanData.iconId) || { id: 'default', icon: 'fa-users' };
    const { averageRank, color: rankColor } = calculateAverageRank(membersData);
    const totalPower = membersData.reduce((sum, member) => sum + (RANK_POINTS_MAP[member.globalRank] || 0), 0);
    const musicTrack = CLAN_MUSIC_DATABASE.find(m => m.id === clanData.clanMusic);
    let nameClasses = 'text-4xl font-extrabold tracking-tighter';
    let nameStyle = `color: ${clanData.nameColor};`;
    if (clanData.nameIsAnimated) {
        nameClasses += ' dynamic-animated-gradient-text';
        nameStyle = `--base-color: ${clanData.nameColor}; --highlight-color: ${lightenColor(clanData.nameColor, 0.4)};`;
    }
    let iconClasses = `fa-solid ${clanIcon.icon} text-6xl relative z-10`;
    let iconStyle = `color: ${clanData.iconColor};`;
    if (clanData.iconIsAnimated) {
        iconClasses += ' dynamic-animated-gradient-icon';
        iconStyle = `--base-color-icon: ${clanData.iconColor}; --highlight-color-icon: ${lightenColor(clanData.iconColor, 0.4)};`;
    }
    const sortedMembers = [...membersData].sort((a, b) => (a.uid === clanData.chefUid ? -1 : 1) - (b.uid === clanData.chefUid ? -1 : 1) || (RANK_POINTS_MAP[b.globalRank] || 0) - (RANK_POINTS_MAP[a.globalRank] || 0));
    const featuredMembers = sortedMembers.slice(0, 3);
    const otherMembers = sortedMembers.slice(3);

    return `
    <div class="flex-grow flex flex-col min-h-0 animate-fadeIn">
        
        <header class="p-6 pt-4 text-center relative flex-shrink-0">
            <div id="clan-header-title-wrapper" class="relative flex flex-col items-center justify-center gap-2">
                
                <i class="${iconClasses}" style="${iconStyle}"></i>

                <div class="relative flex items-center justify-center">
                    <h1 class="${nameClasses}" style="${nameStyle}">${clanData.name}</h1>
                    
                    ${isCurrentUserChef ? `
                        <button id="open-clan-settings-btn" class="settings-pencil-btn absolute left-full ml-2" title="Personnaliser l'équipe">
                            <i class="fa-solid fa-pencil"></i>
                        </button>
                    ` : ''}
                </div>
            </div>

            <div class="absolute inset-0 flex items-center justify-center pointer-events-none -top-8">
                <div class="w-48 h-48 rounded-full" style="background: radial-gradient(circle, ${clanData.iconColor}1A 0%, transparent 70%);"></div>
            </div>
            
            <div class="absolute top-4 left-4 flex gap-2 z-20">
                <button id="open-clan-search-modal-btn" class="w-10 h-10 rounded-full bg-black/30 backdrop-blur-sm flex items-center justify-center text-white hover:bg-black/50 transition-colors" title="Rechercher une autre équipe"><i class="fa-solid fa-magnifying-glass"></i></button>
                <button id="toggle-clan-mute-btn" class="w-10 h-10 rounded-full bg-black/30 backdrop-blur-sm flex items-center justify-center text-white hover:bg-black/50 transition-colors" title="Son de l'équipe">
                    <i class="fa-solid ${state.clanMusicMuted ? 'fa-volume-xmark' : 'fa-volume-high'}"></i>
                </button>
            </div>

            ${musicTrack && musicTrack.image ? `
            <div class="absolute top-16 left-8 w-16 h-16 flex items-center justify-center z-10">
                 <button id="toggle-clan-music-btn-vinyl" class="w-full h-full rounded-full bg-gray-900 shadow-lg group spinning-vinyl" style="animation-play-state: ${state.clanAudioElement && !state.clanAudioElement.paused ? 'running' : 'paused'}">
                    <div class="w-full h-full rounded-full bg-black flex items-center justify-center">
                        <img src="${musicTrack.image}" class="w-[90%] h-[90%] object-cover rounded-full" alt="Pochette">
                        <div class="absolute w-3 h-3 bg-gray-800 rounded-full border-2 border-gray-900"></div>
                    </div>
                 </button>
            </div>
            ` : ''}
        </header>

        <div class="px-6 pb-4 flex-shrink-0">
            <div class="glass-card p-3 rounded-xl flex items-center text-center">
                <div class="flex-1 px-2 border-r border-white/10"><p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-users text-xs"></i> Membres</p><p class="text-xl font-bold">${clanData.members.length}<span class="text-sm text-gray-500">/10</span></p></div>
                <div class="flex-[1.5] px-2 border-r border-white/10"><p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-shield-halved text-xs"></i> Rang Moyen</p><p class="text-xl font-bold truncate" style="color: ${rankColor};">${averageRank}</p></div>
                <div class="flex-1 px-2"><p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-bolt text-xs"></i> Puissance</p><p class="text-xl font-bold">${totalPower}</p></div>
            </div>
        </div>
        <div class="flex-grow overflow-y-auto scrollbar-hide px-6 space-y-3">
            <div><h3 class="font-bold text-lg mb-2">Membres à la une</h3><div class="space-y-3">${featuredMembers.map(member => renderUnifiedUserCard(member, 'clan-member', clanData.chefUid)).join('')}</div></div>
            ${otherMembers.length > 0 ? `<div><h3 class="font-bold text-lg mb-2 pt-2">Tous les membres</h3><div class="space-y-3">${otherMembers.map(member => renderUnifiedUserCard(member, 'clan-member', clanData.chefUid)).join('')}</div></div>` : ''}
        </div>
        <footer class="flex-shrink-0 p-4 pt-3 mt-auto">
             <div class="flex gap-2">
                ${canInvite ? `<button id="invite-to-clan-btn" class="btn-primary flex-1"><i class="fa-solid fa-user-plus mr-2"></i>Inviter</button>` : ''}
                <button id="leave-clan-btn" class="secondary-btn ${!canInvite ? 'w-full' : 'flex-1'} bg-red-500/10 !border-red-500 !text-red-400 hover:!bg-red-500/20">Quitter</button>
            </div>
        </footer>
    </div>`;
}

async function openSubmitSBDPerfModal() {
    // La logique de vérification au début est inchangée et correcte...
    const processingQuery = query(collection(db, 'video_validations'), where('userId', '==', currentUserId), where('status', '==', 'processing'));
    const processingSnapshot = await getDocs(processingQuery);
    if (!processingSnapshot.empty) {
        showToast("Veuillez attendre la fin du traitement de votre vidéo actuelle.", "error");
        return;
    }
    const pendingQuery = query(collection(db, 'video_validations'), where('userId', '==', currentUserId), where('status', '==', 'pending'));
    const pendingSnapshot = await getDocs(pendingQuery);
    const pendingLifts = [];
    if (!pendingSnapshot.empty) {
        for (const pendingDoc of pendingSnapshot.docs) { 
            const videoData = pendingDoc.data();
            const perfDoc = await getDoc(doc(db, 'sbd_performances', videoData.sbdPerfId));
            if (perfDoc.exists()) {
                pendingLifts.push(perfDoc.data().liftType);
            }
        }
    }
    if (pendingLifts.length >= 3) {
        showToast("Vous avez atteint la limite de 3 vidéos en attente.", "error");
        return;
    }

    // === LE CODE HTML A ÉTÉ ENTIÈREMENT RESTAURÉ CI-DESSOUS ===
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Soumettre un 1RM</h2>
             <button class="close-modal w-8 h-8 rounded-full bg-black/20 z-20 flex items-center justify-center text-xl hover:bg-white/10">×</button>
        </header>
        <div id="sbd-submit-form" class="space-y-4">
            <div>
                <label class="font-semibold text-gray-400 text-sm">Mouvement</label>
                <div class="flex-shrink-0 mt-1 p-1 bg-black/20 rounded-lg flex gap-1">
                    <button data-lift="squat" class="sbd-lift-btn flex-1 p-2 rounded-md font-semibold text-gray-400" ${pendingLifts.includes('squat') ? 'disabled' : ''}>Squat</button>
                    <button data-lift="bench" class="sbd-lift-btn flex-1 p-2 rounded-md font-semibold text-gray-400" ${pendingLifts.includes('bench') ? 'disabled' : ''}>Bench</button>
                    <button data-lift="deadlift" class="sbd-lift-btn flex-1 p-2 rounded-md font-semibold text-gray-400" ${pendingLifts.includes('deadlift') ? 'disabled' : ''}>Deadlift</button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="sbd-weight-input" class="text-sm font-semibold text-gray-400">Poids 1RM (kg)</label>
                    <input id="sbd-weight-input" type="number" class="input-glass mt-1" placeholder="Ex: 100">
                </div>
                <div>
                    <label class="text-sm font-semibold text-gray-400">Poids du corps</label>
                    <input type="text" class="input-glass mt-1 bg-black/30 text-gray-400" value="${state.userGoals.bodyWeight} kg" disabled>
                </div>
            </div>
            <div>
                <label class="font-semibold text-gray-400 text-sm">Preuve Vidéo</label>
                <div class="mt-1 p-4 border-2 border-dashed border-gray-600 rounded-xl text-center cursor-pointer hover:border-violet-400" id="video-dropzone">
                    <i class="fa-solid fa-video text-3xl text-gray-500"></i>
                    <p id="video-file-label" class="text-sm text-gray-400 mt-2">Cliquez pour choisir (verticale, <20s, <50MB)</p>
                </div>
                <input type="file" id="sbd-video-input" class="hidden" accept="video/*">
            </div>
        </div>
        <div id="upload-progress-container" class="text-center hidden">
            <p id="upload-progress-text" class="text-sm text-violet-300 font-semibold"></p>
            <div class="w-full bg-black/20 rounded-full h-2.5 mt-2">
                <div id="upload-progress-bar" class="bg-violet-500 h-2.5 rounded-full transition-width duration-300" style="width: 0%"></div>
            </div>
        </div>
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-sbd-submit-btn" class="w-full btn-primary" disabled>Soumettre</button>
        </div>
        <button id="cancel-upload-btn" class="w-full mt-2 glass-card p-3 rounded-lg font-bold hidden">Annuler l'envoi</button>
    </div>`;
    // =========================================================

    showModal(modalContent, (modalWrapper) => {
        // Le bloc de déclarations de variables et la logique JavaScript interne sont corrects et inchangés...
        let selectedLift = null;
        let selectedFile = null;
        const form = modalWrapper.querySelector('#sbd-submit-form');
        const closeBtn = modalWrapper.querySelector('.cancel');
        const confirmBtn = modalWrapper.querySelector('#confirm-sbd-submit-btn');
        const cancelBtn = modalWrapper.querySelector('#cancel-upload-btn');
        const dropzone = modalWrapper.querySelector('#video-dropzone');
        const videoInput = modalWrapper.querySelector('#sbd-video-input');
        const videoLabel = modalWrapper.querySelector('#video-file-label');
        const progressContainer = modalWrapper.querySelector('#upload-progress-container');
        const progressText = modalWrapper.querySelector('#upload-progress-text');
        const progressBar = modalWrapper.querySelector('#upload-progress-bar');
        let uploadTask = null;

        const validateForm = () => {
            const weight = parseFloat(modalWrapper.querySelector('#sbd-weight-input').value);
            const isLiftSlotAvailable = selectedLift && !pendingLifts.includes(selectedLift);
            const isFormValid = isLiftSlotAvailable && weight > 0 && selectedFile;
            confirmBtn.disabled = !isFormValid;
        };
        

        const handleFile = (file) => {
            if (!file || !file.type.startsWith('video/')) {
                showToast("Veuillez sélectionner un fichier vidéo.", "error"); return;
            }
            if (file.size > 50 * 1024 * 1024) {
                showToast("La vidéo est trop lourde (max 50MB).", "error"); return;
            }

            const video = document.createElement('video');
            video.preload = 'metadata';
            video.onloadedmetadata = function() {
                window.URL.revokeObjectURL(video.src);
                if (video.duration > 20) {
                    showToast("La vidéo doit faire moins de 20 secondes.", "error");
                    return;
                }
                if (video.videoWidth > video.videoHeight) {
                    showToast("La vidéo doit être au format vertical (9/16).", "error");
                    return;
                }
                selectedFile = file;
                videoLabel.textContent = file.name;
                videoLabel.classList.add('text-violet-300');
                validateForm();
            };
            video.src = URL.createObjectURL(file);
        };
        
        confirmBtn.addEventListener('click', async () => {
    confirmBtn.disabled = true;
    form.style.display = 'none';
    closeBtn.classList.add('hidden');
    confirmBtn.classList.add('hidden');
    progressContainer.classList.remove('hidden');
    cancelBtn.classList.remove('hidden');
    
    try {
        // --- Phase 1 : Upload (inchangé) ---
        const { task, promise } = uploadFile(selectedFile, (progress) => {
            progressText.textContent = `Envoi de la vidéo... ${progress.toFixed(0)}%`;
            progressBar.style.width = `${progress}%`;
        });
        
        uploadTask = task;
        const { downloadURL, filePath } = await promise;

        // --- Phase 2 : Création du document et attente ---
        progressText.textContent = 'Initialisation du traitement...';
        
        // On récupère l'ID du document qui sera traité par la fonction
        const validationDocId = await submitSBDPerformanceForValidation({
            liftType: selectedLift,
            weight: parseFloat(modalWrapper.querySelector('#sbd-weight-input').value),
            reps: 1,
            bodyweight: state.userGoals.bodyWeight,
            videoUrl: downloadURL,
            videoPath: filePath
        });

        if (!validationDocId) {
            throw new Error("La création du document de validation a échoué.");
        }

        // On change le message pour indiquer le traitement côté serveur
        progressText.textContent = 'Compression de la vidéo... (cela peut prendre un moment)';
        progressBar.style.width = `100%`; // La barre reste pleine
        progressBar.classList.add('animate-pulse'); // On ajoute une petite animation
        cancelBtn.classList.add('hidden'); // On ne peut plus annuler

        // On met en place un écouteur en temps réel sur ce document précis
        const unsubscribe = onSnapshot(doc(db, "video_validations", validationDocId), async (docSnapshot) => {
            // Si le document existe et que son statut est passé à "pending"...
            if (docSnapshot.exists() && docSnapshot.data().status === 'pending') {
                unsubscribe(); // On arrête d'écouter pour ne pas consommer de ressources
                clearTimeout(processingTimeout); // On annule la sécurité de timeout
                
                // --- NOUVELLE LOGIQUE AJOUTÉE ---
                const videoData = docSnapshot.data();
                const perfDocRef = doc(db, 'sbd_performances', videoData.sbdPerfId);
                const perfDoc = await getDoc(perfDocRef);

                if (perfDoc.exists()) {
                    const perfData = perfDoc.data();
                    const liftType = perfData.liftType;

                    // On s'assure que la structure du coffre-fort existe dans l'état local
                    if (!state.userProfile.sbdVault) state.userProfile.sbdVault = {};
                    if (!state.userProfile.sbdVault[liftType]) {
                        state.userProfile.sbdVault[liftType] = { verified: null, pending_tribunal: null, processing: null, pending: null };
                    }

                    // On remplit l'emplacement "pending" du coffre-fort avec toutes les données nécessaires
                    state.userProfile.sbdVault[liftType].pending = {
                        id: videoData.sbdPerfId,
                        weight: perfData.weight,
                        status: 'pending',
                        timestamp: perfData.timestamp,
                        validationId: validationDocId,
                        videoUrl: videoData.compressedVideoUrl || videoData.videoUrl, // On préfère l'URL compressée
                        judgements: videoData.judgements || []
                    };
                    
                    // Cette soumission n'est plus en "traitement"
                    state.userProfile.sbdVault[liftType].processing = null;
                    
                    // On sauvegarde le nouvel état du coffre-fort dans Firestore
                    await saveState(); 
                }
                // --- FIN DE LA NOUVELLE LOGIQUE ---
                
                showToast("Votre vidéo a été traitée et soumise !", "success");
                closeModal(); // On ferme la modale de soumission
                openSbdVaultModal(); // On ouvre immédiatement le coffre-fort pour afficher la vidéo en attente
            }
        });

        // On ajoute une sécurité : un timeout de 90 secondes en cas d'échec de la fonction
        const processingTimeout = setTimeout(() => {
            unsubscribe(); // On arrête d'écouter
            showToast("Le traitement a échoué ou a pris trop de temps.", "error");
            closeModal();
        }, 90000); // 90 secondes

    } catch (error) {
        if (error.code !== 'storage/canceled') {
            showToast("Une erreur critique est survenue.", "error");
            console.error("Upload/Processing Error:", error);
        }
        closeModal();
    }
});

        closeBtn.addEventListener('click', () => {
            closeModal();
        });

        cancelBtn.addEventListener('click', () => {
            if (uploadTask) {
                uploadTask.cancel();
            }
            closeModal();
        });

        modalWrapper.querySelectorAll('.sbd-lift-btn').forEach(btn => btn.addEventListener('click', () => {
            modalWrapper.querySelectorAll('.sbd-lift-btn').forEach(b => b.classList.remove('bg-white/10', 'text-white'));
            btn.classList.add('bg-white/10', 'text-white');
            selectedLift = btn.dataset.lift;
            validateForm();
        }));
        
        dropzone.addEventListener('click', () => videoInput.click());
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('border-violet-400');
        });
        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('border-violet-400');
        });
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('border-violet-400');
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });
        videoInput.addEventListener('change', (e) => { 
            if (e.target.files.length) handleFile(e.target.files[0]); 
        });
        modalWrapper.querySelector('#sbd-weight-input').addEventListener('input', validateForm);
    });
}

function openSystemMessageModal(message) {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col">
        <header class="flex justify-between items-center mb-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid ${message.systemIcon || 'fa-robot'} text-violet-400 text-2xl"></i>
                <h2 class="text-2xl font-bold">${message.subject || 'Message du Système'}</h2>
            </div>
        </header>
        <div class="text-gray-300">
            <p class="leading-relaxed">${message.content}</p>
            <p class="text-sm text-gray-500 mt-4">Reçu le ${message.timestamp.toDate().toLocaleString('fr-FR')}</p>
        </div>
        <button id="close-and-delete-message" class="w-full mt-8 btn-primary">OK</button>
    </div>
    `;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#close-and-delete-message').onclick = async () => {
            // 1. Ferme la modale pour une meilleure réactivité
            closeModal();
            
            // 2. Retire le message de l'état local et met à jour l'affichage de la boîte de réception
            const messageIndex = state.inbox.unreadMessages.findIndex(m => m.id === message.id);
            if (messageIndex > -1) {
                state.inbox.unreadMessages.splice(messageIndex, 1);
                renderInboxMessages();
                updateSocialNotificationBadge(); // Met à jour la pastille de notification
            }
            
            // 3. Supprime le message de la base de données en arrière-plan
            try {
                await deleteDoc(doc(db, 'inboxMessages', message.id));
            } catch (error) {
                console.error("Échec de la suppression du message:", error);
            }
        };
    });
}

async function openMyVideosModal() {
    // On prépare nos 3 emplacements SBD
    const slots = {
        squat: { label: 'Squat', data: null },
        bench: { label: 'Bench', data: null },
        deadlift: { label: 'Deadlift', data: null }
    };

    // --- NOUVEAU : On fait deux requêtes en parallèle ---
    // 1. On cherche les soumissions de vidéos classiques (1RM) et celles en cours de compression
    const videoSubmissionsQuery = query(collection(db, 'video_validations'), 
        where('userId', '==', currentUserId),
        where('status', 'in', ['processing', 'pending'])
    );
    // 2. On cherche les performances de séance qui attendent une preuve vidéo
    const sbdPerformancesQuery = query(collection(db, 'sbd_performances'),
        where('userId', '==', currentUserId),
        where('status', '==', 'pending_tribunal')
    );

    const [videoSubmissionsSnapshot, sbdPerformancesSnapshot] = await Promise.all([
        getDocs(videoSubmissionsQuery),
        getDocs(sbdPerformancesQuery)
    ]);
    // --- FIN DES NOUVELLES REQUÊTES ---

    // On traite les soumissions de vidéo
    for (const validationDoc of videoSubmissionsSnapshot.docs) {
        const videoData = { id: validationDoc.id, ...validationDoc.data() };
        const perfDoc = await getDoc(doc(db, 'sbd_performances', videoData.sbdPerfId));
        if (perfDoc.exists()) {
            const perfData = perfDoc.data();
            if (slots[perfData.liftType]) {
                slots[perfData.liftType].data = { ...videoData, perfData, sourceType: 'video_submission' };
            }
        }
    }
    
    // On traite les performances de séance en attente de preuve
    sbdPerformancesSnapshot.forEach(perfDoc => {
        const perfData = { id: perfDoc.id, ...perfDoc.data() };
        if (slots[perfData.liftType]) {
            slots[perfData.liftType].data = { ...perfData, sourceType: 'sbd_performance' };
        }
    });
    
    // La logique pour générer le HTML est maintenant plus intelligente
    const slotsHtml = Object.keys(slots).map(liftType => {
        const slot = slots[liftType];
        if (slot.data) {
            const item = slot.data;
            let contentHtml = '';

            // Cas 1 : Vidéo en cours de compression
            if (item.status === 'processing') {
                contentHtml = `
                    <p class="font-bold text-lg text-white">${slot.label} - ${item.perfData.weight}kg</p>
                    <div class="text-center py-4 mt-2">
                        <p class="text-sm font-semibold text-violet-300 animate-pulse">Traitement en cours...</p>
                    </div>`;
            } 
            // Cas 2 : Performance de séance en attente de validation
            else if (item.status === 'pending_tribunal') {
                contentHtml = `
                    <div class="flex items-center justify-between">
                        <p class="font-bold text-lg text-white">${slot.label} - ${item.weight}kg</p>
                        <div class="flex items-center gap-2">
                             <button data-action="open-locked-validation" data-perf-id="${item.id}" class="btn-primary !py-2 !px-4 text-sm flex items-center gap-2" title="Soumettre une vidéo de preuve">
                                <i class="fa-solid fa-video"></i> Faire valider
                            </button>
                            <button data-action="delete-sbd-performance" data-perf-id="${item.id}" class="text-red-400 hover:text-red-600 w-8 h-8 rounded-full bg-black/20 flex items-center justify-center" title="Supprimer la performance">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </div>
                    </div>
                    <p class="text-sm text-gray-400 mt-2">Enregistré le ${item.timestamp.toDate().toLocaleDateString('fr-FR')}</p>
                `;
            }
            // Cas 3 : Vidéo 1RM classique en attente de votes
            else {
                // ... (cette partie est pour la compatibilité avec l'ancien système, elle reste la même)
                const date = item.perfData.timestamp.toDate().toLocaleDateString('fr-FR');
                const approvals = item.judgements?.filter(j => j.vote === 'legitime').length || 0;
                const rejections = item.judgements?.filter(j => j.vote === 'invalide').length || 0;
                contentHtml = `
                 <div class="flex items-center justify-between">
                    <p class="font-bold text-lg text-white">${slot.label} - ${item.perfData.weight}kg</p>
                    <div class="flex items-center gap-2">
                        <button data-action="preview-pending-video" data-video-url="${item.compressedVideoUrl || item.videoUrl}" class="text-sky-300 hover:text-sky-500 w-8 h-8 rounded-full bg-black/20 flex items-center justify-center"><i class="fa-solid fa-eye"></i></button>
                        <button data-action="delete-pending-video" data-validation-id="${item.id}" class="text-red-400 hover:text-red-600 w-8 h-8 rounded-full bg-black/20 flex items-center justify-center"><i class="fa-solid fa-trash-can"></i></button>
                    </div>
                </div>
                <div class="flex justify-between items-center text-sm mt-2">
                    <p class="text-gray-400">Soumis le ${date}</p>
                    <div class="flex items-center gap-4">
                       <span class="font-semibold text-green-400 flex items-center gap-1.5" title="Validations"><i class="fa-solid fa-check"></i> ${approvals}</span>
                       <span class="font-semibold text-red-400 flex items-center gap-1.5" title="Refus"><i class="fa-solid fa-xmark"></i> ${rejections}</span>
                    </div>
                </div>
                `;
            }

            return `<div class="glass-card p-4 rounded-xl">${contentHtml}</div>`;

        } else {
            return `<div class="p-4 rounded-xl border-2 border-dashed border-gray-700 text-center"><p class="font-semibold text-gray-500">${slot.label}</p><p class="text-sm text-gray-600">Emplacement libre</p></div>`;
        }
    }).join('');

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col" style="min-height: 450px;">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Mes Soumissions</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-black/20 z-20 flex items-center justify-center text-xl hover:bg-white/10">×</button>
        </header>
        <div class="flex-grow overflow-y-auto pr-2 space-y-3 scrollbar-hide min-h-0">${slotsHtml}</div>
    </div>`;
    
    showModal(modalContent);
}

async function openLockedValidationModal(performanceId) {
    const perfRef = doc(db, 'sbd_performances', performanceId);
    const perfDoc = await getDoc(perfRef);

    if (!perfDoc.exists()) {
        showToast("Cette performance est introuvable.", "error");
        return;
    }

    const perfData = perfDoc.data();
    const liftLabel = {squat:'Squat', bench:'Bench', deadlift:'Deadlift'}[perfData.liftType];

    // On réutilise la même modale d'upload, mais avec des champs désactivés
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-auto flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Valider une Performance</h2>
             <button class="close-modal w-8 h-8 rounded-full bg-black/20 z-20">×</button>
        </header>
        <div id="sbd-submit-form" class="space-y-4">
            <div class="grid grid-cols-2 gap-4">
                 <div>
                    <label class="font-semibold text-gray-400 text-sm">Mouvement</label>
                    <input type="text" class="input-glass mt-1 bg-black/30 text-gray-400" value="${liftLabel}" disabled>
                </div>
                <div>
                    <label class="font-semibold text-gray-400 text-sm">Poids à Valider</label>
                    <input type="text" class="input-glass mt-1 bg-black/30 text-gray-400" value="${perfData.weight} kg" disabled>
                </div>
            </div>
            <div>
                <label class="font-semibold text-gray-400 text-sm">Preuve Vidéo</label>
                <div class="mt-1 p-4 border-2 border-dashed border-gray-600 rounded-xl text-center cursor-pointer hover:border-violet-400" id="video-dropzone">
                    <i class="fa-solid fa-video text-3xl text-gray-500"></i>
                    <p id="video-file-label" class="text-sm text-gray-400 mt-2">Cliquez pour choisir votre preuve</p>
                </div>
                <input type="file" id="sbd-video-input" class="hidden" accept="video/*">
            </div>
        </div>
        <div id="upload-progress-container" class="text-center hidden"></div>
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-sbd-submit-btn" class="w-full btn-primary" disabled>Soumettre au Tribunal</button>
        </div>
        <button id="cancel-upload-btn" class="w-full mt-2 hidden">Annuler l'envoi</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        let selectedFile = null;
        const confirmBtn = modalWrapper.querySelector('#confirm-sbd-submit-btn');

        const validateForm = () => { confirmBtn.disabled = !selectedFile; };

        // La logique de gestion de fichier et d'upload est la même que dans `openSubmitSBDPerfModal`
        const handleFile = (file) => { /* ... (identique) ... */ };
        
        // La logique du bouton de confirmation est légèrement adaptée
        confirmBtn.addEventListener('click', async () => {
            // ... (logique pour afficher la barre de progression)
            try {
                const { promise } = uploadFile(selectedFile, (progress) => { /* ... */ });
                const { downloadURL, filePath } = await promise;
                
                // --- ACTION SPÉCIFIQUE ---
                // Au lieu de créer une nouvelle perf, on crée juste la validation
                // et on met à jour le statut de la performance existante.
                await addDoc(collection(db, 'video_validations'), {
                    sbdPerfId: performanceId,
                    userId: currentUserId,
                    videoUrl: downloadURL,
                    videoPath: filePath,
                    status: 'processing', // La vidéo va être compressée
                    judgements: []
                });
                
                // On change le statut de la perf pour qu'elle ne soit plus "en attente de preuve"
                await updateDoc(perfRef, { status: 'pending_tribunal_video' }); 
                // --- FIN DE L'ACTION ---

                closeModal();
            } catch (error) { /* ... (gestion d'erreur identique) */ }
        });

        // Les autres event listeners (dropzone, etc.) sont identiques
    });
}

function showVideoPreviewModal(videoUrl) {
    const modalContent = `
    <div class="relative w-full max-w-sm">
         <video id="preview-video-player" class="w-full rounded-2xl" src="${videoUrl}" autoplay loop muted playsinline></video>
         
         <button id="close-preview-btn" class="absolute top-4 right-4 w-8 h-8 rounded-full bg-black/60 z-20 flex items-center justify-center text-xl hover:bg-white/20">×</button>
         <button id="toggle-preview-sound" class="absolute bottom-4 left-4 w-10 h-10 rounded-full bg-black/50 text-white z-20 flex items-center justify-center"><i class="fa-solid fa-volume-xmark"></i></button>
    </div>
    `;

    const setupCallback = (modalWrapper) => {
        const videoElement = modalWrapper.querySelector('#preview-video-player');
        const soundBtn = modalWrapper.querySelector('#toggle-preview-sound');
        const closeBtn = modalWrapper.querySelector('#close-preview-btn');

        // Logique pour le bouton du son
        if (soundBtn && videoElement) {
            videoElement.muted = true; // On commence en muet pour l'autoplay
            soundBtn.onclick = (e) => {
                e.stopPropagation();
                videoElement.muted = !videoElement.muted;
                soundBtn.querySelector('i').className = `fa-solid ${videoElement.muted ? 'fa-volume-xmark' : 'fa-volume-high'}`;
            };
        }
        
        // Logique pour le bouton fermer
        if (closeBtn) {
            closeBtn.onclick = (e) => {
                e.stopPropagation(); // Empêche la fermeture des autres modales
                closeModal();
            };
        }
    };

    showModal(modalContent, setupCallback, null, true);
}

async function deletePendingPerformance(validationId) {
    if (!currentUserId) return false;
    const validationRef = doc(db, 'video_validations', validationId);
    try {
        const validationDoc = await getDoc(validationRef);
        if (!validationDoc.exists()) throw new Error("Vidéo déjà supprimée ou validée.");

        const { sbdPerfId, videoUrl, compressedVideoUrl } = validationDoc.data();
        const performanceRef = doc(db, 'sbd_performances', sbdPerfId);

        const batch = writeBatch(db);
        batch.delete(validationRef);
        batch.delete(performanceRef);
        await batch.commit();

        const storage = getStorage(app);
        const deletePromises = [];

        // === CORRECTION APPLIQUÉE ICI ===
        // On rend la suppression de chaque fichier indépendante et tolérante aux erreurs "Not Found".

        // Essayer de supprimer la vidéo originale
        if (videoUrl) {
            const originalRef = ref(storage, videoUrl);
            deletePromises.push(
                deleteObject(originalRef).catch(err => {
                    if (err.code === 'storage/object-not-found') {
                        console.log("Vidéo originale déjà supprimée par la fonction, c'est normal.");
                        return; // C'est une erreur attendue, on continue.
                    }
                    throw err; // C'est une autre erreur, on la propage.
                })
            );
        }

        // Essayer de supprimer la vidéo compressée
        if (compressedVideoUrl) {
            const compressedRef = ref(storage, compressedVideoUrl);
            deletePromises.push(deleteObject(compressedRef)); // Ici, une erreur serait inattendue.
        }
        
        // On attend que toutes les suppressions valides se terminent.
        await Promise.all(deletePromises);
        // ===================================

        showToast("Votre soumission a été supprimée.", "success");
        return true;
    } catch (error) {
        console.error("Erreur lors de la suppression de la vidéo :", error);
        showToast("Erreur lors de la suppression.", "error");
        return false;
    }
}

function openClanSearchModal() {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Rechercher une Équipe</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        <div class="flex-grow flex flex-col text-center min-h-0">
            <p class="text-sm text-gray-500 max-w-xs mx-auto mb-4 flex-shrink-0">Recherchez une équipe pour consulter son profil ou envoyer une demande d'adhésion.</p>
            <div class="w-full max-w-sm mx-auto space-y-4 flex-shrink-0">
                <div class="relative">
                    <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                    <input id="clan-search-input-modal" type="text" placeholder="Rechercher une équipe..." class="input-glass pl-12 w-full">
                </div>
            </div>
            <div id="clan-search-results-modal" class="w-full max-w-sm mx-auto mt-4 space-y-2 flex-grow overflow-y-auto pr-2 scrollbar-hide"></div>
        </div>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        const searchInput = modalWrapper.querySelector('#clan-search-input-modal');
        const resultsContainer = modalWrapper.querySelector('#clan-search-results-modal');
        
        const searchClans = async (searchQuery) => {
            const normalizedQuery = searchQuery.trim().toLowerCase();
            if (normalizedQuery.length < 3) {
                resultsContainer.innerHTML = '<p class="text-center text-gray-500">Entrez au moins 3 caractères.</p>';
                return;
            }
            resultsContainer.innerHTML = '<p class="text-center text-gray-400">Recherche...</p>';
            try {
                const q = query(collection(db, 'clans'), 
                    where('name_lowercase', '>=', normalizedQuery), 
                    where('name_lowercase', '<=', normalizedQuery + '\uf8ff'),
                    limit(10)
                );
                const querySnapshot = await getDocs(q);
                const clans = [];
                querySnapshot.forEach(doc => {
                    clans.push({ id: doc.id, ...doc.data() });
                });
                if (clans.length === 0) {
                    resultsContainer.innerHTML = '<p class="text-center text-gray-500">Aucune équipe trouvée.</p>';
                } else {
                    resultsContainer.innerHTML = clans.map(clan => {
                        const clanIcon = CLAN_ICONS.find(icon => icon.id === clan.iconId) || { icon: 'fa-question-circle' };
                        return `
                        <button data-action="view-public-clan" data-clan-id="${clan.id}" class="w-full text-left glass-card p-3 rounded-xl flex items-center gap-3">
                            <i class="fa-solid ${clanIcon.icon} text-2xl w-8 text-center" style="color: var(--theme-primary);"></i>
                            <div>
                                <p class="font-bold">${clan.name}</p>
                                <p class="text-sm text-gray-400">${clan.members.length}/10 membres</p>
                            </div>
                        </button>
                        `;
                    }).join('');
                }
            } catch (error) {
                console.error("Erreur de recherche de clan:", error);
                resultsContainer.innerHTML = '<p class="text-center text-red-500">Erreur de recherche.</p>';
            }
        };

        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            if (searchTimeout) clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => searchClans(e.target.value), 300);
        });

        modalWrapper.addEventListener('click', e => {
            const viewClanBtn = e.target.closest('[data-action="view-public-clan"]');
            if (viewClanBtn) {
                e.stopPropagation();
                const clanId = viewClanBtn.dataset.clanId;
                openPublicClanViewModal(clanId, true);
            }
        });
    });
}

// AJOUTEZ ces deux nouvelles fonctions pour gérer les événements spécifiques
function handleGymSearchEvents(e) {
    // Détection de la saisie dans la barre de recherche de ville
    const citySearchInput = document.getElementById('city-search-input');
    if (citySearchInput && e.type === 'input' && e.target === citySearchInput) {
        if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
        autocompleteTimeout = setTimeout(() => {
            if (autocompleteService) {
                // --- CORRECTION ---
                // On récupère le conteneur des résultats de la page principale
                const resultsContainer = document.getElementById('autocomplete-results-container');
                // On passe bien les DEUX arguments requis à la fonction
                searchCityPredictions(citySearchInput.value, resultsContainer);
            }
        }, 500);
        return;
    }
    
    // Clic sur une salle dans la liste des résultats
    const viewGymBtn = e.target.closest('[data-action="view-gym-on-map"]');
    if (viewGymBtn) {
        const { placeId, name, address } = viewGymBtn.dataset;
        openPublicGymViewModal(placeId, name, address);
        return;
    }
    
    // Clic sur une prédiction de ville
    const predictionButton = e.target.closest('[data-place-id]');
    if (predictionButton) {
        const placeId = predictionButton.dataset.placeId;
        findGymsFromPlaceId(placeId, predictionButton.textContent.trim());
        const resultsContainer = document.getElementById('autocomplete-results-container');
        if(resultsContainer) resultsContainer.innerHTML = '';
        return;
    }
}

function handleClanEvents(e) {
    // Recherche de clan par nom (pour la saisie)
    const clanSearchInput = document.getElementById('clan-search-input');
    if (clanSearchInput && e.type === 'input' && e.target === clanSearchInput) {
        if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
        autocompleteTimeout = setTimeout(() => searchClansByName(clanSearchInput.value), 300);
        return;
    }
    
    // Le reste des actions sont des clics
    if (e.type !== 'click') return;

    // --- LOGIQUE MANQUANTE AJOUTÉE ---
    const inviteBtn = e.target.closest('#invite-to-clan-btn');
    if (inviteBtn) {
        openInviteFriendsToClanModal();
        return;
    }
    const leaveClanBtn = e.target.closest('#leave-clan-btn');
    if (leaveClanBtn) {
        const clanData = state.currentClanData;
        if (clanData.chefUid === currentUserId && clanData.members.length > 1) {
            openPromoteNewChefModal();
        } else {
            openLeaveClanConfirmationModal();
        }
        return;
    }
    // --- FIN DE LA LOGIQUE AJOUTÉE ---

    // Clic pour voir un clan
    const viewClanBtn = e.target.closest('[data-action="view-public-clan"]');
    if (viewClanBtn) {
        openPublicClanViewModal(viewClanBtn.dataset.clanId);
        return;
    }
    // Créer un clan
    if (e.target.closest('#open-create-clan-modal')) {
        openCreateClanModal();
    }
}

function renderGymSearchView(message = '') {
    return `
    <div class="flex-grow flex flex-col text-center animate-fadeIn">
        ${message || '<p class="text-sm text-gray-500 max-w-xs mx-auto mb-4">Recherchez une ville pour trouver des salles près de chez vous.</p>'}
        <div class="w-full max-w-sm mx-auto space-y-4 relative">
            <div class="relative">
                <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                <input id="city-search-input" type="text" placeholder="Entrez une ville..." class="input-glass pl-12 w-full" autocomplete="off">
            </div>
            <div id="autocomplete-results-container" class="absolute top-full left-0 right-0 z-10 bg-[#23253A] border border-white/10 rounded-xl overflow-hidden max-h-60 overflow-y-auto"></div>
        </div>
        <div id="gym-results-list" class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide mt-6 pb-28"></div>
    </div>`;
}

function renderMyGymView(gymId) {
    const socialContentContainer = document.getElementById('social-content-container');
    if (!socialContentContainer) return;

    if (gymListener) gymListener();

    gymListener = onSnapshot(doc(db, 'gyms', gymId), async (gymSnap) => {
        if (!gymSnap.exists()) {
            socialContentContainer.innerHTML = renderGymSearchView('<p class="text-red-400 text-center">Erreur: Votre salle est introuvable.</p>');
            return;
        }

        const gymData = gymSnap.data();
        state.currentGymData = { id: gymId, ...gymData };

        const memberPromises = gymData.members.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
        const memberDocs = await Promise.all(memberPromises);
        let membersData = memberDocs.map(d => d.exists() ? d.data() : null).filter(Boolean);
        state.currentGymMembersData = membersData;

        // --- Logique de calcul (similaire à la vue Équipe) ---
        membersData.sort((a, b) => (RANK_POINTS_MAP[b.globalRank] || 0) - (RANK_POINTS_MAP[a.globalRank] || 0));
        const leader = membersData.length > 0 ? membersData[0] : null;
        const { averageRank, color: rankColor } = calculateAverageRank(membersData);
        
        const featuredMembers = membersData.slice(0, 3);
        const otherMembers = membersData.slice(3);

        // --- Carte pour le Leader ---
        let leaderCardHtml;
        if (leader) {
            // CORRECTION ICI : On utilise renderAvatar() qui gère déjà le cas de l'avatar par défaut
            leaderCardHtml = `
            <div class="flex-1 px-2">
                <p class="text-xs text-yellow-300 font-bold flex items-center justify-center gap-1.5"><i class="fa-solid fa-crown"></i> LEADER</p>
                <div class="flex items-center justify-center gap-2 mt-1">
                    <div class="w-6 h-6 rounded-full border border-yellow-400/50">${renderAvatar(leader.profilePicUrl, 'w-full h-full')}</div>
                    <p class="text-lg font-bold text-white truncate">${leader.name}</p>
                </div>
            </div>`;
        } else {
            leaderCardHtml = `<div class="flex-1 px-2"><p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-crown"></i> LEADER</p><p class="text-xl font-bold text-gray-500">Aucun</p></div>`;
        }

        // --- STRUCTURE HTML DE LA VUE (Refonte totale) ---
        const viewHtml = `
            <div class="flex-grow flex flex-col min-h-0 animate-fadeIn">

                <header class="h-64 flex-shrink-0 relative flex flex-col justify-center items-center text-center p-6 text-white">
                    <div class="absolute inset-0 flex items-center justify-center pointer-events-none -top-8">
                        <div class="w-64 h-64 rounded-full" style="background: radial-gradient(circle, var(--theme-shadow) 0%, transparent 70%);"></div>
                    </div>
                    
                    <div id="my-gym-map-bg" class="absolute inset-0 opacity-30"></div>

                    <div class="absolute inset-0 bg-gradient-to-t from-black/50 via-black/20 to-transparent"></div>

                    <div class="relative z-10">
                        <h1 class="text-4xl font-black tracking-tighter">${gymData.name}</h1>
                        <p class="text-gray-300 text-sm font-medium mt-1 max-w-xs truncate">${gymData.address}</p>
                    </div>
                </header>

                <div class="px-6 pb-4 flex-shrink-0 -mt-8 z-10">
                    <div class="glass-card p-3 rounded-xl flex items-center text-center">
                        <div class="flex-1 px-2 border-r border-white/10">
                            <p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-users text-xs"></i> Membres</p>
                            <p class="text-xl font-bold">${gymData.members.length}</p>
                        </div>
                        <div class="flex-[1.5] px-2 border-r border-white/10">
                            <p class="text-xs text-gray-400 font-semibold flex items-center justify-center gap-1.5"><i class="fa-solid fa-shield-halved text-xs"></i> Rang Moyen</p>
                            <p class="text-xl font-bold truncate" style="color: ${rankColor};">${averageRank}</p>
                        </div>
                        ${leaderCardHtml}
                    </div>
                </div>

                <div class="flex-grow overflow-y-auto scrollbar-hide px-6 space-y-4">
                    ${featuredMembers.length > 0 ? `<div><h3 class="font-bold text-lg mb-2">Membres à la une</h3><div class="space-y-3">${featuredMembers.map(member => renderUnifiedUserCard(member, 'gym-member')).join('')}</div></div>` : ''}
                    ${otherMembers.length > 0 ? `<div><h3 class="font-bold text-lg mb-2 pt-2">Tous les membres</h3><div class="space-y-3">${otherMembers.map(member => renderUnifiedUserCard(member, 'gym-member')).join('')}</div></div>` : ''}
                    ${membersData.length === 0 ? '<p class="text-gray-500 text-center italic py-8">Personne n\'est encore ici.</p>' : ''}
                </div>

                <footer class="flex-shrink-0 p-4 pt-3 mt-auto">
                     <div class="flex gap-2">
                        <button id="open-gym-search-modal-btn" class="secondary-btn flex-1"><i class="fa-solid fa-magnifying-glass mr-2"></i>Découvrir</button>
                        <button id="leave-gym-btn" class="secondary-btn flex-1 bg-red-500/10 !border-red-500 !text-red-400 hover:!bg-red-500/20">Quitter</button>
                    </div>
                </footer>
            </div>`;
        
        socialContentContainer.innerHTML = viewHtml;

        // On initialise la carte APRES que le HTML a été injecté dans la page
        setTimeout(() => {
    const mapDiv = document.getElementById('my-gym-map-bg');
    if (mapDiv && window.google) {
        const initializeMap = (location) => {
            const gymMap = new google.maps.Map(mapDiv, {
                center: location, zoom: 16, disableDefaultUI: true,
                styles: [{"elementType":"geometry","stylers":[{"color":"#242f3e"}]},{"elementType":"labels.text.stroke","stylers":[{"color":"#242f3e"}]},{"elementType":"labels.text.fill","stylers":[{"color":"#746855"}]},{"featureType":"administrative.locality","elementType":"labels.text.fill","stylers":[{"color":"#d59563"}]},{"featureType":"poi","stylers":[{"visibility":"off"}]},{"featureType":"road","elementType":"geometry","stylers":[{"color":"#38414e"}]},{"featureType":"road","elementType":"labels.icon","stylers":[{"visibility":"off"}]},{"featureType":"road.arterial","elementType":"labels","stylers":[{"visibility":"off"}]},{"featureType":"road.highway","elementType":"labels","stylers":[{"visibility":"off"}]},{"featureType":"road.local","stylers":[{"visibility":"off"}]},{"featureType":"transit","stylers":[{"visibility":"off"}]},{"featureType":"water","elementType":"geometry","stylers":[{"color":"#17263c"}]},{"featureType":"water","elementType":"labels.text.fill","stylers":[{"color":"#515c6d"}]},{"featureType":"water","elementType":"labels.text.stroke","stylers":[{"color":"#17263c"}]}
            ]
            });
            new google.maps.Marker({ position: location, map: gymMap, icon: { url: 'https://maps.google.com/mapfiles/ms/icons/purple-dot.png' } });
        };

        // OPTIMISATION : On utilise les coordonnées de Firestore si elles existent
        if (gymData.location && gymData.location.lat && gymData.location.lng) {
            initializeMap(gymData.location);
        } else {
            // Fallback (sécurité) : si les coordonnées manquent, on géocode quand même
            console.warn("Coordonnées manquantes pour la salle, géocodage de secours activé.");
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ 'address': gymData.address }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    initializeMap(location);
                    // On pourrait même ajouter ici une mise à jour de Firestore pour "auto-réparer"
                    updateDoc(doc(db, 'gyms', gymId), { location: { lat: location.lat(), lng: location.lng() } });
                }
            });
        }
    }
}, 150);
    });

    return `<div class="flex-grow flex items-center justify-center"><i class="fa-solid fa-spinner fa-spin text-4xl text-gray-500"></i></div>`;
}

function uploadFile(file, onProgress) {
    const storage = getStorage(app);
    // On garde le chemin du fichier dans une variable
    const filePath = `sbd_videos/${currentUserId}/${Date.now()}-${file.name}`;
    const storageRef = ref(storage, filePath);
    const uploadTask = uploadBytesResumable(storageRef, file);

    const promise = new Promise((resolve, reject) => {
        uploadTask.on('state_changed', 
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                if (onProgress) onProgress(progress);
            }, 
            (error) => {
                console.error("Erreur d'upload :", error);
                reject(error);
            }, 
            async () => {
                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                // On retourne maintenant un objet avec l'URL ET le chemin
                resolve({ downloadURL, filePath });
            }
        );
    });
    return { task: uploadTask, promise: promise };
}

function openGymSearchModal() {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Découvrir une Salle</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">×</button>
        </header>
        <div class="flex-shrink-0">
            <p class="text-sm text-gray-500 max-w-xs mx-auto mb-4 text-center">Recherchez une ville pour trouver des salles de sport.</p>
            <div class="w-full max-w-sm mx-auto space-y-4 relative">
                <div class="relative">
                    <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                    <input id="city-search-input-modal" type="text" placeholder="Entrez une ville..." class="input-glass pl-12 w-full" autocomplete="off">
                </div>
                <div id="autocomplete-results-container-modal" class="absolute top-full left-0 right-0 z-20 bg-[#23253A] border border-white/10 rounded-xl overflow-hidden max-h-60 overflow-y-auto"></div>
            </div>
        </div>
        <div id="gym-results-list-modal" class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide mt-6 min-h-0">
            <p class="text-center text-gray-500 pt-8">Les résultats s'afficheront ici.</p>
        </div>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        const citySearchInput = modalWrapper.querySelector('#city-search-input-modal');
        const autocompleteResultsContainer = modalWrapper.querySelector('#autocomplete-results-container-modal');
        const gymResultsList = modalWrapper.querySelector('#gym-results-list-modal');
        let autocompleteTimeout;

        function renderGymList(places, isFromCache = false) {
            if (!places || places.length === 0) {
                gymResultsList.innerHTML = `<p class="text-center text-gray-500 pt-8">Aucune salle trouvée dans cette zone.</p>`;
                return;
            }
            gymResultsList.innerHTML = places.map(place => {
                // **CORRECTION: Check if data is from cache to access properties correctly**
                const lat = isFromCache ? place.location.lat : place.location.lat();
                const lng = isFromCache ? place.location.lng : place.location.lng();
                
                return `
                <button class="w-full text-left glass-card p-3 rounded-xl hover:bg-white/10 transition-colors"
                    data-action="view-gym-on-map"
                    data-place-id="${place.id}"
                    data-name="${place.displayName}"
                    data-address="${place.formattedAddress}"
                    data-lat="${lat}"
                    data-lng="${lng}">
                    <p class="font-bold">${place.displayName}</p>
                    <p class="text-sm text-gray-400">${place.formattedAddress || 'Adresse non disponible'}</p>
                </button>
                `;
            }).join('');
        }

        async function findGymsFromPlaceId(placeId, placeDescription) {
            if (!placeId) return;
            
            gymResultsList.innerHTML = `<p class="text-center text-gray-400 pt-8">Recherche des salles...</p>`;
            const cacheRef = doc(db, 'gymCache', placeId);

            try {
                const cacheSnap = await getDoc(cacheRef);

                if (cacheSnap.exists()) {
                    const cacheData = cacheSnap.data();
                    let lastUpdatedTimestamp = cacheData.lastUpdated;

                    if (lastUpdatedTimestamp && typeof lastUpdatedTimestamp.toDate !== 'function') {
                        lastUpdatedTimestamp = new Timestamp(lastUpdatedTimestamp.seconds, lastUpdatedTimestamp.nanoseconds);
                    }
                    
                    const ageInDays = (new Date() - lastUpdatedTimestamp.toDate()) / (1000 * 60 * 60 * 24);

                    if (ageInDays < 30) {
            console.log("✅ Résultats servis depuis le cache Firestore !");
            renderGymList(cacheData.gyms, true); // <-- Pass 'true' for cache
            return;
        }
                }

                console.log("Cache vide ou périmé. Appel à l'API Google Places...");
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ 'placeId': placeId }, async (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        const request = {
                            fields: ['displayName', 'location', 'formattedAddress', 'id'],
                            locationRestriction: { center: location, radius: 5000 },
                            includedPrimaryTypes: ['gym'],
                        };
                        const { places } = await google.maps.places.Place.searchNearby(request);
                        
                        const gymsToCache = places.map(place => ({
                            id: place.id,
                            displayName: place.displayName,
                            formattedAddress: place.formattedAddress,
                            location: { lat: place.location.lat(), lng: place.location.lng() }
                        }));
                        await setDoc(cacheRef, {
                            cityName: placeDescription,
                            gyms: gymsToCache,
                            lastUpdated: serverTimestamp()
                        });
                        console.log(`Résultats pour "${placeDescription}" mis en cache.`);

                        renderGymList(places, false); // Vient de l'API
                    } else {
                        throw new Error("Geocode a échoué: " + status);
                    }
                });
            } catch (error) {
                console.error("Erreur dans findGymsFromPlaceId:", error);
                gymResultsList.innerHTML = `<p class="text-center text-red-500 pt-8">Une erreur est survenue.</p>`;
            }
        }
        
        // Les écouteurs d'événements restent identiques
        citySearchInput.addEventListener('input', (e) => {
        if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
        
        autocompleteTimeout = setTimeout(() => {
            // On appelle notre fonction globale flexible en lui passant le conteneur de la modale
            searchCityPredictions(e.target.value, autocompleteResultsContainer);
        }, 300);
    });

        autocompleteResultsContainer.addEventListener('click', (e) => {
            e.stopPropagation();
        const predictionButton = e.target.closest('[data-place-id]');
        if (predictionButton) {
            const { placeId, description } = predictionButton.dataset;
            // On utilise la fonction findGymsFromPlaceId locale à la modale
            findGymsFromPlaceId(placeId, description);
            autocompleteResultsContainer.innerHTML = '';
            citySearchInput.value = description;
        }
    });
    
    modalWrapper.addEventListener('click', e => {
        // ... (Le reste de votre logique de clic pour 'view-gym-on-map' reste ici)
        const viewGymBtn = e.target.closest('[data-action="view-gym-on-map"]');
        if (viewGymBtn) {
            e.stopPropagation();
            const { placeId, name, address } = viewGymBtn.dataset;
            openPublicGymViewModal(placeId, name, address, true);
        }
    });
});
}

async function renderSocialContent() {
    const container = document.getElementById('social-content-container');
    if (!container) return;

    container.innerHTML = `<div class="flex-grow flex items-center justify-center"><i class="fa-solid fa-spinner fa-spin text-4xl text-gray-500"></i></div>`;

    let contentHtml = '';
    if (state.social.activeTab === 'gym') {
        contentHtml = state.userProfile.gymId
            ? await renderMyGymView(state.userProfile.gymId)
            : renderGymSearchView();
    } else if (state.social.activeTab === 'clan') { // On utilise else if
        contentHtml = state.userProfile.clanId
            ? await renderMyClanView(state.userProfile.clanId)
            : renderClanSearchView();
    } else if (state.social.activeTab === 'competition') { // On ajoute la nouvelle condition
        // On appelle directement le template de la page Compétition
        contentHtml = templates.Competition(); 
    }

    container.innerHTML = contentHtml;

    // Le reste du code pour attacher les écouteurs d'événements est inchangé
    const citySearchInput = document.getElementById('city-search-input');
    if (citySearchInput) {
        citySearchInput.addEventListener('input', handleGymSearchEvents);
    }
    const clanSearchInput = document.getElementById('clan-search-input');
    if (clanSearchInput) {
        clanSearchInput.addEventListener('input', handleClanEvents);
    }
}

async function openInviteFriendsToClanModal() {
    const clanData = state.currentClanData;
    if (!clanData) return;

    const friendUids = state.friends.accepted;
    if (friendUids.length === 0) {
        showToast("Vous n'avez aucun ami à inviter.", "info");
        return;
    }

    const friendPromises = friendUids.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
    const friendDocs = await Promise.all(friendPromises);
    const friendsData = friendDocs.map(doc => doc.exists() ? doc.data() : null).filter(Boolean);

    // --- CORRECTION CLÉ APPLIQUÉE ICI ---
    const invitableFriends = friendsData.filter(friend => {
        // Un ami n'est pas invitable si :
        // 1. Il est DÉJÀ dans notre équipe (la vérification la plus fiable).
        const alreadyInOurClan = clanData.members.includes(friend.uid);
        // 2. Il est dans une autre équipe.
        const inAnotherClan = !!friend.clanId;
        // 3. Une invitation est déjà en attente pour lui.
        const alreadyInvited = clanData.pendingInvites && clanData.pendingInvites[friend.uid];
        
        return !alreadyInOurClan && !inAnotherClan && !alreadyInvited;
    });
    // --- FIN DE LA CORRECTION ---

    let friendsListHtml;
    if (invitableFriends.length === 0) {
        friendsListHtml = `<p class="text-center text-gray-500 py-8">Tous vos amis sont déjà dans une équipe ou ont été invités.</p>`;
    } else {
        friendsListHtml = invitableFriends.map(friend => {
            // On récupère toutes les données cosmétiques pour un affichage complet
            const equippedBorder = BORDERS_DATABASE.find(b => b.id === friend.equipped?.border) || { style: '' };
            const equippedTitle = TITLES_DATABASE.find(t => t.id === friend.equipped?.title) || { name: 'Débutant', rarity: 'Commun' };
            const titleClass = equippedTitle.color ? equippedTitle.color : `rarity-${normalizeString(equippedTitle.rarity)}-text`;

            return `
            <div class="glass-card p-3 rounded-xl flex items-center justify-between">
                <div class="flex items-center gap-3 min-w-0">
                    <div class="w-12 h-12 rounded-full flex-shrink-0" style="${equippedBorder.style}">
                        <div class="w-full h-full rounded-full" style="background-color: rgb(29, 31, 43);">
                            ${renderAvatar(friend.profilePicUrl, "w-full h-full")}
                        </div>
                    </div>
                    <div class="min-w-0">
                        <p class="font-bold truncate">${friend.name}</p>
                        <p class="text-sm truncate ${titleClass}" title="${equippedTitle.name}">${equippedTitle.name}</p>
                    </div>
                </div>
                <div class="flex items-center flex-shrink-0">
                    <div class="w-12 h-12 ml-2 mr-2" title="${friend.globalRank || 'Non classé'}">
                        ${getRankBadgeSVG(friend.globalRank || 'Novice III', '48px')}
                    </div>
                    <button data-action="send-clan-invite" data-friend-id="${friend.uid}" class="btn-primary text-sm !py-2 !px-4">Inviter</button>
                </div>
            </div>
            `;
        }).join('');
    }

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">

        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Inviter des amis</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        <div class="flex-grow overflow-y-auto pr-2 space-y-3 scrollbar-hide min-h-0">
            ${friendsListHtml}
        </div>
    </div>`;
    
    showModal(modalContent);
}



function toggleClanMusic() {
    const player = document.getElementById('clan-music-player');
    // On cible le bouton de lecture/pause. Assurez-vous qu'il a bien cet ID.
    const button = document.getElementById('toggle-clan-music-btn'); 
    if (!player || !button) return;

    // On cible l'image à l'intérieur du bouton
    const pochette = button.querySelector('img'); 
    if (!pochette) return; // Si c'est l'icône "muet", on ne fait rien

    if (player.paused) {
        player.play().then(() => {
            // La musique joue : on ajoute l'animation de rotation à l'image
            pochette.classList.add('spinning-vinyl');
            pochette.classList.remove('opacity-75'); // On remet l'opacité normale
        }).catch(e => {
            console.error("Erreur de lecture audio :", e);
            showToast("La lecture automatique a été bloquée par le navigateur.", "error");
        });
    } else {
        player.pause();
        // La musique est en pause : on retire l'animation et on baisse l'opacité
        pochette.classList.remove('spinning-vinyl');
        pochette.classList.add('opacity-75');
    }
}

async function openFriendOptionsMenu(friendId, buttonElement) {
    document.getElementById('friend-options-popover')?.remove();
    const rect = buttonElement.getBoundingClientRect();
    const popover = document.createElement('div');
    popover.id = 'friend-options-popover';
    popover.className = 'glass-card p-2 rounded-lg w-52';

    // --- LOGIQUE D'INVITATION AJOUTÉE ICI ---
    const friendDoc = await getDoc(doc(db, 'publicProfiles', friendId));
    let inviteButtonHtml = '';
    
    // On vérifie que l'utilisateur est bien dans une équipe pour proposer l'invitation
    if (state.userProfile.clanId && friendDoc.exists()) {
        const friendData = friendDoc.data();
        const clanData = state.currentClanData;

        // Condition 1 : L'ami est déjà dans notre équipe.
        if (clanData.members.includes(friendId)) {
            inviteButtonHtml = `<button class="w-full text-left p-2 rounded-md font-semibold flex items-center gap-3 text-gray-500 cursor-not-allowed" disabled><i class="fa-solid fa-check w-4 text-center"></i>Déjà membre</button>`;
        } 
        // Condition 2 : L'ami est dans une autre équipe.
        else if (friendData.clanId) {
             inviteButtonHtml = `<button class="w-full text-left p-2 rounded-md font-semibold flex items-center gap-3 text-gray-500 cursor-not-allowed" disabled><i class="fa-solid fa-users w-4 text-center"></i>Dans une équipe</button>`;
        } 
        // Condition 3 : Une invitation a déjà été envoyée.
        else if (clanData.pendingInvites && clanData.pendingInvites[friendId]) {
            inviteButtonHtml = `<button class="w-full text-left p-2 rounded-md font-semibold flex items-center gap-3 text-gray-500 cursor-not-allowed" disabled><i class="fa-solid fa-paper-plane w-4 text-center"></i>Invitation envoyée</button>`;
        } 
        // Cas par défaut : L'ami est invitable.
        else {
            inviteButtonHtml = `
            <button data-action="invite-friend-to-clan" data-uid="${friendId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3 text-violet-400">
                <i class="fa-solid fa-user-plus w-4 text-center"></i>Inviter dans l'équipe
            </button>`;
        }
    }
    // --- FIN DE LA LOGIQUE D'INVITATION ---

    // On insère le bouton d'invitation (conditionnel) au-dessus des autres options.
    popover.innerHTML = `
        ${inviteButtonHtml}
        <button data-action="confirm-remove-friend" data-uid="${friendId}" class="w-full text-left p-2 rounded-md hover:bg-red-500/20 text-red-400 font-semibold flex items-center gap-3">
            <i class="fa-solid fa-user-slash w-4 text-center"></i>
            Supprimer l'ami
        </button>
        <button data-action="report-user" data-uid="${friendId}" class="w-full text-left p-2 rounded-md hover:bg-white/10 font-semibold flex items-center gap-3">
            <i class="fa-solid fa-flag w-4 text-center text-gray-400"></i>
            Signaler
        </button>
    `;

    // Le reste de la fonction pour afficher le popover est inchangé.
    popover.style.top = `${rect.bottom + 5}px`;
    popover.style.right = `${window.innerWidth - rect.right}px`;
    document.body.appendChild(popover);

    setTimeout(() => {
        const closeHandler = (e) => {
            if (!popover.contains(e.target) && !buttonElement.contains(e.target)) {
                popover.remove();
                document.removeEventListener('click', closeHandler, true);
            }
        };
        document.addEventListener('click', closeHandler, true);
    }, 0);
}

// --- NOUVEAU ---
async function openKickConfirmationModal(memberId) {
    const memberDoc = await getDoc(doc(db, 'publicProfiles', memberId));
    if (!memberDoc.exists()) return;
    const memberName = memberDoc.data().name;

    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Exclure ${memberName} ?</h2>
        <p class="text-gray-400 mb-6">Cette personne sera retirée de l'équipe. Cette action est irréversible.</p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-kick" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Exclure</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#confirm-kick').onclick = async () => {
            closeModal();
            await kickClanMember(memberId);
        };
    });
}

// --- NOUVEAU ---
async function kickClanMember(memberId) {
    const clanId = state.userProfile.clanId;
    if (!currentUserId || !clanId) return false;

    const clanRef = doc(db, 'clans', clanId);
    const memberUserRef = doc(db, 'users', memberId);

    try {
        await runTransaction(db, async (transaction) => {
            transaction.update(clanRef, { members: arrayRemove(memberId) });
            transaction.update(memberUserRef, { 'userProfile.clanId': null });
        });
        showToast("Membre exclu.", "success");
        return true;
    } catch (error) {
        showToast("Erreur lors de l'exclusion.", "error");
        return false;
    }
}

// --- NOUVEAU ---
async function openPromoteConfirmationModal(memberId) {
    const memberDoc = await getDoc(doc(db, 'publicProfiles', memberId));
    if (!memberDoc.exists()) return;
    const memberName = memberDoc.data().name;

    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Promouvoir ${memberName} ?</h2>
        <p class="text-gray-400 mb-6">Cette personne deviendra le nouveau chef et vous deviendrez un membre normal.</p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-promote" class="w-full bg-yellow-600 text-white p-3 rounded-lg font-bold">Promouvoir</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#confirm-promote').onclick = async () => {
            closeModal();
            await promoteClanMember(memberId);
        };
    });
}

// --- NOUVEAU ---
async function promoteClanMember(newChefId) {
    const clanId = state.userProfile.clanId;
    if (!currentUserId || !clanId) return false;
    const clanRef = doc(db, 'clans', clanId);
    try {
        await updateDoc(clanRef, { chefUid: newChefId });
        showToast("Nouveau chef promu !", "success");
        return true;
    } catch (error) {
        showToast("Erreur lors de la promotion.", "error");
        return false;
    }
}

async function searchClansByName(nameQuery) {
    const normalizedQuery = nameQuery.trim().toLowerCase();
    const resultsContainer = document.getElementById('clan-search-results');

    if (normalizedQuery.length < 3) {
        resultsContainer.innerHTML = '';
        return;
    }
    
    resultsContainer.innerHTML = '<p class="text-center text-gray-400">Recherche...</p>';

    try {
        const q = query(collection(db, 'clans'), 
            where('name_lowercase', '>=', normalizedQuery), 
            where('name_lowercase', '<=', normalizedQuery + '\uf8ff'),
            limit(10)
        );

        const querySnapshot = await getDocs(q);
        const clans = [];
        querySnapshot.forEach(doc => {
            clans.push({ id: doc.id, ...doc.data() });
        });

        renderClanSearchResults(clans);
    } catch (error) {
        console.error("Erreur de recherche de clan:", error);
        resultsContainer.innerHTML = '<p class="text-center text-red-500">Erreur de recherche.</p>';
    }
}

function renderClanSearchResults(clans) {
    const resultsContainer = document.getElementById('clan-search-results');
    if (clans.length === 0) {
        resultsContainer.innerHTML = '<p class="text-center text-gray-500">Aucune équipe trouvée.</p>';
        return;
    }

    resultsContainer.innerHTML = clans.map(clan => {
        const clanIcon = CLAN_ICONS.find(icon => icon.id === clan.iconId) || { icon: 'fa-question-circle' };
        // NOTE: On ajoutera la fonction openPublicClanViewModal plus tard
        return `
        <button data-action="view-public-clan" data-clan-id="${clan.id}" class="w-full text-left glass-card p-3 rounded-xl flex items-center gap-3">
            <i class="fa-solid ${clanIcon.icon} text-2xl w-8 text-center" style="color: var(--theme-primary);"></i>
            <div>
                <p class="font-bold">${clan.name}</p>
                <p class="text-sm text-gray-400">${clan.members.length}/10 membres</p>
            </div>
        </button>
        `;
    }).join('');
}
               
        function setupCalendarDragAndDrop() {
            const storyContainer = document.getElementById('story-container');
            if (!storyContainer) return;

            // On nettoie l'ancien observateur s'il existe, pour éviter les bugs
            if (lastItemObserver) {
                lastItemObserver.disconnect();
            }

            const scrollLeftBtn = document.getElementById('scroll-story-left-btn');
            const scrollRightBtn = document.getElementById('scroll-story-right-btn');

            // --- GESTION FLÈCHE GAUCHE (inchangée) ---
            const updateLeftButton = () => {
                if (storyContainer.scrollLeft < 1) {
                    scrollLeftBtn.style.opacity = '0';
                    scrollLeftBtn.style.pointerEvents = 'none';
                } else {
                    scrollLeftBtn.style.opacity = '1';
                    scrollLeftBtn.style.pointerEvents = 'auto';
                }
            };
            storyContainer.addEventListener('scroll', updateLeftButton, { passive: true });
            updateLeftButton();


            // --- GESTION FLÈCHE DROITE (nouvelle méthode "Observer") ---
            const lastAsset = storyContainer.querySelector('.draggable:last-child');
            
            if (lastAsset) {
                // On crée un "observateur" qui va surveiller le dernier élément
                lastItemObserver = new IntersectionObserver((entries) => {
                    const lastEntry = entries[0];
                    // Si le dernier élément est visible à l'écran...
                    if (lastEntry.isIntersecting) {
                        // ... on cache la flèche.
                        scrollRightBtn.style.opacity = '0';
                        scrollRightBtn.style.pointerEvents = 'none';
                    } else {
                        // Sinon, on la montre.
                        scrollRightBtn.style.opacity = '1';
                        scrollRightBtn.style.pointerEvents = 'auto';
                    }
                }, { 
                    root: storyContainer, // On observe à l'intérieur du conteneur
                    threshold: 0.95 // Se déclenche quand 95% de l'élément est visible
                });

                // On dit à l'observateur de commencer à surveiller le dernier élément
                lastItemObserver.observe(lastAsset);
            } else {
                 // S'il n'y a pas d'éléments, on s'assure que la flèche est cachée
                 scrollRightBtn.style.opacity = '0';
                 scrollRightBtn.style.pointerEvents = 'none';
            }

            // --- GESTION DRAG & DROP (inchangée) ---
            document.querySelectorAll('.draggable').forEach(el => {
                // ... (le reste de votre fonction drag & drop reste ici, inchangé) ...
                el.ondragstart = e => {
                    const target = e.currentTarget; 
                    e.dataTransfer.setData('text/plain', `${target.dataset.itemId},${target.dataset.itemType}`);
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => {
                        if (target) target.classList.add('dragging');
                    }, 0);
                };
                el.ondragend = e => {
                    if (e.currentTarget) e.currentTarget.classList.remove('dragging');
                };
            });
            document.querySelectorAll('#calendar-grid .calendar-day:not(.past-day)').forEach(day => {
                day.ondragover = e => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; day.classList.add('drag-over'); };
                day.ondragleave = e => day.classList.remove('drag-over');
                day.ondrop = e => {
                    e.preventDefault();
                    day.classList.remove('drag-over');
                    const [itemId, itemType] = e.dataTransfer.getData('text/plain').split(',');
                    if (itemId && itemType && day.dataset.date) openPlanModal(itemId, day.dataset.date, itemType);
                };
            });
        }

        // AJOUTEZ CETTE NOUVELLE FONCTION
function setupEditorDragAndDrop(containerId, itemsArray) {
    const container = document.getElementById(containerId);
    if (!container) return;

    let draggedElementId = null;

    container.addEventListener('dragstart', e => {
        const target = e.target.closest('.draggable');
        if (target) {
            draggedElementId = target.dataset.id;
            // Un petit délai pour permettre au navigateur de "capturer" l'élément
            setTimeout(() => target.classList.add('dragging'), 0);
        }
    });

    container.addEventListener('dragend', e => {
        const target = e.target.closest('.draggable');
        if (target) {
            target.classList.remove('dragging');
        }
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        const draggables = [...container.querySelectorAll('.draggable:not(.dragging)')];
        
        draggables.forEach(draggable => draggable.classList.remove('drag-over'));

        if (afterElement == null) {
            // Pas d'élément en dessous, on ne met pas de marqueur
        } else {
            afterElement.classList.add('drag-over');
        }
    });

    container.addEventListener('drop', e => {
        e.preventDefault();
        const fromIndex = itemsArray.findIndex(item => item.id === draggedElementId);
        if (fromIndex === -1) return;

        const afterElement = getDragAfterElement(container, e.clientY);
        const toId = afterElement ? afterElement.dataset.id : null;
        const toIndex = toId ? itemsArray.findIndex(item => item.id === toId) : itemsArray.length;

        // Réorganisation de l'array
        const [movedItem] = itemsArray.splice(fromIndex, 1);
        
        // Ajustement de l'index si on déplace vers le bas
        const adjustedToIndex = fromIndex < toIndex ? toIndex -1 : toIndex;
        itemsArray.splice(adjustedToIndex, 0, movedItem);

        // Nettoyage et re-render
        container.querySelector('.drag-over')?.classList.remove('drag-over');
        draggedElementId = null;
        render();
    });

    function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
}
        
        // --- EVENT LISTENERS & DOM MANIPULATION ---
        const mainClickHandler = async e => {
    const userOptionsMenuBtn = e.target.closest('[data-action="open-user-options-menu"]');
    if (userOptionsMenuBtn) {
        openUnifiedUserOptionsMenu(
            userOptionsMenuBtn.dataset.uid, 
            userOptionsMenuBtn,
            userOptionsMenuBtn.dataset.context
        );
        return;
    }
    const isClickInsideSearch = e.target.closest('#city-search-input, #autocomplete-results-container');
    if (!isClickInsideSearch) {
        const resultsContainer = document.getElementById('autocomplete-results-container');
        if (resultsContainer) resultsContainer.innerHTML = '';
    }
    closeAllPopovers();
    const openClanSettingsBtn = e.target.closest('#open-clan-settings-btn');
    if (openClanSettingsBtn) {
        openClanSettingsModal();
        return;
    }
    const reportUserBtn = e.target.closest('[data-action="report-user"]');
    if (reportUserBtn) {
        closeAllPopovers();
        openReportUserModal(reportUserBtn.dataset.uid);
        return;
    }
    const acceptClanInviteBtn = e.target.closest('[data-action="accept-clan-invite"]');
    if (acceptClanInviteBtn) {
        const { clanId, messageId } = acceptClanInviteBtn.dataset;
        acceptClanInviteBtn.closest('.glass-card').style.opacity = '0.5';
        acceptClanInvite(clanId, messageId);
        return;
    }

    const declineClanInviteBtn = e.target.closest('[data-action="decline-clan-invite"]');
    if (declineClanInviteBtn) {
        const { clanId, messageId } = declineClanInviteBtn.dataset;
        declineClanInviteBtn.closest('.glass-card').style.opacity = '0.5';
        declineClanInvite(clanId, messageId);
        return;
    }
    const inviteFriendToClanBtn = e.target.closest('[data-action="invite-friend-to-clan"]');
    if (inviteFriendToClanBtn) {
        closeAllPopovers();
        sendClanInvite(inviteFriendToClanBtn.dataset.uid);
        return;
    }
    const clanMemberOptionsBtn = e.target.closest('[data-action="open-clan-member-options"]');
    if (clanMemberOptionsBtn) {
        openClanMemberOptionsMenu(clanMemberOptionsBtn.dataset.uid, clanMemberOptionsBtn);
        return;
    }
    const kickMemberBtn = e.target.closest('[data-action="kick-clan-member"]');
    if (kickMemberBtn) {
        closeAllPopovers();
        openKickConfirmationModal(kickMemberBtn.dataset.uid);
        return;
    }
    const promoteMemberBtn = e.target.closest('[data-action="promote-clan-member"]');
    if (promoteMemberBtn) {
        closeAllPopovers();
        openPromoteConfirmationModal(promoteMemberBtn.dataset.uid);
        return;
    }
    const sendInviteBtn = e.target.closest('[data-action="send-clan-invite"]');
    if (sendInviteBtn) {
        sendInviteBtn.disabled = true;
        sendInviteBtn.textContent = 'Invité';
        sendInviteBtn.classList.remove('btn-primary');
        sendInviteBtn.classList.add('glass-card');
        sendClanInvite(sendInviteBtn.dataset.friendId);
        return;
    }
    const promoteBtn = e.target.closest('[data-action="promote-and-leave"]');
    if (promoteBtn) {
        closeModal();
        const newChefId = promoteBtn.dataset.newChefId;
        setTimeout(() => {
            openFinalPromotionConfirmationModal(newChefId);
        }, 50);
        return;
    }
    const dropdownButton = e.target.closest('.custom-select-button, .shop-sort-button');
    const isClickInsideActiveDropdownOptions = e.target.closest('.custom-select-options.active, .shop-sort-options.active');
    if (dropdownButton) {
        e.stopPropagation();
        const parentContainer = dropdownButton.closest('.custom-select-container');
        const optionsContainer = parentContainer.querySelector('.custom-select-options, .shop-sort-options');
        const wasActive = optionsContainer.classList.contains('active');
        
        closeAllDropdowns();
        closeAllPopovers();
        
        if (!wasActive) {
            optionsContainer.classList.add('active');
            dropdownButton.classList.add('active');
        }
        return;
    }
    if (!isClickInsideActiveDropdownOptions) {
        closeAllDropdowns();
    }

    const confirmRemoveBtn = e.target.closest('[data-action="confirm-remove-friend"]');
    if (confirmRemoveBtn) {
        closeAllPopovers();
        openRemoveFriendConfirmationModal(confirmRemoveBtn.dataset.uid);
        return;
    }
    
    if (e.target.closest('#open-create-clan-modal')) {
        openCreateClanModal();
    }

    // --- CORRECTION DÉFINITIVE APPLIQUÉE ICI ---
    // On ne cible que les boutons AVEC un data-action à l'intérieur de la modale
    const sbdVaultButton = e.target.closest('#sbd-vault-modal button[data-action]');
    if (sbdVaultButton) {
        // On appelle la fonction qui gère les actions spécifiques (œil, corbeille, etc.)
        handleSbdVaultEvents(e);
        // Et on s'arrête là pour ne pas interférer avec d'autres écouteurs.
        return; 
    }
    // --- FIN DE LA CORRECTION ---

    const switcher = e.target.closest('#flow-switcher');
    if (switcher) {
        if (state.isAnimating) return;
        
        stopClanMusic();

        state.isAnimating = true;

        const appContainer = document.getElementById('app-container');
        const overlay = document.getElementById('page-transition-overlay');
        const iconWrapper = document.getElementById('page-transition-icon-wrapper');
        const icon = document.getElementById('page-transition-icon');
        const newActiveSide = state.activeSide === 'workout' ? 'nutrition' : 'workout';
        
        switcher.classList.add('is-switching');
        overlay.classList.remove('color-workout', 'color-nutrition');
        overlay.classList.add(newActiveSide === 'workout' ? 'color-nutrition' : 'color-workout');
        icon.className = `fa-solid ${newActiveSide === 'workout' ? 'fa-utensils' : 'fa-dumbbell'} page-transition-icon`;
        
        overlay.style.transition = 'none';
        overlay.style.transform = 'translateY(100%)';
        overlay.offsetHeight; 
        overlay.style.transition = '';
        
        requestAnimationFrame(() => {
            overlay.classList.add('active');
            overlay.style.transform = 'translateY(0)';
            iconWrapper.classList.add('active');
        });

        setTimeout(() => {
            state.activeSide = newActiveSide;
            state.activePage = 'Accueil';
            render();
            iconWrapper.classList.remove('active');
            overlay.style.transform = 'translateY(-100%)';

            setTimeout(() => {
                switcher.classList.remove('is-switching');
                overlay.classList.remove('active');
                state.isAnimating = false;
            }, 300);
        }, 200); 
        
        return;
    }

    const navElement = e.target.closest('[data-navigate]');
    if (navElement) {
        e.stopPropagation();
        const targetPage = navElement.dataset.navigate;
        const itemId = navElement.dataset.id;
        
        if (targetPage === 'WorkoutEditor') {
            const originalWorkout = state.workouts.find(w => w.id === itemId);
            if (originalWorkout) state.editingWorkout = JSON.parse(JSON.stringify(originalWorkout));
            navigate(targetPage, { id: itemId });
        } else if (targetPage === 'MealEditor') {
            const mealToEdit = state.meals.find(m => m.id === itemId);
            if (mealToEdit) {
               state.editingMeal = JSON.parse(JSON.stringify(mealToEdit));
               state.editingMeal.isQuickAdd = false;
            }
            navigate(targetPage, { id: itemId });
        } else {
            navigate(targetPage);
        }
        return;
    }

    const filterButton = e.target.closest('[data-filter]');
    if (filterButton) {
        state.viewFilter = filterButton.dataset.filter;
        render();
        return;
    }

    switch(state.activePage) {
        case 'Onboarding':    handleOnboardingEvents(e); break;
        case 'Login':         handleLoginEvents(e); break;
        case 'Accueil':       handleAccueilEvents(e); break;
        case 'Workouts':      handleWorkoutsEvents(e); break;
        case 'Repas':         handleRepasEvents(e); break;
        case 'WorkoutEditor': handleWorkoutEditorEvents(e); break;
        case 'MealEditor':    handleMealEditorEvents(e); break;
        case 'Shop':          handleShopEvents(e); break;
        case 'WorkoutPlayer': handleWorkoutPlayerEvents(e); break;
        case 'Calendrier':    handleCalendarEvents(e); break;
        case 'Dashboard':     handleDashboardEvents(e); break;
        case 'Stats':         handleStatsEvents(e); break;
        case 'Profil':        handleProfilEvents(e); break;
        case 'CreatorSpace':  handleCreatorSpaceEvents(e); break;
        case 'ProgramStudio': handleProgramStudioEvents(e); break;
        case 'Achievements':  handleAchievementsEvents(e); break;
        case 'Quêtes':        handleQuestsEvents(e); break;
        case 'Social':        handleSocialEvents(e); break;
        case 'SearchUsers':   handleSearchUsersEvents(e); break;
        case 'Inbox':         handleInboxEvents(e); break;
        case 'Tribunal':      handleTribunalEvents(e); break;
        case 'Leaderboard': handleLeaderboardEvents(e); break;
    }
};

async function loadNextJuryVideo() {
    // On cible uniquement le conteneur central
    const container = document.getElementById('jury-card-container');
    if (!container || isJuryVideoLoading) return;

    isJuryVideoLoading = true;
    // L'arrière-plan de la page est maintenant transparent, laissant voir le thème
    container.innerHTML = `<i class="fa-solid fa-spinner fa-spin text-4xl text-white"></i>`;
    container.style.backgroundColor = 'transparent'; 

    try {
        const q = query(
            collection(db, 'video_validations'),
            where('status', '==', 'pending'),
            orderBy('sbdPerfId'),
            limit(10)
        );

        const querySnapshot = await getDocs(q);
        
        const videos = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        const videoData = videos.find(video => {
            if (video.userId === currentUserId) return false;
            const hasVoted = (video.judgements || []).some(j => j.judgeId === currentUserId);
            return !hasVoted;
        });

        // Cas N°1 : Aucune vidéo à juger
        if (!videoData) {
            container.innerHTML = `
                <div class="text-center text-gray-400">
                    <i class="fa-solid fa-check-double text-6xl mb-4"></i>
                    <h3 class="text-xl font-bold text-white">C'est tout bon !</h3>
                    <p>Aucune vidéo n'est en attente de votre vote.</p>
                </div>
            `;
            isJuryVideoLoading = false;
            return;
        }
        
        const videoValidationRef = doc(db, 'video_validations', videoData.id);
        const urlToCheck = videoData.compressedVideoUrl || videoData.videoUrl;
        
        const isVideoPlayable = await new Promise((resolve) => {
            const tempVideo = document.createElement('video');
            tempVideo.src = urlToCheck; 
            tempVideo.onloadeddata = () => resolve(true);
            tempVideo.onerror = (e) => {
                console.error("La vidéo est illisible ou corrompue:", e);
                resolve(false);
            };
        });

        if (!isVideoPlayable) {
            showToast("Vidéo corrompue. Chargement de la suivante.", "error");
            await deleteDoc(videoValidationRef);
            isJuryVideoLoading = false;
            loadNextJuryVideo();
            return;
        }

        const perfDoc = await getDoc(doc(db, 'sbd_performances', videoData.sbdPerfId));
        const userDoc = await getDoc(doc(db, 'publicProfiles', videoData.userId));

        if (!perfDoc.exists() || !userDoc.exists()) {
            await deleteDoc(videoValidationRef);
            isJuryVideoLoading = false;
            loadNextJuryVideo();
            return;
        }
        
        // Cas N°2 : Une vidéo est trouvée, on la met dans un conteneur au fond noir
        const perfData = perfDoc.data();
        const userData = userDoc.data();
        const liftLabel = {squat:'Squat', bench:'Bench', deadlift:'Deadlift'}[perfData.liftType];
        
        // On remet le fond noir uniquement pour le conteneur de la carte vidéo
        container.style.backgroundColor = 'black'; 
        container.innerHTML = `
            <div class="w-full h-full bg-black rounded-2xl overflow-hidden shadow-lg relative" data-validation-id="${videoData.id}">
                <video id="jury-video-player" src="${urlToCheck}" class="w-full h-full object-cover absolute inset-0 z-0" autoplay loop muted playsinline></video>
                
                <div class="absolute top-0 left-0 right-0 z-20 pt-32 pb-6">
                    <div data-action="view-public-profile" data-uid="${userData.uid}" class="w-fit glass-card flex items-center gap-3 p-2 pl-4 pr-6 rounded-full text-white bg-black/50 backdrop-blur-md self-start ml-6 cursor-pointer">
                        ${renderAvatar(userData.profilePicUrl, 'w-10 h-10')}
                        <div>
                            <p class="font-bold text-lg">${userData.name}</p>
                            <p class="text-sm text-gray-300">${liftLabel} - <span class="font-semibold text-white">${perfData.weight}kg</span> @ ${perfData.bodyweight}kg</p>
                        </div>
                    </div>
                </div>

                <div class="absolute bottom-0 left-0 right-0 z-10 p-6 flex flex-col justify-end items-center h-1/2 bg-gradient-to-t from-black/60 to-transparent">
                    <div class="w-full flex justify-around items-center mb-16 px-8">
                        <button data-vote="reject" data-validation-id="${videoData.id}" class="jury-vote-btn w-20 h-20 rounded-full bg-red-500/50 backdrop-blur-md flex items-center justify-center transition-transform hover:scale-105"><i class="fa-solid fa-xmark text-4xl"></i></button>
                        <button data-vote="approve" data-validation-id="${videoData.id}" class="jury-vote-btn w-20 h-20 rounded-full bg-green-500/50 backdrop-blur-md flex items-center justify-center transition-transform hover:scale-105"><i class="fa-solid fa-check text-4xl"></i></button>
                    </div>
                    <button id="toggle-video-sound" class="absolute bottom-6 left-6 w-12 h-12 rounded-full bg-black/50 text-white z-20 flex items-center justify-center"><i class="fa-solid fa-volume-xmark"></i></button>
                </div>
            </div>
        `;

        const videoElement = container.querySelector('#jury-video-player');
        const soundBtn = container.querySelector('#toggle-video-sound');
        videoElement.muted = true;
        soundBtn.addEventListener('click', () => {
            videoElement.muted = !videoElement.muted;
            soundBtn.querySelector('i').className = `fa-solid ${videoElement.muted ? 'fa-volume-xmark' : 'fa-volume-high'}`;
        });

    } catch (error) {
        console.error("Erreur critique lors du chargement du jury:", error);
        container.innerHTML = `<p class="text-center text-red-400">Erreur critique. Réessayez plus tard.</p>`;
    } finally {
        isJuryVideoLoading = false;
    }
}

// --- NOUVEAU ---
async function submitUserReport(reportedUid, reason, comment) {
    if (!currentUserId || !reportedUid) {
        showToast("Erreur d'identification.", "error");
        return;
    }

    try {
        await addDoc(collection(db, 'userReports'), {
            reporterUid: currentUserId,
            reportedUid: reportedUid,
            reason: reason,
            comment: comment,
            timestamp: serverTimestamp(),
            status: 'pending' // Pour le suivi : 'pending', 'resolved', 'ignored'
        });

        closeModal();
        showToast("Utilisateur signalé. Merci pour votre aide !", "success");

    } catch (error) {
        console.error("Erreur lors de l'envoi du signalement:", error);
        showToast("Une erreur est survenue.", "error");
        const button = document.getElementById('confirm-report-btn');
        if (button) {
            button.disabled = false;
            button.textContent = "Envoyer";
        }
    }
}

function openClanSettingsModal() {
    const clanData = state.currentClanData;
    if (!clanData) return;

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Personnaliser</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        
        <div class="glass-card p-4 rounded-xl mb-4 text-center flex-shrink-0">
            <div id="preview-icon-wrapper" class="w-20 h-20 mx-auto flex items-center justify-center">
                <i id="preview-icon" class="fa-solid text-5xl"></i>
            </div>
            <h3 id="preview-name" class="text-3xl font-extrabold mt-2"></h3>
        </div>
        
        <div id="clan-settings-form" class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-4 min-h-0">
            <div>
                <label class="font-semibold text-gray-400">Nom</label>
                <input id="clan-name-edit" type="text" class="input-glass" value="${clanData.name}" maxlength="20">
            </div>
            
            <div>
                <label class="font-semibold text-gray-400">Icône</label>
                <div id="clan-icon-edit" class="grid grid-cols-6 gap-2 bg-black/20 p-2 rounded-lg">
                    ${CLAN_ICONS.map(i => `
                        <button class="clan-icon-btn aspect-square rounded-md text-2xl" data-id="${i.id}" data-icon-class="${i.icon}">
                            <i class="fa-solid ${i.icon}"></i>
                        </button>
                    `).join('')}
                </div>
            </div>
            
            <div class="pt-4 mt-4 border-t border-white/10 space-y-4">
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="font-semibold text-gray-400">Couleur du Titre</label>
                        <input id="clan-name-color" type="color" class="w-full h-12 bg-transparent p-1 rounded-lg" value="${clanData.nameColor || '#FFFFFF'}">
                    </div>
                    <div>
                        <label class="font-semibold text-gray-400">Couleur de l'Icône</label>
                        <input id="clan-icon-color" type="color" class="w-full h-12 bg-transparent p-1 rounded-lg" value="${clanData.iconColor || '#A78BFA'}">
                    </div>
                </div>
                <div class="flex items-center justify-between glass-card p-3 rounded-xl">
                    <label class="font-semibold">Animer le titre</label>
                    <label class="toggle-switch-v2">
                        <input type="checkbox" id="name-animation-toggle" ${clanData.nameIsAnimated ? 'checked' : ''}>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between glass-card p-3 rounded-xl">
                    <label class="font-semibold">Animer l'icône</label>
                    <label class="toggle-switch-v2">
                        <input type="checkbox" id="icon-animation-toggle" ${clanData.iconIsAnimated ? 'checked' : ''}>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="pt-4 mt-4 border-t border-white/10">
                <label class="font-semibold text-gray-400 mb-2 block">Musique de l'Équipe</label>
                <div id="clan-music-selection" class="grid grid-cols-4 gap-3">
                    ${CLAN_MUSIC_DATABASE.map(m => `
                        <button data-music-id="${m.id}" class="clan-music-btn flex flex-col items-center justify-center gap-2 p-2 rounded-lg bg-black/20 aspect-square">
                            ${m.id === 'music_none' 
                                ? '<i class="fa-solid fa-volume-xmark text-2xl"></i>' 
                                : `
                                <img src="${m.image}" class="w-8 h-8 rounded-md object-cover" loading="lazy" decoding="async">
                                `
                            }
                            <span class="text-xs text-center font-semibold leading-tight">${m.name}</span>
                        </button>
                    `).join('')}
                </div>
            </div>
        </div>
        
        <button id="save-clan-settings-btn" class="w-full mt-6 btn-primary flex-shrink-0">Sauvegarder</button>
    </div>
    `;

    showModal(modalContent, (modalWrapper) => {
        // ... Le reste de la logique interne de la fonction reste inchangé ...
        const getValues = () => ({
            name: modalWrapper.querySelector('#clan-name-edit').value.trim(),
            iconId: modalWrapper.querySelector('.clan-icon-btn.bg-violet-500')?.dataset.id,
            iconClass: modalWrapper.querySelector('.clan-icon-btn.bg-violet-500')?.dataset.iconClass,
            iconColor: modalWrapper.querySelector('#clan-icon-color').value,
            nameColor: modalWrapper.querySelector('#clan-name-color').value,
            nameIsAnimated: modalWrapper.querySelector('#name-animation-toggle').checked,
            iconIsAnimated: modalWrapper.querySelector('#icon-animation-toggle').checked,
            clanMusic: modalWrapper.querySelector('.clan-music-btn.bg-violet-500')?.dataset.musicId
        });

        const updatePreview = () => {
            const values = getValues();
            const previewName = modalWrapper.querySelector('#preview-name');
            const previewIcon = modalWrapper.querySelector('#preview-icon');
            
            previewName.textContent = values.name || 'Aperçu';
            let nameClasses = 'text-3xl font-extrabold mt-2';
            let nameStyle = `color: ${values.nameColor};`;
            if (values.nameIsAnimated) {
                nameClasses += ' dynamic-animated-gradient-text';
                nameStyle = `--base-color: ${values.nameColor}; --highlight-color: ${lightenColor(values.nameColor, 0.4)};`;
            }
            previewName.className = nameClasses;
            previewName.style = nameStyle;

            if (values.iconClass) {
                let iconClasses = `fa-solid ${values.iconClass} text-5xl`;
                let iconStyle = `color: ${values.iconColor};`;
                if (values.iconIsAnimated) {
                    iconClasses += ' dynamic-animated-gradient-icon';
                    iconStyle = `--base-color-icon: ${values.iconColor}; --highlight-color-icon: ${lightenColor(values.iconColor, 0.4)};`;
                }
                previewIcon.className = iconClasses;
                previewIcon.style = iconStyle;
            } else {
                previewIcon.className = 'fa-solid fa-question text-5xl text-gray-500';
            }
        };

        modalWrapper.addEventListener('input', updatePreview);
        modalWrapper.addEventListener('change', updatePreview);
        modalWrapper.addEventListener('click', (e) => {
            const iconBtn = e.target.closest('.clan-icon-btn');
            if (iconBtn) {
                modalWrapper.querySelectorAll('.clan-icon-btn').forEach(b => b.classList.remove('bg-violet-500'));
                iconBtn.classList.add('bg-violet-500');
                updatePreview();
            }
            const musicBtn = e.target.closest('.clan-music-btn');
            if (musicBtn) {
                modalWrapper.querySelectorAll('.clan-music-btn').forEach(b => b.classList.remove('bg-violet-500'));
                musicBtn.classList.add('bg-violet-500');
                playClanMusic(musicBtn.dataset.musicId);
            }
        });

        modalWrapper.querySelector('#save-clan-settings-btn').onclick = async () => {
            await updateClanSettings(getValues());
            closeModal();
        };

        modalWrapper.querySelector(`.clan-icon-btn[data-id="${clanData.iconId}"]`)?.classList.add('bg-violet-500');
        modalWrapper.querySelector(`.clan-music-btn[data-music-id="${clanData.clanMusic || 'music_none'}"]`)?.classList.add('bg-violet-500');
        updatePreview();
    });
}

// --- NOUVEAU ---
async function updateClanSettings(newData) {
    const clanId = state.currentClanData.id;
    if (!clanId || newData.name.length < 3) {
        showToast("Le nom de l'équipe doit faire au moins 3 caractères.", "error");
        return false;
    }
    const updateData = {
        name: newData.name,
        name_lowercase: newData.name.toLowerCase(),
        iconId: newData.iconId,
        iconColor: newData.iconColor,
        // iconEffect est supprimé car le menu n'existe plus
        nameColor: newData.nameColor,
        nameIsAnimated: newData.nameIsAnimated,
        iconIsAnimated: newData.iconIsAnimated,
        clanMusic: newData.clanMusic
    };
    const clanRef = doc(db, 'clans', clanId);
    try {
        await updateDoc(clanRef, updateData);
        showToast("Équipe mise à jour !", "success");
        return true;
    } catch (error) {
        showToast("Erreur lors de la mise à jour.", "error");
        return false;
    }
}

async function acceptClanInvite(clanId, messageId) {
    if (!currentUserId || state.userProfile.clanId) {
        showToast("Vous devez d'abord quitter votre équipe actuelle.", "error");
        renderInboxMessages();
        return;
    }

    const clanRef = doc(db, 'clans', clanId);
    const userRef = doc(db, 'users', currentUserId);
    const messageRef = doc(db, 'inboxMessages', messageId);
    const inviteKey = `pendingInvites.${currentUserId}`;

    try {
        await runTransaction(db, async (transaction) => {
            const clanDoc = await transaction.get(clanRef);
            if (!clanDoc.exists()) throw new Error("Cette équipe n'existe plus.");
            const clanData = clanDoc.data();
            if (clanData.members.length >= 10) throw new Error("L'équipe est maintenant complète.");
            transaction.update(clanRef, {
                members: arrayUnion(currentUserId),
                [inviteKey]: deleteField()
            });
            transaction.update(userRef, { 'userProfile.clanId': clanId });
            transaction.delete(messageRef);
        });

        // --- AJOUTS IMPORTANTS ---
        const newClanDoc = await getDoc(doc(db, 'clans', clanId));
        if (newClanDoc.exists()) {
            state.userProfile.clanId = clanId;
            state.currentClanData = { id: newClanDoc.id, ...newClanDoc.data() };
            render(); // Force le rafraîchissement pour jouer la musique
        }
        // --- FIN DES AJOUTS ---

        showToast("Vous avez rejoint l'équipe !", "success");
        renderInboxMessages();

    } catch (error) {
        showToast(error.message, "error");
        renderInboxMessages();
    }
}

function playClanMusic(musicId) {
        const player = document.getElementById('clan-music-player');
        const musicTrack = CLAN_MUSIC_DATABASE.find(m => m.id === musicId);

        if (player) {
            state.clanAudioElement = player;
        }
        
        // ÉTAPE 1 : Annuler TOUTES les animations de volume en cours (fondu entrant ou sortant).
        if (fadeInInterval) clearInterval(fadeInInterval);
        if (fadeOutInterval) clearInterval(fadeOutInterval);
        fadeInInterval = null;
        fadeOutInterval = null;
        
        if (!musicTrack || !musicTrack.url) {
            stopClanMusic();
            return;
        }

        // ÉTAPE 2 : On s'assure que la bonne musique est chargée.
        if (player.src !== musicTrack.url) {
             player.src = musicTrack.url;
        }

        // ÉTAPE 3 : On lance la lecture et on démarre TOUJOURS un fondu entrant.
        const playPromise = player.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                startParticleEffect();
                
                // Ce fondu va maintenant "reprendre" là où le volume s'est arrêté
                // et l'amener jusqu'à 100%, même si on l'a interrompu.
                fadeInInterval = setInterval(() => {
                    const targetVolume = state.clanMusicMuted ? 0 : 1;
                    if (player.volume < targetVolume) {
                        // Vitesse de fondu légèrement augmentée pour une reprise rapide.
                        player.volume = Math.min(targetVolume, player.volume + 0.1);
                    } else {
                        player.volume = targetVolume;
                        clearInterval(fadeInInterval);
                        fadeInInterval = null;
                    }
                }, 100);

            }).catch(error => {
                console.error("Erreur de lecture audio :", error);
                stopParticleEffect();
            });
        }
    }

function stopClanMusic() {
        stopParticleEffect();
        if (fadeInInterval) clearInterval(fadeInInterval);
        if (fadeOutInterval) clearInterval(fadeOutInterval); // Sécurité supplémentaire

        const player = document.getElementById('clan-music-player');
        if (player && !player.paused) {
            // CORRECTION : On assigne l'animation à notre variable globale.
            fadeOutInterval = setInterval(() => {
                if (player.volume > 0.05) {
                    player.volume -= 0.05;
                } else {
                    clearInterval(fadeOutInterval);
                    fadeOutInterval = null; // On nettoie la variable quand c'est fini.
                    player.pause();
                    player.volume = 1;
                }
            }, 50);
        }
    }

// --- NOUVEAU ---
async function declineClanInvite(clanId, messageId) {
    if (!currentUserId) return;

    const clanRef = doc(db, 'clans', clanId);
    const messageRef = doc(db, 'inboxMessages', messageId);
    // La clé est bien 'currentUserId' car c'est l'utilisateur invité qui refuse.
    const inviteKey = `pendingInvites.${currentUserId}`;

    try {
        const batch = writeBatch(db);
        // On supprime le champ de l'invitation en attente dans le document du clan
        batch.update(clanRef, { [inviteKey]: deleteField() });
        // On supprime le message de la boîte de réception
        batch.delete(messageRef);
        await batch.commit();

        showToast("Invitation refusée.", "info");
        renderInboxMessages();
    } catch (error) {
        showToast("Une erreur est survenue.", "error");
        renderInboxMessages();
    }
}

function renderLeaderboardHero(user) {
    if (!user) return '<div class="w-full h-full flex items-center justify-center"><p class="text-gray-500">Le trône est vacant.</p></div>';
    
    const liftType = state.leaderboard.activeTab;
    const perf = user.displayPerf ?? (user.sbd_ranks[liftType]?.best_1rm || 0);
    
    let bodyweightText = '';
    if (liftType === 'total') {
        const maxBw = Math.max(user.sbd_ranks.squat?.bodyweight || 0, user.sbd_ranks.bench?.bodyweight || 0, user.sbd_ranks.deadlift?.bodyweight || 0);
        if (maxBw > 0) bodyweightText = `@ ${maxBw.toFixed(1)} kg`;
    } else {
        const bw = user.sbd_ranks[liftType]?.bodyweight;
        if (bw) bodyweightText = `@ ${bw.toFixed(1)} kg`;
    }

    const equippedTitle = TITLES_DATABASE.find(t => t.id === user.equipped?.title) || { name: 'Débutant', rarity: 'Commun' };
    const equippedBorder = BORDERS_DATABASE.find(b => b.id === user.equipped?.border) || { style: '' };
    const titleClass = equippedTitle.color ? equippedTitle.color : `rarity-${normalizeString(equippedTitle.rarity)}-text`;
    
    return `
    <div data-action="view-public-profile" data-uid="${user.uid}" class="w-full h-full glass-card rounded-2xl p-4 flex items-center gap-4 cursor-pointer hover:bg-white/10 transition-all duration-300 relative overflow-hidden border-2 border-yellow-400/50" style="box-shadow: 0 0 25px rgba(253, 224, 71, 0.15);">
        <div class="absolute -left-12 -top-12 text-yellow-400/20" style="font-size: 10rem; filter: drop-shadow(0 0 10px #FDE047);">
            <i class="fa-solid fa-crown"></i>
        </div>
        <div class="relative z-10 w-24 h-24 flex-shrink-0 p-1 rounded-full" style="${equippedBorder.style}">
             <div class="w-full h-full bg-gray-900 rounded-full overflow-hidden">
                ${renderAvatar(user.profilePicUrl, 'w-full h-full')}
             </div>
        </div>
        <div class="relative z-10 min-w-0">
            <p class="font-black text-4xl text-yellow-300" style="filter: drop-shadow(0 0 8px currentColor);">#1</p>
            <p class="text-xl font-bold truncate">${user.name}</p>
            <p class="text-sm font-semibold ${titleClass}">${equippedTitle.name}</p>
        </div>
        <div class="relative z-10 ml-auto text-right">
            <div class="flex items-baseline gap-1 whitespace-nowrap">
                <p class="text-4xl font-extrabold text-white">${perf.toFixed(1)}</p>
                <p class="text-lg font-semibold text-gray-400">kg</p>
            </div>
            <p class="text-sm font-semibold text-gray-400">${bodyweightText}</p>
        </div>
    </div>`;
}

async function renderLeaderboardContent() {
    const heroContainer = document.getElementById('leaderboard-hero');
    const listContainer = document.getElementById('leaderboard-list');
    const myRankContainer = document.getElementById('myleaderboard-rank');
    const filterSummary = document.getElementById('leaderboard-filter-summary');

    if (!heroContainer || !listContainer || !myRankContainer || !filterSummary) return;
    
    heroContainer.innerHTML = `<div class="w-full h-full flex items-center justify-center"><i class="fa-solid fa-spinner fa-spin text-4xl text-gray-500"></i></div>`;
    listContainer.innerHTML = '';
    myRankContainer.innerHTML = `<div class="glass-card p-4 rounded-xl text-center text-gray-400">Chargement...</div>`;

    const { activeTab, genderFilter, weightClassFilter } = state.leaderboard;
    const liftType = activeTab;

    const liftLabel = {total: 'Total SBD', squat: 'Squat', bench: 'Bench', deadlift: 'Deadlift'}[liftType];
    const genderForClass = genderFilter === 'femme' ? 'Femme' : 'Homme';
    const wcLabel = genderFilter === 'tout' 
        ? 'Open (Tous poids)' 
        : WEIGHT_CLASSES[genderForClass].find(wc => wc.key === weightClassFilter)?.name || 'Open';
    filterSummary.textContent = `${liftLabel} - ${wcLabel}`;

    const fieldToSortBy = liftType === 'total' ? 'sbd_ranks.total.best_1rm' : `sbd_ranks.${liftType}.best_1rm`;
    let q = query(collection(db, 'publicProfiles'), where(fieldToSortBy, '>', 0), orderBy(fieldToSortBy, 'desc'), limit(500));
    
    if (genderFilter !== 'tout') {
        q = query(q, where('sex', '==', (genderFilter === 'homme' ? 'Homme' : 'Femme')));
    }

    try {
        const querySnapshot = await getDocs(q);
        let allUsers = querySnapshot.docs.map(doc => doc.data());
        let filteredUsers = allUsers;

        if (weightClassFilter !== 'open') {
            const weightClass = WEIGHT_CLASSES[genderForClass].find(wc => wc.key === weightClassFilter);
            if (weightClass) {
                const [min, max] = weightClass.range;

                // --- NOUVELLE LOGIQUE DE FILTRAGE SIMPLIFIÉE ---
                if (liftType === 'total') {
                    // Pour le total, on détermine la catégorie de poids de l'utilisateur par son BW max sur les 3 lifts
                    filteredUsers = allUsers.filter(user => {
                        const ranks = user.sbd_ranks;
                        const maxBodyweight = Math.max(
                            ranks.squat?.bodyweight || 0,
                            ranks.bench?.bodyweight || 0,
                            ranks.deadlift?.bodyweight || 0
                        );
                        return maxBodyweight > min && maxBodyweight <= max;
                    });
                } else {
                    // Pour un mouvement simple, la logique reste la même : on filtre sur le BW de ce lift
                    filteredUsers = allUsers.filter(user => {
                        const userBw = user.sbd_ranks[liftType]?.bodyweight || 0;
                        return userBw > min && userBw <= max;
                    });
                }
                // --- FIN DE LA NOUVELLE LOGIQUE ---
            }
        }

        // On assigne la performance à afficher. Pour le total, c'est le total précalculé.
        filteredUsers.forEach(user => {
            user.displayPerf = user.sbd_ranks[liftType]?.best_1rm || 0;
        });

        const top100 = filteredUsers.slice(0, 100);
        const top1 = top100.length > 0 ? top100[0] : null;
        const theRest = top100.slice(1);

        heroContainer.innerHTML = renderLeaderboardHero(top1);
        listContainer.innerHTML = theRest.length > 0
            ? theRest.map((user, index) => renderLeaderboardCard(user, index + 2)).join('')
            : `<p class="text-center text-gray-400 pt-8">${top1 ? 'Seul au sommet !' : 'Aucune performance trouvée.'}</p>`;

        const myRankIndex = filteredUsers.findIndex(user => user.uid === currentUserId);
        const myPerf = state.userProfile.sbd_ranks[liftType]?.best_1rm || 0;
        
        myRankContainer.innerHTML = renderMyRank(myRankIndex, myPerf);

    } catch (error) {
        console.error("Erreur Firestore:", error);
        heroContainer.innerHTML = '';
        listContainer.innerHTML = `<p class="text-center text-red-400 pt-16">Erreur de chargement.</p>`;
    }
}

function openLeaderboardFilterModal_v3() {
    const { activeTab, genderFilter, weightClassFilter } = state.leaderboard;
    const genderForClass = genderFilter === 'femme' ? 'Femme' : 'Homme';
    const weightClasses = WEIGHT_CLASSES[genderForClass];
    const selectedWc = weightClasses.find(wc => wc.key === weightClassFilter) || weightClasses[0];

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <div class="w-12 h-1.5 bg-gray-600 rounded-full mx-auto mb-4"></div>
        <h2 class="text-2xl font-bold text-center mb-6">Filtres</h2>
        <div class="space-y-4">
            <div>
                <label class="font-semibold text-gray-400 text-sm">Mouvement</label>
                <div class="p-1 bg-black/20 rounded-lg flex gap-1 mt-1">
                    <button data-filter-type="activeTab" data-value="total" class="flex-1 p-2 rounded-md text-sm font-semibold">Total</button>
                    <button data-filter-type="activeTab" data-value="squat" class="flex-1 p-2 rounded-md text-sm font-semibold">Squat</button>
                    <button data-filter-type="activeTab" data-value="bench" class="flex-1 p-2 rounded-md text-sm font-semibold">Bench</button>
                    <button data-filter-type="activeTab" data-value="deadlift" class="flex-1 p-2 rounded-md text-sm font-semibold">Deadlift</button>
                </div>
            </div>
            <div>
                <label class="font-semibold text-gray-400 text-sm">Sexe</label>
                <div class="p-1 bg-black/20 rounded-lg flex gap-1 mt-1">
                    <button data-filter-type="gender" data-value="homme" class="flex-1 p-2 rounded-md text-sm font-semibold">Homme</button>
                    <button data-filter-type="gender" data-value="femme" class="flex-1 p-2 rounded-md text-sm font-semibold">Femme</button>
                    <button data-filter-type="gender" data-value="tout" class="flex-1 p-2 rounded-md text-sm font-semibold">Tout</button>
                </div>
            </div>
            <div>
                <label class="font-semibold text-gray-400 text-sm">Catégorie de poids</label>
                <div id="weight-class-select-container" class="relative custom-select-container mt-1">
                     <button id="weight-class-select-button" class="custom-select-button">
                        <span>${selectedWc.name}</span><i class="fa-solid fa-chevron-down text-gray-500"></i>
                     </button>
                     <div class="custom-select-options max-h-56 overflow-y-auto scrollbar-hide">
                        ${weightClasses.map(wc => `<div class="custom-select-option" data-value="${wc.key}">${wc.name}</div>`).join('')}
                     </div>
                </div>
            </div>
        </div>
        <button id="apply-leaderboard-filters" class="w-full mt-8 btn-primary">Appliquer les filtres</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        let tempGender = genderFilter;
        let tempWc = weightClassFilter;

        const updateButtonStyles = (type, value) => {
            modalWrapper.querySelectorAll(`[data-filter-type="${type}"]`).forEach(b => {
                const isActive = b.dataset.value === value;
                b.classList.toggle('bg-white/10', isActive);
                b.classList.toggle('text-white', isActive);
                b.classList.toggle('text-gray-400', !isActive);
            });
        };
        
        updateButtonStyles('activeTab', activeTab);
        updateButtonStyles('gender', genderFilter);

        const wcContainer = modalWrapper.querySelector('#weight-class-select-container');
        if (genderFilter === 'tout') {
            wcContainer.style.opacity = '0.5';
            wcContainer.style.pointerEvents = 'none';
        }

        modalWrapper.addEventListener('click', e => {
            const filterBtn = e.target.closest('button[data-filter-type]');
            if (filterBtn) {
                const { filterType, value } = filterBtn.dataset;
                updateButtonStyles(filterType, value);
                if (filterType === 'gender') {
                    tempGender = value;
                    const newWeightClasses = tempGender === 'femme' ? WEIGHT_CLASSES.Femme : WEIGHT_CLASSES.Homme;
                    wcContainer.querySelector('.custom-select-options').innerHTML = newWeightClasses.map(wc => `<div class="custom-select-option" data-value="${wc.key}">${wc.name}</div>`).join('');
                    wcContainer.querySelector('button span').textContent = 'Open (Tous poids)';
                    tempWc = 'open';
                    
                    if (tempGender === 'tout') {
                        wcContainer.style.opacity = '0.5';
                        wcContainer.style.pointerEvents = 'none';
                    } else {
                        wcContainer.style.opacity = '1';
                        wcContainer.style.pointerEvents = 'auto';
                    }
                }
            }
            
            const wcOption = e.target.closest('.custom-select-option');
            if (wcOption) {
                tempWc = wcOption.dataset.value;
                wcContainer.querySelector('button span').textContent = wcOption.textContent;
                closeAllDropdowns();
            }
        });

        modalWrapper.querySelector('#apply-leaderboard-filters').onclick = () => {
            state.leaderboard = {
                activeTab: modalWrapper.querySelector('[data-filter-type="activeTab"].bg-white\\/10')?.dataset.value || 'total',
                genderFilter: tempGender,
                weightClassFilter: tempWc,
            };
            closeModal();
            renderLeaderboardContent();
        };
    });
}

function renderLeaderboardCard(user, rank) {
    const liftType = state.leaderboard.activeTab;
    const perf = user.displayPerf ?? (user.sbd_ranks[liftType]?.best_1rm || 0);
    
    let bodyweightText = '';
    if (liftType === 'total') {
        const maxBw = Math.max(user.sbd_ranks.squat?.bodyweight || 0, user.sbd_ranks.bench?.bodyweight || 0, user.sbd_ranks.deadlift?.bodyweight || 0);
        if (maxBw > 0) bodyweightText = `@ ${maxBw.toFixed(1)} kg`;
    } else {
        const bw = user.sbd_ranks[liftType]?.bodyweight;
        if (bw) bodyweightText = `@ ${bw.toFixed(1)} kg`;
    }

    const equippedBorder = BORDERS_DATABASE.find(b => b.id === user.equipped?.border) || { style: '' };
    const rankColors = { 2: 'border-gray-400/50 text-gray-300', 3: 'border-yellow-600/50 text-yellow-600' };
    const rankStyle = rankColors[rank] || 'border-transparent text-gray-400';

    return `
    <div data-action="view-public-profile" data-uid="${user.uid}" class="glass-card p-2 rounded-full flex items-center justify-between cursor-pointer hover:bg-white/10 border-2 ${rank <= 3 ? rankStyle : 'border-transparent'}">
        <div class="flex items-center gap-3 min-w-0">
            <p class="font-bold text-base w-8 text-center ${rank <= 3 ? 'font-black' : ''} ${rankStyle}">#${rank}</p>
            <div class="w-10 h-10 rounded-full p-0.5" style="${equippedBorder.style}">
                <div class="w-full h-full bg-gray-900 rounded-full overflow-hidden">
                    ${renderAvatar(user.profilePicUrl, 'w-full h-full')}
                </div>
            </div>
            <p class="font-semibold truncate">${user.name}</p>
        </div>
        <div class="text-right pr-4">
            <p class="text-base font-bold text-white">${perf.toFixed(1)} kg</p>
            <p class="text-xs text-gray-400 -mt-1">${bodyweightText}</p>
        </div>
    </div>`;
}

function renderPodium(top3Users) {
    if (top3Users.length === 0) return '';
    const podiumOrder = [1, 0, 2]; // Affiche #2, #1 (central), #3
    const heights = ['h-3/4', 'h-full', 'h-2/3'];
    const crowns = [
        { rank: 2, icon: 'fa-crown', color: '#C0C0C0' }, // Argent
        { rank: 1, icon: 'fa-crown', color: '#FFD700' }, // Or
        { rank: 3, icon: 'fa-crown', color: '#CD7F32' }  // Bronze
    ];

    return podiumOrder.map(index => {
        const user = top3Users[index];
        if (!user) return `<div class="w-1/3"></div>`;
        const crown = crowns[index];
        const perf = user.sbd_ranks[state.leaderboard.activeTab]?.best_1rm || 0;
        
        return `
        <div data-action="view-public-profile" data-uid="${user.uid}" class="w-1/3 flex flex-col items-center justify-end ${heights[index]} cursor-pointer group">
            <i class="fa-solid ${crown.icon} text-3xl mb-1" style="color: ${crown.color}; filter: drop-shadow(0 0 8px ${crown.color});"></i>
            <div class="w-20 h-20 rounded-full p-1 bg-gray-900 transition-transform duration-300 group-hover:scale-110" style="border: 4px solid ${crown.color};">
                ${renderAvatar(user.profilePicUrl, 'w-full h-full')}
            </div>
            <p class="font-bold text-white truncate mt-2" style="text-shadow: 0 1px 3px #000;">${user.name}</p>
            <p class="font-semibold text-gray-200 text-sm" style="text-shadow: 0 1px 3px #000;">${perf.toFixed(1)} kg</p>
        </div>`;
    }).join('');
}

function renderMyRank(rankIndex, perf) {
    const rankText = rankIndex !== -1 ? `#${rankIndex + 1}` : '-';
    const liftType = state.leaderboard.activeTab;
    let bodyweightText = '';
     if (liftType === 'total') {
        const maxBw = Math.max(state.userProfile.sbd_ranks.squat?.bodyweight || 0, state.userProfile.sbd_ranks.bench?.bodyweight || 0, state.userProfile.sbd_ranks.deadlift?.bodyweight || 0);
        if (maxBw > 0) bodyweightText = `@ ${maxBw.toFixed(1)} kg`;
    } else {
        const bw = state.userProfile.sbd_ranks[liftType]?.bodyweight;
        if (bw) bodyweightText = `@ ${bw.toFixed(1)} kg`;
    }
    
    const equippedBorder = BORDERS_DATABASE.find(b => b.id === state.userProfile.equipped?.border) || { style: '' };

    return `
    <div data-action="view-public-profile" data-uid="${currentUserId}" class="glass-card p-2 rounded-full flex items-center justify-between border-2 ${rankIndex !== -1 ? 'border-violet-400/50' : 'border-transparent'} cursor-pointer hover:bg-white/10">
        <div class="flex items-center gap-3 min-w-0">
            <p class="font-bold text-base w-8 text-center ${rankIndex !== -1 ? 'text-violet-300' : 'text-gray-500'}">${rankText}</p>
            <div class="w-10 h-10 rounded-full p-0.5" style="${equippedBorder.style}">
                <div class="w-full h-full bg-gray-900 rounded-full overflow-hidden">
                    ${renderAvatar(state.userProfile.profilePicUrl, 'w-full h-full')}
                </div>
            </div>
            <p class="font-semibold truncate">Votre Rang</p>
        </div>
        <div class="text-right pr-4">
            <p class="text-base font-bold text-white">${perf.toFixed(1)} kg</p>
            <p class="text-xs text-gray-400 -mt-1">${bodyweightText}</p>
        </div>
    </div>`;
}

// AJOUTE CE NOUVEAU GESTIONNAIRE D'ÉVÉNEMENTS
async function handleLeaderboardEvents(e) {
    // Clic sur le bouton de filtre principal
    if (e.target.closest('#open-leaderboard-filters-v3')) {
        openLeaderboardFilterModal_v3();
        return;
    }

    // CORRECTION : Gestion du clic sur n'importe quelle carte de profil
    const profileCard = e.target.closest('[data-action="view-public-profile"]');
    if (profileCard) {
        const userId = profileCard.dataset.uid;
        if (userId) {
            openPublicProfileModal(userId);
        }
        return;
    }
}

function handleLoginEvents(e) {
    // Référence au conteneur du message d'erreur
    const errorContainer = document.getElementById('auth-error-message');
    if (errorContainer) errorContainer.textContent = ''; // Effacer les messages précédents

    const googleBtn = e.target.closest('#google-login-btn');
    if (googleBtn) {
        handleGoogleLogin(errorContainer);
    }

    const emailLoginBtn = e.target.closest('#email-login-btn');
    if (emailLoginBtn) {
        handleEmailLogin(errorContainer);
    }
    
    const registerBtn = e.target.closest('#register-btn');
    if (registerBtn) {
        handleEmailRegister(errorContainer);
    }
}

// === NOUVELLE FONCTION AJOUTÉE ICI ===
async function handleGoogleLogin(errorContainer) {
    const provider = new GoogleAuthProvider(); // 1. Crée un fournisseur d'authentification Google
    try {
        // 2. Ouvre la fenêtre contextuelle pour la connexion
        await signInWithPopup(auth, provider);
        // Si la connexion réussit, l'écouteur `onAuthStateChanged` s'occupera automatiquement
        // de la redirection vers la page d'accueil.
    } catch (error) {
        // 3. Gère les erreurs si l'utilisateur ferme la fenêtre ou si un problème survient
        const errorCode = error.code;
        console.error("Erreur de connexion Google:", errorCode);
        if (errorCode === 'auth/popup-closed-by-user') {
            if (errorContainer) errorContainer.textContent = "La fenêtre de connexion a été fermée.";
        } else {
            if (errorContainer) errorContainer.textContent = "Erreur de connexion avec Google. Veuillez réessayer.";
        }
    }
}
// === FIN DE L'AJOUT ===


async function handleEmailLogin(errorContainer) {
    const emailInput = document.getElementById('login-email');
    const passwordInput = document.getElementById('login-password');
    const email = emailInput.value;
    const password = passwordInput.value;

    if (!email || !password) {
        if (errorContainer) errorContainer.textContent = "Veuillez remplir tous les champs.";
        return;
    }

    try {
        await signInWithEmailAndPassword(auth, email, password);
        // Firebase `onAuthStateChanged` s'occupe de la redirection
    } catch (error) {
        const errorCode = error.code;
        console.error("Erreur de connexion par email:", errorCode);
        if (errorContainer) {
            // Afficher des messages d'erreur adaptés
            if (errorCode === 'auth/invalid-credential') {
                errorContainer.textContent = "Email ou mot de passe incorrect.";
            } else if (errorCode === 'auth/user-not-found') {
                errorContainer.textContent = "Aucun compte trouvé avec cet email.";
            } else {
                errorContainer.textContent = "Erreur de connexion. Veuillez réessayer.";
            }
        }
    }
}

async function handleTribunalEvents(e) {
    const voteBtn = e.target.closest('.jury-vote-btn');
    if (voteBtn) {
        const { validationId, vote } = voteBtn.dataset;
        const juryCardContainer = document.getElementById('jury-card-container');
        if (!juryCardContainer) return;

        juryCardContainer.innerHTML = `<div class="flex items-center justify-center h-full"><i class="fa-solid fa-spinner fa-spin text-4xl text-white"></i></div>`;

        try {
            const { updatedJudgements, perfData, videoData, perfDocRef, videoValidationRef } = await runTransaction(db, async (transaction) => {
                const validationRef = doc(db, 'video_validations', validationId);
                const videoDoc = await transaction.get(validationRef);
                if (!videoDoc.exists()) throw new Error("Ce document n'existe plus.");

                const vData = videoDoc.data();
                const pRef = doc(db, 'sbd_performances', vData.sbdPerfId);
                const perfDoc = await transaction.get(pRef);
                const pData = perfDoc.exists() ? perfDoc.data() : null;

                const alreadyVoted = (vData.judgements || []).some(j => j.judgeUid === currentUserId);
                if (alreadyVoted) throw new Error("Vous avez déjà voté pour cette performance.");

                const newJudgement = { judgeUid: currentUserId, vote: vote, timestamp: new Date() };
                const newJudgements = [...(vData.judgements || []), newJudgement];
                
                transaction.update(validationRef, { judgements: newJudgements });
                
                return { updatedJudgements: newJudgements, perfData: pData, videoData: vData, perfDocRef: pRef, videoValidationRef: validationRef };
            });

            const approveCount = updatedJudgements.filter(j => j.vote === 'approve').length;
            const rejectCount = updatedJudgements.filter(j => j.vote === 'reject').length;
            const VOTE_THRESHOLD = 1;

            let verdictFinal = null;
            if (approveCount >= VOTE_THRESHOLD) verdictFinal = 'approved';
            else if (rejectCount >= VOTE_THRESHOLD) verdictFinal = 'rejected';
            
            if (verdictFinal) {
                const userDocRef = doc(db, 'users', videoData.userId);
                const batch = writeBatch(db);
                
                batch.update(perfDocRef, { status: verdictFinal });
                batch.delete(videoValidationRef);
                
                // --- CORRECTION APPLIED HERE ---
                const liftType = perfData.liftType;
                const userProfileUpdate = {};

                if (verdictFinal === 'approved') {
                    const newVaultEntry = {
                        id: perfDocRef.id,
                        weight: perfData.weight,
                        status: 'verified',
                        timestamp: perfData.timestamp,
                        bodyweight: perfData.bodyweight,
                        sourcePerf: { method: 'tribunal', validationId: videoValidationRef.id }
                    };
                    userProfileUpdate[`userProfile.sbdVault.${liftType}.verified`] = newVaultEntry;
                }
                
                // Regardless of the verdict, clear the 'pending' slot
                userProfileUpdate[`userProfile.sbdVault.${liftType}.pending`] = null;
                batch.update(userDocRef, userProfileUpdate);
                // --- END OF CORRECTION ---

                await batch.commit();

                // The video file deletion logic remains unchanged...
                try {
                    const storage = getStorage(app);
                    const urlsToDelete = [];
                    if (videoData.compressedVideoUrl) urlsToDelete.push(videoData.compressedVideoUrl);
                    if (videoData.videoUrl) urlsToDelete.push(videoData.videoUrl);

                    const deletePromises = urlsToDelete.map(url => {
                        if (!url) return Promise.resolve();
                        const fileRef = ref(storage, url);
                        return deleteObject(fileRef).catch(err => {
                            if (err.code === 'storage/object-not-found') {
                                console.log(`File already deleted: ${url}`);
                                return;
                            }
                            throw err;
                        });
                    });

                    await Promise.all(deletePromises);
                    console.log("Verdict video files deleted from storage. ✅");
                } catch (storageError) {
                    console.error("Error deleting video files:", storageError);
                }

                await sendVerdictMessage(videoData.userId, verdictFinal, perfData);
                showToast(`Verdict final : ${verdictFinal === 'approved' ? 'Approuvé' : 'Rejeté'} !`, 'success');

            } else {
                 showToast("Vote enregistré !", "success");
            }

        } catch (error) {
            console.error("Erreur lors du vote:", error);
            showToast(typeof error.message === 'string' ? error.message : "Une erreur s'est produite.", "error");
        } finally {
            await loadNextJuryVideo();
        }
    }

    const profileBtn = e.target.closest('[data-action="view-public-profile"]');
    if (profileBtn) {
        const userId = profileBtn.dataset.uid;
        openPublicProfileModal(userId, true);
    }
}

async function loadNextVideoForJury() {
    // CORRECTION : L'ID du conteneur est maintenant le bon ("tribunal-container")
    const container = document.getElementById('tribunal-container');
    if (!container || isJuryVideoLoading) return;

    isJuryVideoLoading = true;
    container.innerHTML = `<div class="flex items-center justify-center pt-24"><i class="fa-solid fa-spinner fa-spin text-4xl text-white"></i></div>`;
    
    try {
        const q = query(
            collection(db, 'video_validations'),
            where('status', '==', 'pending'),
            limit(15)
        );
        const querySnapshot = await getDocs(q);
        
        const videos = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const videoData = videos.find(video => {
            if (video.userId === currentUserId) return false;
            const hasVoted = (video.judgements || []).some(j => j.judgeUid === currentUserId);
            return !hasVoted;
        });

        if (!videoData) {
            container.innerHTML = `
                <div class="text-center text-gray-400 pt-24">
                    <i class="fa-solid fa-check-double text-6xl mb-4"></i>
                    <h3 class="text-xl font-bold text-white">C'est tout bon !</h3>
                    <p>Aucune vidéo n'est en attente de votre vote.</p>
                </div>`;
            return;
        }

        const perfDoc = await getDoc(doc(db, 'sbd_performances', videoData.sbdPerfId));
        const userDoc = await getDoc(doc(db, 'publicProfiles', videoData.userId));

        if (!perfDoc.exists() || !userDoc.exists()) {
            await deleteDoc(doc(db, 'video_validations', videoData.id));
            loadNextVideoForJury();
            return;
        }

        const perfData = perfDoc.data();
        const userData = userDoc.data();
        const liftLabel = getExerciseName(perfData.liftType);
        
        container.innerHTML = `
            <div class="w-full h-[700px] bg-black rounded-2xl overflow-hidden shadow-lg relative" data-validation-id="${videoData.id}">
                <video id="jury-video-player" src="${videoData.compressedVideoUrl || videoData.videoUrl}" class="w-full h-full object-cover absolute inset-0 z-0" autoplay loop muted playsinline></video>
                <div class="absolute inset-0 bg-gradient-to-t from-black/70 via-transparent to-black/30 z-10"></div>
                <div class="absolute top-0 left-0 right-0 p-4 z-20">
                    <div data-action="view-public-profile" data-uid="${userData.uid}" class="w-fit glass-card flex items-center gap-3 p-2 pl-3 pr-4 rounded-full text-white bg-black/50 backdrop-blur-md cursor-pointer">
                        ${renderAvatar(userData.profilePicUrl, 'w-10 h-10')}
                        <div>
                            <p class="font-bold">${userData.name}</p>
                            <p class="text-xs text-gray-300">${liftLabel} - <span class="font-semibold text-white">${perfData.weight}kg</span> @ ${perfData.bodyweight}kg</p>
                        </div>
                    </div>
                </div>
                <div class="absolute bottom-0 left-0 right-0 z-20 p-6 flex flex-col justify-end items-center">
                    <div class="w-full flex justify-around items-center mb-4 jury-vote-btn-container">
                        <button data-vote="invalide" data-validation-id="${videoData.id}" class="jury-vote-btn w-20 h-20 rounded-full bg-red-500/80 backdrop-blur-md flex items-center justify-center transition-transform hover:scale-105"><i class="fa-solid fa-xmark text-4xl"></i></button>
                        <button data-vote="legitime" data-validation-id="${videoData.id}" class="jury-vote-btn w-20 h-20 rounded-full bg-green-500/80 backdrop-blur-md flex items-center justify-center transition-transform hover:scale-105"><i class="fa-solid fa-check text-4xl"></i></button>
                    </div>
                    <button id="toggle-video-sound" class="w-10 h-10 rounded-full bg-black/50 text-white z-20 flex items-center justify-center"><i class="fa-solid fa-volume-xmark"></i></button>
                </div>
            </div>`;

        const videoElement = container.querySelector('#jury-video-player');
        const soundBtn = container.querySelector('#toggle-video-sound');
        soundBtn.addEventListener('click', () => {
            videoElement.muted = !videoElement.muted;
            soundBtn.querySelector('i').className = `fa-solid ${videoElement.muted ? 'fa-volume-xmark' : 'fa-volume-high'}`;
        });

    } catch (error) {
        console.error("Erreur critique lors du chargement pour le jury:", error);
        container.innerHTML = `<p class="text-center text-red-400 pt-24">Erreur critique. Réessayez plus tard.</p>`;
    } finally {
        isJuryVideoLoading = false;
    }
}

function getExerciseName(liftType) {
    switch (liftType) {
        case 'squat': return 'Squat';
        case 'bench': return 'Bench';
        case 'deadlift': return 'Deadlift';
        default: return liftType;
    }
}

async function sendVerdictMessage(recipientUid, verdict, perfData) {
    if (!recipientUid || !verdict || !perfData) return;

    const liftName = getExerciseName(perfData.liftType) || "Performance SBD";
    const weight = perfData.weight;
    let subject = '';
    let content = '';
    let systemIcon = 'fa-robot';

    if (verdict === 'approved') {
        subject = `✅ Performance Validée !`;
        content = `Félicitations ! Votre performance de ${liftName} à ${weight} kg a été validée par le Tribunal. Elle est maintenant visible dans votre coffre-fort et compte pour vos statistiques.`;
        systemIcon = 'fa-check-circle';
    } else {
        subject = `❌ Performance Rejetée`;
        content = `Votre performance de ${liftName} à ${weight} kg a été rejetée par le Tribunal. Cela peut être dû à une amplitude de mouvement incomplète ou un non-respect des règles. Vous pouvez la soumettre à nouveau avec une vidéo plus claire.`;
        systemIcon = 'fa-times-circle';
    }

    try {
        // CORRECTION : Écrit dans la collection "inboxMessages" avec les bons champs
        await addDoc(collection(db, 'inboxMessages'), {
            recipientUid: recipientUid,
            senderUid: 'fitflow_system_tribunal',
            senderName: 'FitFlow Tribunal',
            type: 'sbd_verdict',
            subject: subject,
            content: content,
            liftInfo: `${liftName} - ${weight}kg`,
            systemIcon: systemIcon,
            timestamp: serverTimestamp(),
            isRead: false
        });
    } catch (error) {
        console.error("Erreur lors de l'envoi du message de verdict:", error);
    }
}

async function handleEmailRegister(errorContainer) {
    const emailInput = document.getElementById('login-email');
    const passwordInput = document.getElementById('login-password');
    const email = emailInput.value;
    const password = passwordInput.value;

    if (!email || !password) {
        if (errorContainer) errorContainer.textContent = "Veuillez remplir tous les champs.";
        return;
    }

    // Validation du mot de passe
    if (password.length < 6) {
        if (errorContainer) errorContainer.textContent = "Le mot de passe doit contenir au moins 6 caractères.";
        return;
    }

    try {
        await createUserWithEmailAndPassword(auth, email, password);
        // Firebase `onAuthStateChanged` s'occupe de la redirection vers 'Onboarding'
    } catch (error) {
        const errorCode = error.code;
        console.error("Erreur d'inscription par email:", errorCode);
        if (errorContainer) {
             if (errorCode === 'auth/email-already-in-use') {
                errorContainer.textContent = "Cet email est déjà utilisé. Essayez de vous connecter.";
            } else {
                errorContainer.textContent = "Erreur d'inscription. Veuillez réessayer.";
            }
        }
    }
}

function handleAchievementsEvents(e) {
    
    // --- PARTIE 2 : GÉRER LE CHOIX D'UNE OPTION ---
    const sortOption = e.target.closest('.custom-select-option[data-type="achievements-sort"]');
    if (sortOption) {
        state.achievementsSortOrder = sortOption.dataset.value;
        render(); // On redessine simplement la page, le tri sera appliqué
        return; // On s'arrête ici
    }

    // --- PARTIE 3 : LOGIQUE EXISTANTE (DÉTAILS DU SUCCÈS) ---
    const achBtn = e.target.closest('[data-action="view-achievement"]');
    if (achBtn) {
        openAchievementDetailsModal(achBtn.dataset.id);
    }
}

const mainInputHandler = async e => {
    // --- NOUVEAU BLOC AJOUTÉ ---
    if(e.target.id === 'profile-pic-input') {
        handleProfilePictureChange(e);
    } 
    // --- LE RESTE EST INCHANGÉ ---
    else if(e.target.classList.contains('meal-checkbox')) {
    const checkbox = e.target;
    const event = state.calendarEvents.find(ev => ev.id === checkbox.dataset.eventId);
    if (event) {
        event.validated = checkbox.checked;
        updateStreaks();

        checkDailyMealQuests();
        checkDailyGoalQuests();
        // --- NOUVELLE LIGNE ---
        checkWeeklyNutritionQuests();
    }
    await saveState();
    render();
    } else if (state.activePage === 'WorkoutEditor' && e.target.id === 'workout-name-input') {
        if (state.editingWorkout) state.editingWorkout.name = e.target.value;
    } else if (state.activePage === 'MealEditor' && e.target.id === 'meal-name-input') {
        if (state.editingMeal) state.editingMeal.name = e.target.value;
    } 
    else if (state.activePage === 'MealEditor' && e.target.id === 'ingredient-search-input') {
        handleAutocompleteSearch(e);
    }
};

function addEventListeners() {
    // On retire les anciens écouteurs pour être sûr de ne pas en avoir plusieurs à la fois
    document.removeEventListener('click', mainClickHandler);
    document.removeEventListener('input', mainInputHandlerWithRouting);

    // On attache les écouteurs uniques et permanents
    document.addEventListener('click', mainClickHandler);
    document.addEventListener('input', mainInputHandlerWithRouting);
}

// Nous créons une nouvelle fonction pour gérer les 'input' de manière plus claire
function mainInputHandlerWithRouting(e) {
    if (e.target.closest('#profile-pic-input')) {
        handleProfilePictureChange(e);
        return;
    }

    // --- CORRECTION CLÉ CI-DESSOUS ---
    // On vérifie sur quelle page on se trouve pour appeler le bon gestionnaire d'événements.
    switch(state.activePage) {
        case 'SearchUsers':
            handleSearchUsersEvents(e);
            break;
        case 'Social':
            handleSocialEvents(e); // Maintenant, la recherche de clan va fonctionner
            break;
        default:
            // Pour toutes les autres pages, on appelle le gestionnaire par défaut
            mainInputHandler(e);
            break;
    }
    // --- FIN DE LA CORRECTION ---
}

async function openPublicClanViewModal(clanId, isNested = false) {
    showToast("Chargement de l'équipe...", "info");

    try {
        let successfulJoin = false;

        const clanRef = doc(db, 'clans', clanId);
        const clanSnap = await getDoc(clanRef);

        if (!clanSnap.exists()) {
            showToast("Cette équipe n'existe plus.", "error");
            return;
        }

        const clanData = { id: clanSnap.id, ...clanSnap.data() };
        const clanIcon = CLAN_ICONS.find(icon => icon.id === clanData.iconId) || { icon: 'fa-question-circle' };

        playClanMusic(clanData.clanMusic);
       
        const memberPromises = clanData.members.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
        const memberDocs = await Promise.all(memberPromises);
        let membersData = memberDocs.map(doc => doc.exists() ? doc.data() : null).filter(Boolean);

        membersData.sort((a, b) => (RANK_POINTS_MAP[b.globalRank] || 0) - (RANK_POINTS_MAP[a.globalRank] || 0));

        const { averageRank, color: rankColor } = calculateAverageRank(membersData);

        const membersListHtml = membersData.map(member => {
            const isChef = member.uid === clanData.chefUid;
            const memberForCard = { ...member, name: `${member.name} ${isChef ? '👑' : ''}` };
            return renderUnifiedUserCard(memberForCard, 'public-clan-member');
        }).join('');

        let buttonHtml = '';
        if (state.userProfile.clanId) {
            buttonHtml = `<button class="w-full mt-6 btn-primary opacity-60 cursor-not-allowed flex items-center justify-center gap-2" disabled><i class="fa-solid fa-user-check"></i><span>Vous êtes déjà dans une équipe</span></button>`;
        } else if (clanData.members.length >= 10) {
            buttonHtml = `<button class="w-full mt-6 btn-primary opacity-60 cursor-not-allowed flex items-center justify-center gap-2" disabled><i class="fa-solid fa-users"></i><span>Équipe complète</span></button>`;
        } else {
            buttonHtml = `<button id="join-clan-btn" data-clan-id="${clanId}" class="w-full mt-6 btn-primary">Rejoindre l'équipe</button>`;
        }

        const modalContent = `
        <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">

            <button class="close-modal absolute top-4 right-4 w-8 h-8 rounded-full bg-black/30 z-20 flex items-center justify-center">&times;</button>
            <header class="text-center mb-4 flex-shrink-0">
                <i class="fa-solid ${clanIcon.icon} text-5xl mb-2" style="color: var(--theme-primary);"></i>
                <h1 class="text-3xl font-extrabold">${clanData.name}</h1>
                <p class="text-gray-400 font-semibold">Membres : ${clanData.members.length} / 10</p>
                <p class="text-gray-400 font-semibold text-sm">
                    Rang: 
                    <span class="font-bold flex items-center gap-1.5" style="color: ${rankColor};">
                        ${getRankBadgeSVG(averageRank, '24px')}
                        <span>${averageRank}</span>
                    </span>
                </p>
            </header>
            <div class="flex-grow overflow-y-auto pr-2 space-y-2 scrollbar-hide min-h-0">
                ${membersListHtml}
            </div>
            ${buttonHtml}
        </div>`;

        const setupCallback = (modalWrapper) => {
            const joinBtn = modalWrapper.querySelector('#join-clan-btn');
            if (joinBtn) {
                joinBtn.onclick = async () => {
                    joinBtn.disabled = true;
                    joinBtn.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i>`;
                    const success = await joinClan(joinBtn.dataset.clanId);
                    if (success) {
                        successfulJoin = true; 
                        closeModal();
                    } else {
                        joinBtn.disabled = false;
                        joinBtn.innerHTML = "Rejoindre l'équipe";
                    }
                };
            }

            modalWrapper.addEventListener('click', (e) => {
                const profileBtn = e.target.closest('[data-action="view-public-profile"]');
                if (profileBtn) {
                    e.stopPropagation();
                    openPublicProfileModal(profileBtn.dataset.uid, true);
                }
            });
        };

        const closeCallback = () => {
            if (!successfulJoin) {
                if (state.userProfile.clanId && state.currentClanData) {
                    playClanMusic(state.currentClanData.clanMusic);
                } else {
                    stopClanMusic();
                }
            }
        };

        showModal(modalContent, setupCallback, closeCallback, isNested);

    } catch (error) {
        console.error("Erreur lors de l'ouverture du clan public:", error);
        showToast("Une erreur est survenue.", "error");
    }
}
        
        async function handleWorkoutEditorEvents(e) {
    if (!state.editingWorkout) return;
    const workout = state.editingWorkout;
    if (e.type === 'input' && e.target.id === 'workout-name-input') { workout.name = e.target.value; return; }
    if (e.type !== 'click') return;
    
    const actionButton = e.target.closest('[data-action]');
    if (!actionButton) return;
    const action = actionButton.dataset.action;

    if (action === 'save-workout') { await saveWorkout(); return; }
    if (action === 'cancel-workout') { navigate('Workouts'); return; }
    if (action === 'add-exercise') { openExerciseSelectionForNewGroup(); return; }

    const { groupId, group1Id, group2Id, exerciseIndex } = actionButton.dataset;

    if (action === 'open-exercise-editor') {
        openExerciseEditorModal(groupId, parseInt(exerciseIndex, 10));
        return;
    }
    
    if (action === 'remove-exercise-group') {
        const group = workout.groups.find(g => g.id === groupId);
        // Si c'est un superset, on retire juste un exercice
        if (group && group.type === 'superset' && group.exercises.length > 1) {
             group.exercises.splice(parseInt(exerciseIndex, 10), 1);
             if (group.exercises.length <= 1) group.type = 'single';
        } else { // Sinon on retire le groupe entier
            workout.groups = workout.groups.filter(g => g.id !== groupId);
        }
    }
    
    if (action === 'link-groups') {
        const index1 = workout.groups.findIndex(g => g.id === group1Id);
        const index2 = workout.groups.findIndex(g => g.id === group2Id);
        if (index1 === -1 || index2 === -1) return;

        const group1 = workout.groups[index1];
        const group2 = workout.groups[index2];

        // Fusionner les exercices
        const combinedExercises = [...group1.exercises, ...group2.exercises];
        
        // Créer un nouveau groupe superset
        const newSupersetGroup = { id: generateId(), type: 'superset', exercises: combinedExercises };
        
        // Remplacer les deux anciens groupes par le nouveau
        workout.groups.splice(index1, 2, newSupersetGroup);
    }
    
    if (action === 'unlink-group') {
        const groupIndex = workout.groups.findIndex(g => g.id === groupId);
        if (groupIndex !== -1) {
            const supersetGroup = workout.groups[groupIndex];
            const newSingleGroups = supersetGroup.exercises.map(ex => ({ id: generateId(), type: 'single', exercises: [ex] }));
            workout.groups.splice(groupIndex, 1, ...newSingleGroups);
        }
    }

    render();
}

// DANS VOTRE SCRIPT, REMPLACEZ la fonction handleExerciseEditorModalEvents

function handleExerciseEditorModalEvents(e, groupId, exerciseIndex) {
    const workout = state.editingWorkout;
    const group = workout.groups.find(g => g.id === groupId);
    const exercise = group.exercises[exerciseIndex];
    const contentDiv = document.getElementById('exercise-editor-modal-content');
    if (!contentDiv) return;

    // Nouvelle fonction qui ne met à jour que la liste des séries
    const updateSetListAndRestoreScroll = () => {
        const setsTimeline = contentDiv.querySelector('#sets-timeline');
        const scrollableContainer = contentDiv.querySelector('.overflow-y-auto');
        if (!setsTimeline || !scrollableContainer) return;
        
        const scrollPosition = scrollableContainer.scrollTop;

        // On utilise la nouvelle fonction pour ne redessiner que les <li>
        setsTimeline.innerHTML = renderSetListForEditor(exercise, state.editingExerciseMode);

        setTimeout(() => {
            if (scrollableContainer) scrollableContainer.scrollTop = scrollPosition;
        }, 0);
    };

    if (e.type === 'input') {
        // La gestion des 'input' est inchangée
        const input = e.target;
        const field = input.dataset.field;
        if (field === 'global-tempo') {
            if (!exercise.tempo) exercise.tempo = {};
            exercise.tempo[input.dataset.tempoPart] = input.value;
            return;
        }
        const setRow = input.closest('[data-set-index]');
        if (setRow) {
            const setIndex = parseInt(setRow.dataset.setIndex, 10);
            const set = exercise.sets[setIndex];
            if (set) {
                if (field === 'reps') set.reps = input.value;
                if (field === 'rpe') set.rpe = input.value;
                if (field === 'rest') set.rest = input.value;
            }
        }
        const dropRow = input.closest('[data-drop-index]');
        if(dropRow && setRow){
            const setIndex = parseInt(setRow.dataset.setIndex, 10);
            const dropIndex = parseInt(dropRow.dataset.dropIndex, 10);
            const set = exercise.sets[setIndex];
            if(set && set.drops && set.drops[dropIndex]){
                set.drops[dropIndex].reps = input.value;
            }
        }
        return;
    }
    
    if (e.type === 'click') {
        if (e.target.closest('.close-modal')) { closeModal(); return; }
        
        // Si on change de mode, un re-rendu complet est nécessaire
        if (e.target.closest('#mode-toggle')) {
            state.editingExerciseMode = e.target.checked ? 'advanced' : 'simple';
            renderExerciseEditorContent(contentDiv, groupId, exerciseIndex); // Re-rendu complet
            return;
        }

        const button = e.target.closest('[data-action]');
        if (!button) return;

        const action = button.dataset.action;
        const setRow = button.closest('[data-set-index]'); 
        const setIndex = setRow ? parseInt(setRow.dataset.setIndex, 10) : null;
        const set = setIndex !== null ? exercise.sets[setIndex] : null;
        
        // Logique pour modifier les données (inchangée)
        switch(action) {
            case 'add-set':
                if (!exercise.sets) exercise.sets = [];
                const lastSet = exercise.sets.at(-1);
                const newSet = lastSet ? JSON.parse(JSON.stringify(lastSet)) : { type: 'normal', reps: 10, rpe: null, rest: 90 };
                if (newSet.type === 'dropset') { delete newSet.drops; newSet.type = 'normal'; }
                exercise.sets.push(newSet);
                break;
            case 'remove-set':
                if (setIndex !== null) exercise.sets.splice(setIndex, 1);
                break;
            case 'add-technique-dropset':
                if(set) { set.type = 'dropset'; if (!set.drops) set.drops = [{ repsType: 'max' }]; }
                break;
            case 'remove-technique-dropset':
                if(set) { set.type = 'normal'; delete set.drops; }
                break;
            case 'add-drop':
                if(set && set.drops) set.drops.push({ repsType: 'max' });
                break;
            case 'remove-drop':
                if(set && set.drops) {
                    const dropIndex = parseInt(button.closest('.dropset-item').dataset.dropIndex, 10);
                    set.drops.splice(dropIndex, 1);
                }
                break;
            case 'toggle-drop-reps-type':
                if(set && set.drops) {
                    const dropIndex = parseInt(button.closest('.dropset-item').dataset.dropIndex, 10);
                    const drop = set.drops[dropIndex];
                    if (drop) {
                        drop.repsType = button.dataset.value;
                        if (drop.repsType === 'max') drop.reps = '';
                    }
                }
                break;
        }
        
        // On appelle la nouvelle fonction de mise à jour ciblée
        updateSetListAndRestoreScroll();
    }
}

// DANS index.html, AJOUTEZ CETTE NOUVELLE FONCTION

function setupWorkoutEditorDragAndDrop() {
    const container = document.getElementById('workout-editor-list');
    if (!container) return;

    let draggedItem = null;
    let draggedItemType = null; // 'group' ou 'exercise'

    const getDragAfterElement = (dragContainer, y, selector) => {
        const draggableElements = [...dragContainer.querySelectorAll(`${selector}:not(.dragging)`)];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    };

    container.addEventListener('dragstart', e => {
        const groupTarget = e.target.closest('.draggable-group');
        const exerciseTarget = e.target.closest('.draggable-exercise');

        if (exerciseTarget && exerciseTarget.closest('.superset-container')) {
            draggedItem = exerciseTarget;
            draggedItemType = 'exercise';
        } else if (groupTarget) {
            draggedItem = groupTarget;
            draggedItemType = 'group';
        } else { return; }
        setTimeout(() => draggedItem.classList.add('dragging'), 0);
    });
    
    container.addEventListener('dragend', () => {
        if(draggedItem) draggedItem.classList.remove('dragging');
        draggedItem = null;
        draggedItemType = null;
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        if (!draggedItem) return;

        let targetContainer, selector;
        if (draggedItemType === 'group') {
            targetContainer = container;
            selector = '.draggable-group';
        } else { // exercise
            const groupId = draggedItem.dataset.groupId;
            targetContainer = container.querySelector(`.superset-container[data-group-id="${groupId}"] .superset-exercises-list`);
            selector = `.draggable-exercise[data-group-id="${groupId}"]`;
        }

        const afterElement = getDragAfterElement(targetContainer, e.clientY, selector);
        container.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        if (afterElement) afterElement.classList.add('drag-over');
    });

    container.addEventListener('drop', e => {
        e.preventDefault();
        container.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        if (!draggedItem) return;

        const workout = state.editingWorkout;
        let animationTarget = null;
        let positionChanged = false;

        if (draggedItemType === 'group') {
            const fromId = draggedItem.dataset.groupId;
            const fromIndex = workout.groups.findIndex(g => g.id === fromId);
            const afterElement = getDragAfterElement(container, e.clientY, '.draggable-group');
            const toId = afterElement ? afterElement.dataset.groupId : null;
            let toIndex = toId ? workout.groups.findIndex(g => g.id === toId) : workout.groups.length;

            if (fromIndex > -1) {
                const [movedGroup] = workout.groups.splice(fromIndex, 1);
                if (fromIndex < toIndex) toIndex--;
                
                if (fromIndex !== toIndex) {
                    positionChanged = true;
                    animationTarget = { type: 'group', id: fromId };
                }
                workout.groups.splice(toIndex, 0, movedGroup);
            }
        } else { // exercise
            const groupId = draggedItem.dataset.groupId;
            const fromIndex = parseInt(draggedItem.dataset.exerciseIndex, 10);
            const group = workout.groups.find(g => g.id === groupId);
            if (!group) return;

            const targetContainer = container.querySelector(`.superset-exercises-list`);
            const afterElement = getDragAfterElement(targetContainer, e.clientY, `.draggable-exercise[data-group-id="${groupId}"]`);
            const toIndex = afterElement ? parseInt(afterElement.dataset.exerciseIndex, 10) : group.exercises.length;
            
            const [movedExercise] = group.exercises.splice(fromIndex, 1);
            let adjustedToIndex = toIndex;
            if (fromIndex < toIndex) adjustedToIndex--;

            if (fromIndex !== adjustedToIndex) {
                positionChanged = true;
                animationTarget = { type: 'exercise', groupId: groupId, newIndex: adjustedToIndex };
            }
            group.exercises.splice(adjustedToIndex, 0, movedExercise);
        }
        
        render();

        if (positionChanged && animationTarget) {
            setTimeout(() => {
                let elementToAnimate = null;
                if (animationTarget.type === 'group') {
                    elementToAnimate = document.querySelector(`.draggable-group[data-group-id="${animationTarget.id}"]`);
                } else if (animationTarget.type === 'exercise') {
                    elementToAnimate = document.querySelector(`.draggable-exercise[data-group-id="${animationTarget.groupId}"][data-exercise-index="${animationTarget.newIndex}"]`);
                }

                if (elementToAnimate) {
                    elementToAnimate.classList.add('drop-settle');
                    elementToAnimate.addEventListener('animationend', () => {
                        elementToAnimate.classList.remove('drop-settle');
                    }, { once: true });
                }
            }, 50);
        }
    });
}

// NOUVELLE FONCTION D'AIDE pour ouvrir la sélection d'exercice
function openExerciseSelectionForNewGroup() {
    const modalContent = `<div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col"><header class="flex justify-between items-center mb-4 flex-shrink-0"><h2 class="text-2xl font-bold">Choisir un exercice</h2><button class="close-modal w-8 h-8 rounded-full bg-white/10">×</button></header><div class="relative mb-4 flex-shrink-0"><i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i><input id="search-exercise-input-group" type="text" placeholder="Rechercher..." class="input-glass pl-12 w-full"></div><div id="exercise-selection-list-group" class="flex-grow overflow-y-auto space-y-2 pr-2"></div></div>`;
    
    showModal(modalContent, (modalWrapper) => {
        const searchInput = modalWrapper.querySelector('#search-exercise-input-group');
        const selectionList = modalWrapper.querySelector('#exercise-selection-list-group');

        const renderList = (filter = '') => {
            const normalizedFilter = filter.toLowerCase();
            const filteredExercises = EXERCISE_DATABASE.filter(ex => ex.name.toLowerCase().includes(normalizedFilter));
            selectionList.innerHTML = filteredExercises.map(ex => `<button class="select-exercise-for-group-btn w-full text-left glass-card hover:bg-white/20 p-3 rounded-lg" data-exercise-id="${ex.id}">${ex.name}</button>`).join('');
        };

        selectionList.onclick = (e) => {
            const btn = e.target.closest('.select-exercise-for-group-btn');
            if (btn) {
                const exerciseId = btn.dataset.exerciseId;
                
                // On crée un nouveau groupe 'single' avec cet exercice
                const newGroup = {
                    id: generateId(),
                    type: 'single',
                    exercises: [{
                        exerciseId: exerciseId,
                        // On met des valeurs par défaut pour les séries
                        sets: [
                            { type: 'normal', reps: 10, load: '' },
                            { type: 'normal', reps: 10, load: '' },
                            { type: 'normal', reps: 10, load: '' }
                        ]
                    }]
                };
                
                if (!state.editingWorkout.groups) state.editingWorkout.groups = [];
                state.editingWorkout.groups.push(newGroup);
                
                closeModal();
                render();
            }
        };
        
        searchInput.oninput = (e) => renderList(e.target.value);
        renderList();
    });
}

function openExerciseSelectionForGroupModal(groupId, exerciseIndex) {
    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Choisir un exercice</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">×</button>
        </header>
        <div class="relative mb-4 flex-shrink-0">
            <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
            <input id="search-exercise-input-group" type="text" placeholder="Rechercher..." class="input-glass pl-12 w-full">
        </div>
        <div id="exercise-selection-list-group" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        const searchInput = modalWrapper.querySelector('#search-exercise-input-group');
        const selectionList = modalWrapper.querySelector('#exercise-selection-list-group');

        const renderList = (filter = '') => {
            const normalizedFilter = filter.toLowerCase();
            const filteredExercises = EXERCISE_DATABASE.filter(ex => ex.name.toLowerCase().includes(normalizedFilter));
            selectionList.innerHTML = filteredExercises.map(ex => `<button class="select-exercise-for-group-btn w-full text-left glass-card hover:bg-white/20 p-3 rounded-lg" data-exercise-id="${ex.id}">${ex.name}</button>`).join('');
        };

        selectionList.onclick = (e) => {
            const btn = e.target.closest('.select-exercise-for-group-btn');
            if (btn) {
                const exerciseId = btn.dataset.exerciseId;
                const group = state.editingWorkout.groups.find(g => g.id === groupId);
                
                // On met à jour l'exercice dans le groupe
                group.exercises[exerciseIndex].exerciseId = exerciseId;
                
                closeModal();
                render();
            }
        };
        
        searchInput.oninput = (e) => renderList(e.target.value);
        renderList();
    });
}

function openAddWorkoutGroupModal() {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <h2 class="text-2xl font-bold mb-4 text-center">Ajouter un bloc de travail</h2>
        <div class="space-y-3">
            <button data-group-type="single" class="add-group-option w-full text-left glass-card p-4 rounded-lg hover:bg-white/10">
                <p class="font-bold"><i class="fa-solid fa-square w-6 text-center text-gray-400 mr-2"></i>Exercice Seul</p>
                <p class="text-xs text-gray-500 ml-10">Un exercice classique avec ses séries.</p>
            </button>
            <button data-group-type="superset" class="add-group-option w-full text-left glass-card p-4 rounded-lg hover:bg-white/10">
                <p class="font-bold"><i class="fa-solid fa-link w-6 text-center text-violet-400 mr-2"></i>Superset</p>
                <p class="text-xs text-gray-500 ml-10">Enchaînement de deux exercices sans repos.</p>
            </button>
            </div>
        <button class="close-modal w-full mt-6 glass-card p-3 rounded-lg font-bold">Annuler</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelectorAll('.add-group-option').forEach(btn => {
            btn.onclick = () => {
                const type = btn.dataset.groupType;
                let newGroup = { id: generateId(), type, exercises: [] };

                // On pré-remplit le groupe avec des exercices "vides"
                switch(type) {
                    case 'single':
                        newGroup.exercises.push({ exerciseId: null, sets: [{type: 'normal', reps: 10, load: ''}] });
                        break;
                    case 'superset':
                        newGroup.exercises.push({ exerciseId: null, reps: 10, load: '' });
                        newGroup.exercises.push({ exerciseId: null, reps: 10, load: '' });
                        newGroup.sets = 3; // Pour un superset, le nombre de séries est au niveau du groupe
                        break;
                }
                
                state.editingWorkout.groups.push(newGroup);
                closeModal();
                render();
            };
        });
    });
}

function openAdvancedExerciseEditModal(groupId, exerciseIndex) {
    const workout = state.editingWorkout;
    const group = workout.groups.find(g => g.id === groupId);
    const exercise = group.exercises[exerciseIndex];
    const exerciseInfo = getExerciseById(exercise.exerciseId);

    let openAccordions = {};

    const renderModalContent = (modalWrapper) => {
        if (!exercise.tempo || typeof exercise.tempo !== 'object') {
            exercise.tempo = { ecc: '', pause1: '', con: '', pause2: '' };
        }

        const modalHtml = `
        <div class="glass-card w-full max-w-lg p-6 rounded-t-3xl border-none h-[90vh] flex flex-col">
            <header class="flex-shrink-0">
                <h2 class="text-2xl font-bold">${exerciseInfo.name}</h2>
                <p class="text-sm text-gray-400 mb-4">Configurez les options avancées.</p>
                <div class="glass-card p-3 rounded-xl">
                    <label class="font-bold text-lg">Tempo de l'exercice</label>
                    <p class="text-xs text-gray-400 mb-2">S'applique à toutes les séries.</p>
                    <div class="flex items-center justify-center gap-1 bg-black/30 p-1 rounded-lg">
                        <div class="flex flex-col items-center"><label class="text-[10px] text-gray-400">Excentrique</label><input type="number" data-field="global-tempo" data-tempo-part="ecc" value="${exercise.tempo.ecc || ''}" class="w-16 bg-transparent text-center focus:outline-none text-lg"></div><span>-</span>
                        <div class="flex flex-col items-center"><label class="text-[10px] text-gray-400">Pause Basse</label><input type="number" data-field="global-tempo" data-tempo-part="pause1" value="${exercise.tempo.pause1 || ''}" class="w-16 bg-transparent text-center focus:outline-none text-lg"></div><span>-</span>
                        <div class="flex flex-col items-center"><label class="text-[10px] text-gray-400">Concentrique</label><input type="number" data-field="global-tempo" data-tempo-part="con" value="${exercise.tempo.con || ''}" class="w-16 bg-transparent text-center focus:outline-none text-lg"></div><span>-</span>
                        <div class="flex flex-col items-center"><label class="text-[10px] text-gray-400">Pause Haute</label><input type="number" data-field="global-tempo" data-tempo-part="pause2" value="${exercise.tempo.pause2 || ''}" class="w-16 bg-transparent text-center focus:outline-none text-lg"></div>
                    </div>
                </div>
            </header>
            <div id="modal-sets-container" class="flex-grow overflow-y-auto space-y-3 my-4 pr-2 scrollbar-hide">
                ${(exercise.sets || []).map(renderSetRow).join('')}
            </div>
            <div class="flex-shrink-0 space-y-4 pt-4 border-t border-white/10">
                <button id="modal-save-btn" class="w-full btn-primary">Valider</button>
            </div>
        </div>`;
        modalWrapper.innerHTML = modalHtml;
    };
    
    const renderSetRow = (set, index) => {
        set.loadType = set.loadType || 'kg';
        const isDropset = set.type === 'dropset';

        const dropsHtml = (set.drops || []).map((drop, dropIndex) => {
            drop.repsType = drop.repsType || 'max';
            return `
            <div class="flex items-center gap-2 mt-2" data-drop-index="${dropIndex}">
                <span class="text-xs text-gray-400 w-14 flex-shrink-0">Drop ${dropIndex + 1}</span>
                <div class="p-0.5 bg-black/30 rounded-full flex text-xs w-20">
                    <button data-action="toggle-drop-reps-type" data-value="max" class="flex-1 py-1 rounded-full ${drop.repsType === 'max' ? 'bg-gray-500 text-black font-bold' : ''}">Max</button>
                    <button data-action="toggle-drop-reps-type" data-value="fixed" class="flex-1 py-1 rounded-full ${drop.repsType === 'fixed' ? 'bg-gray-500 text-black font-bold' : ''}">Fixe</button>
                </div>
                <input type="number" data-field="drop-reps" value="${drop.repsType === 'fixed' ? drop.reps || '' : ''}" class="input-glass !p-2 text-sm w-20" placeholder="Reps" ${drop.repsType === 'max' ? 'disabled' : ''}>
                <button data-action="remove-drop" data-drop-index="${dropIndex}" class="text-red-500 w-8 h-8 rounded-full hover:bg-red-500/20"><i class="fa-solid fa-xmark"></i></button>
            </div>`;
        }).join('');
        
        return `
        <div class="p-3 bg-black/20 rounded-xl set-row" data-index="${index}">
            <div class="flex items-center gap-3">
                <span class="font-bold text-lg text-gray-500 w-8 text-center">${index + 1}</span>
                <div class="p-0.5 bg-black/30 rounded-full flex text-xs">
                    <button data-action="toggle-load-type" data-value="kg" class="px-3 py-1 rounded-full ${set.loadType === 'kg' ? 'bg-gray-500 text-black font-bold' : ''}">Poids</button>
                    <button data-action="toggle-load-type" data-value="rpe" class="px-3 py-1 rounded-full ${set.loadType === 'rpe' ? 'bg-gray-500 text-black font-bold' : ''}">RPE</button>
                </div>
                <input type="text" data-field="reps" class="input-glass !p-2 text-center w-24" value="${set.reps || ''}" placeholder="Reps">
                <button data-action="remove-set" class="text-red-500 w-8 h-8 rounded-full hover:bg-red-500/20"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="flex items-center gap-3 mt-3 pl-10">
                <label class="text-xs font-semibold text-gray-400">Technique</label>
                <div class="p-1 bg-black/30 rounded-full flex text-xs">
                    <button data-action="toggle-technique" data-technique="normal" class="px-3 py-1 rounded-full ${!isDropset ? 'bg-violet-500 text-black font-bold' : ''}">Normale</button>
                    <button data-action="toggle-technique" data-technique="dropset" class="px-3 py-1 rounded-full ${isDropset ? 'bg-violet-500 text-black font-bold' : ''}">Dropset</button>
                </div>
            </div>
             ${isDropset ? `<details class="mt-2 dropset-details" data-index="${index}" ${openAccordions[index] ? 'open' : ''}>
                <summary class="text-xs font-semibold text-violet-400 cursor-pointer list-none"><span>${(set.drops || []).length} Paliers</span></summary>
                <div class="pl-6 pt-2 border-l-2 border-violet-800/50 ml-2">${dropsHtml}<button data-action="add-drop" class="text-violet-400 text-xs font-semibold mt-3 hover:text-violet-300">+ Ajouter un palier</button></div>
             </details>` : ''}
        </div>`;
    };

    showModal(null, (modalWrapper) => {
        renderModalContent(modalWrapper);
        
        modalWrapper.addEventListener('click', e => {
            const button = e.target.closest('button[data-action]');
            if (!button) return;

            const action = button.dataset.action;
            const setRow = button.closest('.set-row');
            const setIndex = setRow ? parseInt(setRow.dataset.index, 10) : null;
            const set = setIndex !== null ? exercise.sets[setIndex] : null;
            
            if (action === 'modal-save-btn') {
                closeModal();
                window.render();
                return;
            }
            if (set) {
                switch (action) {
                    case 'remove-set':
                        exercise.sets.splice(setIndex, 1);
                        break;
                    case 'toggle-technique':
                        set.type = button.dataset.technique;
                        if (set.type === 'dropset' && !set.drops) set.drops = [];
                        break;
                    case 'toggle-load-type':
                        set.loadType = button.dataset.value;
                        break;
                    case 'add-drop':
                        if (!set.drops) set.drops = [];
                        set.drops.push({ repsType: 'max' });
                        openAccordions[setIndex] = true;
                        break;
                    case 'remove-drop':
                        const dropIndex = parseInt(button.closest('[data-drop-index]').dataset.dropIndex, 10);
                        set.drops.splice(dropIndex, 1);
                        openAccordions[setIndex] = true;
                        break;
                    case 'toggle-drop-reps-type':
                        const dropRepsIndex = parseInt(button.closest('[data-drop-index]').dataset.dropIndex, 10);
                        const drop = set.drops[dropRepsIndex];
                        drop.repsType = button.dataset.value;
                        if (drop.repsType === 'max') drop.reps = '';
                        openAccordions[setIndex] = true;
                        break;
                }
            }
            renderModalContent(modalWrapper);
        });

        modalWrapper.addEventListener('input', e => {
            const input = e.target;
            const field = input.dataset.field;

            if (field === 'global-tempo') {
                exercise.tempo[input.dataset.tempoPart] = input.value;
            } else {
                const setRow = input.closest('.set-row');
                if (!setRow) return;
                const setIndex = parseInt(setRow.dataset.index, 10);
                const set = exercise.sets[setIndex];
                if (field === 'reps') set.reps = input.value;
                if (field === 'drop-reps') {
                    const dropIndex = parseInt(input.closest('[data-drop-index]').dataset.dropIndex, 10);
                    set.drops[dropIndex].reps = input.value;
                }
            }
        });

        modalWrapper.addEventListener("toggle", (e) => {
            const details = e.target.closest('.dropset-details');
            if (details) {
                const setIndex = parseInt(details.dataset.index, 10);
                openAccordions[setIndex] = details.open;
            }
        }, true);
    });
}

        function handleWorkoutPlayerEvents(e) {
    if (e.target.closest('#finish-set-btn')) finishSet();
    else if (e.target.closest('#skip-rest-btn')) nextPlayerStep();
    else if (e.target.closest('#view-session-recap')) openSessionRecapModal();
    // CORRECTION : Logique pour les boutons +/- du poids
    else if (e.target.closest('[data-action="increment-weight"]')) {
        const input = document.getElementById('weight-input');
        let value = parseFloat(input.value) || 0;
        input.value = (value + 0.25).toFixed(2);
    }
    else if (e.target.closest('[data-action="decrement-weight"]')) {
        const input = document.getElementById('weight-input');
        let value = parseFloat(input.value) || 0;
        input.value = Math.max(0, value - 0.25).toFixed(2);
    }
    else if (e.target.closest('#end-workout-btn')) {
        const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center"><h2 class="text-xl font-bold mb-2">Arrêter la séance ?</h2><p class="text-gray-400 mb-6">La progression sera perdue.</p><div class="flex gap-4"><button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button><button id="confirm-end" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Arrêter</button></div></div>`;
        showModal(modalContent, (modalWrapper) => {
            modalWrapper.querySelector('#confirm-end').onclick = () => {
                if (playerTimer) clearInterval(playerTimer);
                if (sessionDurationTimer) clearInterval(sessionDurationTimer);
                playerTimer = null;
                sessionDurationTimer = null;
                state.activeWorkoutSession = null;
                closeModal();
                navigate('Accueil');
            };
        });
    }
}
        
async function handleMealEditorEvents(e) {
    // Find the existing line that handles the click on the parent card
    const fitscoreCard = e.target.closest('[data-action="open-fitscore-details"]');
    const fitscoreInfoBtn = e.target.closest('#fitscore-info-btn');

    if (fitscoreInfoBtn) {
        e.stopPropagation(); // Prevents the click from propagating to the parent card
        openFitScoreInfoModal(); // Opens the new info modal
    } 
    // Keep the rest of the existing logic for the parent card
    else if (fitscoreCard) {
        const meal = state.editingMeal;
        if (meal && meal.ingredients.length > 0) {
            openFitScoreDetailsModal(meal);
        }
    }
    // --- Le reste de la fonction est inchangé ---
    else if (e.target.closest('#save-meal-btn')) {
        saveMeal();
    } 
    else if (e.target.closest('#cancel-meal-btn')) {
        if(state.editingMeal?.isQuickAdd) navigate('Accueil');
        else navigate('Repas');
    }
    else if (e.target.closest('#show-details-btn')) {
        openMealDetailsModal();
    }
    else if (e.target.closest('.delete-ingredient-btn')) {
        const ingId = e.target.closest('.delete-ingredient-btn').dataset.ingId;
        state.editingMeal.ingredients = state.editingMeal.ingredients.filter(ing => ing.id !== ingId);
        await saveState();
        render();
    }
    else if (e.target.closest('.edit-ingredient-btn')) {
        openEditIngredientModal(e.target.closest('.edit-ingredient-btn').dataset.ingId);
    }
    else if (e.target.closest('#open-delete-meal-confirmation-btn')) {
         const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center"><h2 class="text-xl font-bold mb-2">Supprimer le repas ?</h2><p class="text-gray-400 mb-6">Cette action est irréversible.</p><div class="flex gap-4"><button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button><button id="confirm-delete-meal-btn" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Supprimer</button></div></div>`;
        showModal(modalContent, (modalWrapper) => {
            modalWrapper.querySelector('#confirm-delete-meal-btn').onclick = async () => {
                const mealId = document.getElementById('meal-editor-page').dataset.mealId;
                state.meals = state.meals.filter(m => m.id !== mealId);
                state.calendarEvents = state.calendarEvents.filter(ev => ev.refId !== mealId);
                state.editingMeal = null;
                closeModal();
                await saveState()
                navigate('Repas');
            };
        });
    } 
    else if (e.target.closest('#scan-barcode-btn')) {
         startScanner(state.editingMeal?.isQuickAdd);
    } 
    else if (e.target.closest('#autocomplete-results')) {
        const resultDiv = e.target.closest('[data-index]');
        if(resultDiv) {
            const foodItem = currentSearchResults[parseInt(resultDiv.dataset.index)];
            if(foodItem) {
                addIngredientToMeal(foodItem, state.editingMeal?.isQuickAdd);
                document.getElementById('ingredient-search-input').value = '';
                document.getElementById('autocomplete-results').innerHTML = '';
            }
        }
    }
    else if (e.target.closest('#open-tag-selection-modal')) {
        openTagSelectionModal('meal');
    }
    else if (e.target.closest('.remove-tag-btn')) {
        const tagId = e.target.closest('.remove-tag-btn').dataset.tagId;
        state.editingMeal.tags = state.editingMeal.tags.filter(id => id !== tagId);
        await saveState();
        render();
    }
}

        // --- REMPLACEZ COMPLÈTEMENT VOTRE FONCTION handleShopEvents PAR CELLE-CI ---

function handleShopEvents(e) {
    // Clic sur un onglet (Box, Bordures, Titres)
    const tabBtn = e.target.closest('.shop-tab-btn');
    if (tabBtn) {
        state.shop.activeTab = tabBtn.dataset.tab;
        render();
        // On réinitialise la position de défilement pour un effet plus propre
        setTimeout(() => {
            const scrollArea = document.querySelector('.shop-content-scroll-area');
            if (scrollArea) {
                scrollArea.scrollTo(0, 0);
            }
        }, 10);
        return;
    }

    // NOUVEAU: Clic sur le bouton d'information des raretés
    const rarityInfoBtn = e.target.closest('#open-rarity-info-btn');
    if (rarityInfoBtn) {
        openRarityInfoModal();
        return;
    }

    // Clic sur une option de tri
    const sortOption = e.target.closest('.custom-select-option');
    if (sortOption && sortOption.dataset.type) {
        const type = sortOption.dataset.type;
        const value = sortOption.dataset.value;

        // On définit l'objet qui contient le texte des labels de tri (si ce n'est pas déjà global)
        const sortLabels = {
            'possession': 'Par possession',
            'rarity_asc': 'Rareté croissante',
            'rarity_desc': 'Rareté décroissante'
        };

        state.shop[`${type}SortOrder`] = value;

        const parentContainer = sortOption.closest('.custom-select-container');
        parentContainer.querySelector('.shop-sort-options').classList.remove('active');
        parentContainer.querySelector('.shop-sort-button').classList.remove('active');
        
        // --- LOGIQUE ANTI-FLICKER CORRIGÉE ---
        if (type === 'collectibles') {
            // 1. Mise à jour de la liste (ce que vous faisiez déjà)
            document.getElementById('collection-list-container').innerHTML = renderCollectionList();
            
            // 2. LIGNE AJOUTÉE : Mise à jour du texte du bouton de tri
            parentContainer.querySelector('.shop-sort-button span').textContent = sortLabels[value];

        } else {
            // Pour les autres onglets, on garde le render global
            render();
        }
        return;
    }
    
    // Logique d'achat (inchangée)
    const buyBoxBtn = e.target.closest('#buy-box-btn');
    if (buyBoxBtn) {
        buyAndOpenBox(buyBoxBtn);
        return;
    }
    const buyBorderBtn = e.target.closest('.buy-border-btn');
    if (buyBorderBtn) {
        const itemCard = buyBorderBtn.closest('.glass-card');
        buyItem(buyBorderBtn.dataset.itemId, 'border', buyBorderBtn, itemCard);
        return;
    }
    const buyTitleBtn = e.target.closest('.buy-title-btn');
    if (buyTitleBtn) {
        const itemCard = buyTitleBtn.closest('.glass-card');
        buyItem(buyTitleBtn.dataset.itemId, 'title', buyTitleBtn, itemCard);
        return;
    }
}

        function getRandomCollectible() {
    const rarityTable = [
        { rarity: 'Commun', chance: 0.55 },
        { rarity: 'Rare', chance: 0.27 },
        { rarity: 'Épique', chance: 0.12 },
        { rarity: 'Légendaire', chance: 0.04 },
        { rarity: 'Mythique', chance: 0.015 },
        { rarity: 'Divin', chance: 0.005 } // 0.5% de chance
    ];

    const random = Math.random();
    let cumulativeChance = 0;

    for (const tier of rarityTable) {
        cumulativeChance += tier.chance;
        if (random < cumulativeChance) {
            const itemsOfRarity = COLLECTIBLES_DATABASE.filter(item => item.rarity === tier.rarity);
            if (itemsOfRarity.length > 0) {
                return itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
            }
        }
    }
    // Failsafe au cas où
    return COLLECTIBLES_DATABASE.find(item => item.rarity === 'Commun');
}

        function showBoxOpeningModal(wonItem) {
    const rarityColors = {
        'Commun': 'text-gray-400',
        'Rare': 'text-blue-400',
        'Épique': 'text-purple-400',
        'Légendaire': 'text-white-400',
        'Mythique': 'text-yellow-300',
        'Divin': 'text-cyan-300' // Couleur pour la nouvelle rareté
    };

    const modalContent = `
    <div class="glass-card p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center" style="animation: fadeInModal 0.5s forwards;">
        <p class="font-bold ${rarityColors[wonItem.rarity]} mb-4">${wonItem.rarity}</p>
        <div class="w-32 h-32 flex items-center justify-center mb-4">
            <i class="fa-solid ${wonItem.icon} text-8xl ${wonItem.color}"></i>
        </div>
        <h3 class="text-2xl font-bold">${wonItem.name}</h3>
        <button class="close-modal w-full mt-8 btn-primary">Super !</button>
    </div>`;

    // Ce callback sera exécuté à la fermeture de la modale,
    // peu importe la manière (bouton, clic à côté, etc.)
    const updateCollectionCallback = () => {
        // LOGIQUE ANTI-FLICKER : On met à jour uniquement la liste et le compteur
        const listContainer = document.getElementById('collection-list-container');
        if (listContainer) {
            listContainer.innerHTML = renderCollectionList();
        }
        const unlockedCounter = document.querySelector('.w-full.max-w-sm .text-sm.text-gray-400.font-semibold');
        if (unlockedCounter) {
            const unlockedCount = state.userProfile.inventory.collectibles.length;
            unlockedCounter.textContent = `(${unlockedCount}/${COLLECTIBLES_DATABASE.length} débloqués)`;
        }
    };
    
    // Le premier argument (setupCallback) est null car nous n'avons pas d'action spécifique à l'ouverture,
    // seulement à la fermeture.
    showModal(modalContent, null, updateCollectionCallback);
}

        async function buyAndOpenBox(buttonElement) {
            const boxCost = 250;
            if (state.userProfile.coins < boxCost) {
                animateButtonFailure(buttonElement); // Shake button on failure
                return;
            }

            state.userProfile.coins -= boxCost;
            const wonItem = getRandomCollectible();
            
            if (wonItem && !state.userProfile.inventory.collectibles.includes(wonItem.id)) {
                 state.userProfile.inventory.collectibles.push(wonItem.id);
            }

            updateAchievementProgress('shop_first_purchase', 1, 'set');
    updateAchievementProgress('spendthrift', boxCost, 'increment');
    updateAchievementProgress('collector_initiate', 1, 'increment');
    updateAchievementProgress('collection_complete', 1, 'increment');
            
            // Animate the box button's container (the glass-card).
            const boxCardElement = buttonElement.closest('.glass-card'); 
            if (boxCardElement) {
                animateItemPurchaseSuccess(boxCardElement); 
            }

            // Manually update coins display instead of full render()
            document.querySelector('.glass-card.px-4.py-2.rounded-full.font-bold.text-yellow-300').textContent = `${state.userProfile.coins.toLocaleString('fr-FR')} `;
            document.querySelector('.glass-card.px-4.py-2.rounded-full.font-bold.text-yellow-300').innerHTML += `<i class="fa-solid fa-coins ml-1"></i>`;

            checkRarityAchievement();
            showBoxOpeningModal(wonItem); // This modal will trigger a render() when it closes.
            // DO NOT CALL render() here: render(); 
            await saveState();
        }

        async function buyItem(itemId, itemType, buttonElement, itemCardElement) {
            const db = itemType === 'border' ? BORDERS_DATABASE : TITLES_DATABASE;
            const item = db.find(i => i.id === itemId);

            if (!item || item.cost === undefined) return;

            if (state.userProfile.coins < item.cost) {
                animateButtonFailure(buttonElement); // Shake the specific buy button
                return;
            }

            const inventory = itemType === 'border' ? state.userProfile.inventory.borders : state.userProfile.inventory.titles;
            if (inventory.includes(itemId)) {
                // If already owned, no specific animation needed, as the button should be disabled
                return;
            }

            state.userProfile.coins -= item.cost;
            inventory.push(itemId);

            updateAchievementProgress('shop_first_purchase', 1, 'set');
    updateAchievementProgress('spendthrift', item.cost, 'increment');
    if (item.rarity === 'Légendaire') {
        updateAchievementProgress('legendary_owner', 1, 'set');
    }
            
            // Animate the item card for success
            animateItemPurchaseSuccess(itemCardElement);
            
            // MANUALLY UPDATE THE UI INSTEAD OF CALLING render()
            // 1. Update the button to "Possédé" and disable it
            buttonElement.textContent = 'Possédé';
            buttonElement.disabled = true;
            buttonElement.classList.remove('btn-primary');
            buttonElement.classList.add('glass-card'); // Apply the 'glass-card' style
            
            // 2. Update the coin display in the header
            document.querySelector('.glass-card.px-4.py-2.rounded-full.font-bold.text-yellow-300').textContent = `${state.userProfile.coins.toLocaleString('fr-FR')} `;
            document.querySelector('.glass-card.px-4.py-2.rounded-full.font-bold.text-yellow-300').innerHTML += `<i class="fa-solid fa-coins ml-1"></i>`;

            // DO NOT CALL render() here: render(); 
            checkRarityAchievement();
            await saveState();
        }

        function openStatDetailsModal(statType) {
            const thisWeek = getWeeklyStats(0);
            const lastWeek = getWeeklyStats(1);

            let config = {};
            switch (statType) {
                case 'sessions':
                    config = { title: "Séances de la Semaine", icon: 'fa-dumbbell', value: thisWeek.sessions, lastValue: lastWeek.sessions, format: (v) => v };
                    break;
                case 'hours':
                    // On utilise formatDuration en convertissant les heures en millisecondes
                    config = { title: "Heures d'Entraînement", icon: 'fa-clock', value: thisWeek.hours, lastValue: lastWeek.hours, format: (v) => formatDuration(v * 3600000) };
                    break;
                case 'volume':
                    // On utilise formatVolume qui gère déjà les kg, tonnes, etc.
                    config = { title: "Volume Soulevé", icon: 'fa-weight-hanging', value: thisWeek.volume, lastValue: lastWeek.volume, format: (v) => formatVolume(v) };
                    break;
            }

            let percentageChange = 0;
            if (config.lastValue > 0) {
                percentageChange = ((config.value - config.lastValue) / config.lastValue) * 100;
            } else if (config.value > 0) {
                percentageChange = 100;
            }

            const isPositive = percentageChange >= 0;
            const changeColor = isPositive ? 'text-green-400' : 'text-red-400';
            const changeIcon = isPositive ? 'fa-arrow-up' : 'fa-arrow-down';

            // Les fonctions de formatage incluent déjà l'unité, donc on les appelle directement
            const lastWeekDisplay = config.lastValue > 0 ? `${config.format(config.lastValue)}` : 'N/A';
            const comparisonText = (config.value > 0 || config.lastValue > 0) ? `<p class="text-sm mt-2 ${changeColor} font-semibold">
                        <i class="fa-solid ${changeIcon}"></i> ${percentageChange.toFixed(0)}% vs la semaine dernière
                    </p>` : `<p class="text-sm mt-2 text-gray-500">Aucune donnée à comparer</p>`;

            const modalContent = `
            <div class="glass-card p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
                <i class="fa-solid ${config.icon} text-4xl text-violet-300 mb-4"></i>
                <h2 class="text-2xl font-bold">${config.title}</h2>
                
                <p class="text-6xl font-extrabold my-4">${config.format(config.value)}</p>
                
                <div class="w-full bg-black/20 p-4 rounded-xl">
                    <p class="text-xs font-bold text-gray-400">Semaine Passée</p>
                    <p class="text-4xl font-bold mt-1">${lastWeekDisplay}</p>
                    ${comparisonText}
                </div>

                <button class="close-modal w-full mt-8 glass-card p-3 rounded-lg font-bold">Fermer</button>
            </div>`;
            showModal(modalContent);
        }

        function openPublicUserLevelDetailsModal(publicProfileData) {
    const { leveling } = publicProfileData;
    const displayInfo = getDisplayLevelInfo(leveling.realLevel);
    const levelColors = getLevelTierColors(leveling.realLevel);
    
    const totalXPForPreviousLevels = calculateTotalXPToReachLevel(leveling.realLevel);
    const xpNeededToCompleteLevel = calculateXPForLevel(leveling.realLevel);
    const xpInCurrentLevel = leveling.xp - totalXPForPreviousLevels;
    const xpPercentage = (xpInCurrentLevel / xpNeededToCompleteLevel) * 100;

    // CORRECTION : Le titre est maintenant dans un conteneur centré.
    const modalHeaderHtml = `
        <header class="flex justify-center items-center w-full mb-6 z-10 flex-shrink-0">
            <h2 class="text-2xl font-bold text-center">Progression de ${publicProfileData.name}</h2>
        </header>`;

    if (leveling.isMaxedOut) {
        const modalContent = `
        <div class="level-details-modal level-details-modal-maxed p-6 rounded-3xl w-full max-w-sm text-center flex flex-col items-center min-h-[520px]">
            ${modalHeaderHtml} 
            <div class="starfield"><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div></div>
            <div class="flex-grow flex flex-col justify-center w-full">
                <p class="font-bold text-yellow-300 uppercase tracking-widest z-10">Niveau Maximum Atteint</p>
                <h2 class="level-display-main max-level-animated-badge z-10" style="font-size: 8rem; filter: drop-shadow(0 0 15px #FDE047);">MAX</h2>
                <div class="w-full border-t border-yellow-400/20 my-6 z-10"></div>
                <div class="grid grid-cols-2 gap-4 w-full z-10">
                    <div class="stat-card">
                        <p class="text-xs text-gray-400 font-semibold uppercase">Niveau Global</p>
                        <p id="global-level-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p>
                    </div>
                    <div class="stat-card">
                        <p class="text-xs text-gray-400 font-semibold uppercase">XP Total</p>
                        <p id="total-xp-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p>
                    </div>
                </div>
            </div>
            <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold z-10 flex-shrink-0">Fermer</button>
        </div>`;
        showModal(modalContent, (modalWrapper) => {
            animateCounter(document.getElementById('global-level-counter'), 0, leveling.realLevel, 1500);
            animateCounter(document.getElementById('total-xp-counter'), 0, leveling.xp, 1500);
        }, null, true);
        return;
    }

    const levelGlowStyle = `color: ${levelColors.color}; text-shadow: 0 0 ${displayInfo.displayLevel * 0.15}px ${levelColors.color};`;
    const xpBarGlowStyle = `width: ${xpPercentage}%; background-color: ${levelColors.color}; box-shadow: 0 0 12px ${levelColors.color}; opacity: ${0.4 + (xpPercentage * 0.006)};`;
    const titleAnimationClass = displayInfo.prestigeTier >= 9 ? 'max-level-animated-badge' : '';

    const modalContent = `
    <div class="level-details-modal p-6 rounded-3xl w-full max-w-sm text-center flex flex-col items-center min-h-[520px]">
        ${modalHeaderHtml}
        <div class="nebula-bg" style="--nebula-color: ${levelColors.color};"></div>
        <div class="grid grid-cols-2 gap-4 w-full z-10 flex-shrink-0">
            <div class="stat-card"><p class="text-xs text-gray-400 font-semibold uppercase">Niveau Global</p><p id="global-level-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p></div>
            <div class="stat-card"><p class="text-xs text-gray-400 font-semibold uppercase">XP Total</p><p id="total-xp-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p></div>
        </div>
        <div class="relative z-10 flex-grow flex flex-col justify-center w-full my-4">
            <h2 class="level-display-main ${titleAnimationClass}" style="${levelGlowStyle}">Niv. ${displayInfo.displayLevel}</h2>
            ${displayInfo.prestige > 0 ? `<div class="flex items-center justify-center gap-2 mt-2">${Array.from({ length: displayInfo.prestige }, () => `<i class="fa-solid fa-star text-yellow-400 text-2xl" style="filter: drop-shadow(0 0 5px #FBBF24);"></i>`).join('')}</div>` : ''}
        </div>
        <div class="w-full relative z-10 flex-shrink-0">
            <div class="w-full h-2.5 bg-black/30 rounded-full border border-white/10"><div class="h-full rounded-full" style="${xpBarGlowStyle}"></div></div>
            <p class="text-sm text-gray-300 font-semibold tracking-tighter mt-2">Progression</p>
        </div>
        <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold z-10 flex-shrink-0">Fermer</button>
    </div>`;
    showModal(modalContent, (modalWrapper) => {
        animateCounter(document.getElementById('global-level-counter'), 0, leveling.realLevel, 1500);
        animateCounter(document.getElementById('total-xp-counter'), 0, leveling.xp, 1500);
    }, null, true);
}

function openPublicUserRankDetailsModal(publicProfileData) {
            // --- MODIFICATION APPLIQUÉE ICI ---
            // On récupère maintenant globalRank ET totalSr depuis les données du profil public
            const { globalRank, muscleGroupRanks, totalSr } = publicProfileData;
            
            // On appelle toujours la fonction pour obtenir la bonne couleur
            const { globalRankColor } = calculateGlobalRank(globalRank); 
            
            const muscleGroupsHtml = Object.keys(MUSCLE_GROUPS).map(key => {
                const groupRank = (muscleGroupRanks && muscleGroupRanks[key]) ? muscleGroupRanks[key] : 'N/A';
                const rankBaseName = groupRank.split(' ')[0];
                const groupColor = getRankColor(rankBaseName);
                return `
                    <div class="flex items-center justify-between py-3 border-b border-white/10">
                        <span class="font-semibold">${MUSCLE_GROUPS[key]}</span>
                        <span class="font-bold" style="color: ${groupColor.main};">${groupRank}</span>
                    </div>`;
            }).join('');

            // On réintroduit l'affichage du SR Total dans le HTML
            const modalContent = `
                <div class="rank-modal-content p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
                    <h3 class="font-semibold text-lg text-gray-300 mb-2 z-10">Rank de ${publicProfileData.name}</h3>
                    <div class="relative w-32 h-32 mb-4 rank-badge-container">${getRankBadgeSVG(globalRank)}</div>
                    <div class="relative z-10 w-full">
                        <h2 class="text-4xl font-extrabold mb-6">
                            ${globalRank} ${totalSr > 0 ? `<span class="text-yellow-300 text-3xl">+${totalSr} SR</span>` : ''}
                        </h2>
                        <div class="w-full bg-black/20 p-4 rounded-xl text-left space-y-2">
                            ${muscleGroupsHtml}
                        </div>
                        <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold">Fermer</button>
                    </div>
                </div>`;
            // --- FIN DE LA MODIFICATION ---

            showModal(modalContent, null, null, true);
        }

        function openFitScoreDetailsModal(meal) {
    if (!meal || !meal.ingredients || meal.ingredients.length === 0) return;

    const { finalScore: mealScore, adjustments } = calculateMealFitScore(meal);
    const mealScoreColor = getFitScoreColor(mealScore);

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <header class="text-center mb-4">
            <h2 class="text-2xl font-bold">Analyse du Score</h2>
        </header>
        
        <div class="text-center mb-4">
            <p class="text-7xl font-extrabold" style="color: ${mealScoreColor}; filter: drop-shadow(0 0 10px ${mealScoreColor}60);">${mealScore}</p>
        </div>

        ${(adjustments && Object.values(adjustments).some(v => v !== 0)) ? `
        <div class="mb-4">
            <h3 class="font-semibold text-sm text-gray-400 mb-2 text-center">Ajustements d'Équilibre</h3>
            <div class="glass-card p-3 rounded-lg space-y-2 text-sm">
                ${adjustments.sugarMalus < 0 ? `<div class="flex justify-between items-center"><span><i class="fa-solid fa-candy-cane text-red-400 mr-2"></i>Malus Sucres</span><span class="font-bold text-red-400">${adjustments.sugarMalus.toFixed(0)}</span></div>` : ''}
                ${adjustments.satFatMalus < 0 ? `<div class="flex justify-between items-center"><span><i class="fa-solid fa-bacon text-red-400 mr-2"></i>Malus Graisses Saturées</span><span class="font-bold text-red-400">${adjustments.satFatMalus.toFixed(0)}</span></div>` : ''}
                ${adjustments.proteinBonus > 0 ? `<div class="flex justify-between items-center"><span><i class="fa-solid fa-drumstick-bite text-green-400 mr-2"></i>Bonus Protéines</span><span class="font-bold text-green-400">+${adjustments.proteinBonus.toFixed(0)}</span></div>` : ''}
                ${adjustments.completenessBonus > 0 ? `<div class="flex justify-between items-center"><span><i class="fa-solid fa-leaf text-green-400 mr-2"></i>Bonus Repas Complet</span><span class="font-bold text-green-400">+${adjustments.completenessBonus.toFixed(0)}</span></div>` : ''}
            </div>
        </div>
        ` : ''}

        <div class="bg-black/20 p-4 rounded-xl">
            <h3 class="font-semibold text-center mb-2">Détail par ingrédient</h3>
            <div class="text-sm text-gray-300 space-y-2 max-h-32 overflow-y-auto pr-2 scrollbar-hide">
                ${meal.ingredients.map(ing => {
                    const scoreResult = calculateIngredientFitScore(ing);
                    let grade = 'N/A';
                    let gradeColor = '#6B7280';
                    
                    if (scoreResult !== null) {
                        grade = convertScoreToGrade(scoreResult.score);
                        gradeColor = getFitScoreColor(scoreResult.score);
                    }
                    
                    return `<div class="flex items-center">
                        <span class="flex-grow truncate pr-2">${ing.name}</span>
                        <span class="font-mono font-bold flex-shrink-0" style="color: ${gradeColor}">
                            ${grade}
                        </span>
                    </div>`;
                }).join('')}
            </div>
        </div>
        <button class="close-modal w-full mt-8 btn-primary">Fermer</button>
    </div>`;
    
    showModal(modalContent);
}

async function sendSystemMessage(recipientUid, subject, content, icon = 'fa-robot') {
    if (!recipientUid) return;
    try {
        await addDoc(collection(db, 'inboxMessages'), {
            recipientUid: recipientUid,
            senderUid: 'fitflow_system', // Un identifiant pour les messages automatiques
            senderName: 'FitFlow System',
            type: 'system_alert', // Un nouveau type de message pour les distinguer
            subject: subject,
            content: content,
            systemIcon: icon,
            timestamp: serverTimestamp(),
            isRead: false
        });
        console.log("Message système envoyé avec succès à", recipientUid);
    } catch (error) {
        console.error("Erreur lors de l'envoi du message système:", error);
    }
}

        // === CETTE FONCTION EST LA SEULE VERSION À GARDER ===
        function handleAccueilEvents(e) {
            if (e.target.closest('#open-level-details-btn')) { // <-- AJOUTEZ CE BLOC
        openLevelDetailsModal();
    }
            if (e.target.closest('#start-workout-btn') && !e.target.closest('#start-workout-btn').classList.contains('opacity-30')) {
                startWorkout(e.target.closest('#start-workout-btn').dataset.eventId);
            } else if (e.target.closest('#quick-add-food-btn')) {
                openQuickAddFood();
            } else if (e.target.closest('[data-action="open-streak-info"]')) {
                openStreakInfoModal(e.target.closest('[data-action="open-streak-info"]').dataset.type);
            }
            else if (e.target.closest('[data-action="open-stat-modal"]')) {
                const statType = e.target.closest('[data-action="open-stat-modal"]').dataset.statType;
                openStatDetailsModal(statType);
            }
            else if (e.target.closest('#open-quests-modal')) {
        openQuestsModal();
    }
    else if (e.target.closest('#open-guide-modal')) {
                openGuideModal();
            }
            else if (e.target.closest('#add-test-xp-btn')) {
                addXP(9999999);
            }
        }

        async function handleWorkoutsEvents(e) {
    // --- BLOC CORRIGÉ ---
    const sortOption = e.target.closest('#workout-sort-options .custom-select-option');
    if (sortOption) {
        const value = sortOption.dataset.value;
        state.workoutsSortOrder = value; // Met à jour l'état avec le nouvel ordre

        // Met à jour le texte du bouton de tri
        const buttonText = document.querySelector('#workout-sort-button span');
        if (buttonText) {
            const sortOrderLabels = { 'alpha': 'Ordre Alphabétique', 'favorite': 'Favoris en premier', 'exo_asc': 'Moins d\'exercices', 'exo_desc': 'Plus d\'exercices' };
            buttonText.textContent = sortOrderLabels[value];
        }

        closeAllDropdowns(); // Ferme le menu
        render(); // Redessine la page avec la liste triée
        return;
    }
    // --- FIN DU BLOC CORRIGÉ ---

    const favoriteBtn = e.target.closest('.toggle-favorite-btn');
    if (favoriteBtn) {
        e.stopPropagation();
        const workoutId = favoriteBtn.dataset.id;
        const workout = state.workouts.find(w => w.id === workoutId);
        if (workout) {
            workout.isFavorite = !workout.isFavorite;
            await saveState();
            render();
        }
        return;
    }

    const startBtn = e.target.closest('[data-action="start-now"]');
    if (startBtn) {
        e.stopPropagation();
        startWorkoutFromTemplate(startBtn.dataset.id);
        return;
    }

    if (e.target.closest('#add-workout-btn')) {
    // ANCIENNE LIGNE :
    // const newWorkout = { id: generateId(), name: 'Nouvelle Séance', exercises: [], isFavorite: false, tags: [] };
    
    // NOUVELLE LIGNE :
     const newWorkout = { 
        id: generateId(), 
        name: 'Nouvelle Séance', 
        // On revient à un simple tableau d'exercices.
        // La structure avancée (groupes) sera gérée par l'éditeur SEULEMENT.
        exercises: [], 
        isFavorite: false, 
        tags: [] 
    };

    state.editingWorkout = newWorkout;
    // On passe un nouveau paramètre pour signaler que c'est une création
    navigate('WorkoutEditor', { id: newWorkout.id, isNew: true });
}
}

        async function handleRepasEvents(e) {
            const favoriteBtn = e.target.closest('.toggle-meal-favorite-btn');
            if (favoriteBtn) {
                e.stopPropagation();
                const mealId = favoriteBtn.dataset.id;
                const meal = state.meals.find(m => m.id === mealId);
                if (meal) {
                    meal.isFavorite = !meal.isFavorite;
                    await saveState();
                    render();
                }
                return;
            }

            const sortOption = e.target.closest('#meal-sort-options .custom-select-option');
            if (sortOption) {
                state.mealsSortOrder = sortOption.dataset.value;
                optionsContainer.classList.remove('active');
render();
                return;
            }

            if (e.target.closest('[data-action="open-goals-modal"]')) {
                openGoalsModal();
                return;
            }

            if (e.target.closest('#add-meal-btn')) {
                const newMeal = { id: generateId(), name: 'Nouveau Repas', ingredients: [], nutrition: { calories: 0, protein: 0, carbs: 0, fat: 0 }, isQuickAdd: false, isFavorite: false, tags: [] };
                state.editingMeal = newMeal;
                navigate('MealEditor', { id: newMeal.id, isNew: true });
            }
        }
        
        function handleDashboardEvents(e) {
            const periodButton = e.target.closest('#dashboard-period-filter button');
            if (periodButton && periodButton.dataset.period) {
                state.dashboard.period = periodButton.dataset.period;
                render(); // On redessine toute la page du dashboard avec la nouvelle période
                return;
            }
            if (e.target.closest('#show-history-btn')) {
                openSessionHistoryModal();
            } else if (e.target.closest('[data-action="open-dashboard-help"]')) {
                updateAchievementProgress('rewarded_curiosity', 'dashboard_help', 'add_to_set');
                openDashboardHelpModal();
            } else if (e.target.closest('[data-action="open-sessions-details"]')) {
                openSessionsModal();
            } else if (e.target.closest('[data-action="open-time-details"]')) {
                openTimeModal();
            } else if (e.target.closest('[data-action="open-volume-details"]')) {
                openVolumeModal();
            }

            const option = e.target.closest('#exercise-select-options .custom-select-option');
            if (option && optionsContainer) {
                state.selectedChartExerciseId = option.dataset.value;
                optionsContainer.classList.remove('active');
                render();
            }
        }

        async function handleProfilEvents(e) {
    const profileToEdit = state.tempUserProfile;
    if (!profileToEdit) return;

    // --- NOUVEAU : Déclenchement de l'upload et de la suppression ---
    if (e.target.closest('#profile-pic-container')) {
        document.getElementById('profile-pic-input').click();
        return;
    }
    if (e.target.closest('#remove-profile-pic-btn')) {
        profileToEdit.profilePicUrl = null;
        render(); // On redessine juste la page de profil pour voir le changement
        return;
    }
    // --- FIN DES AJOUTS ---

    // Le reste de la fonction est inchangé
    if (e.target.closest('#change-border-btn')) {
        openItemSelectorModal('border');
        return;
    }
    const equipTitleBtn = e.target.closest('#equip-title-btn');
    if (equipTitleBtn) {
        openItemSelectorModal('title');
        return;
    }
    const showcaseBtn = e.target.closest('[data-action="equip-showcase"]');
    if (showcaseBtn) {
        openItemSelectorModal('collectible', parseInt(showcaseBtn.dataset.slotIndex));
        return;
    }

    const countryOption = e.target.closest('#country-select-options .custom-select-option');
    if (countryOption) {
        profileToEdit.country = countryOption.dataset.value;
        render();
        return;
    }

    const sexOption = e.target.closest('#sex-select-options .custom-select-option');
    if (sexOption) {
        profileToEdit.sex = sexOption.dataset.value;
        render();
        return;
    }

    if (e.target.closest('#become-creator-btn')) {
        state.userProfile.isCreator = true;
        await saveState();
        showToast('Félicitations, vous êtes maintenant un vendeur !', 'success');
        render(); // On redessine la page pour afficher le nouveau bouton
        return;
    }
    
    // Logique de sauvegarde
    if (e.target.closest('#save-profile-btn')) {
        // ... (toute la logique de sauvegarde, validation, titres secrets reste la même) ...
        const nameInput = document.getElementById('profile-name');
        const dobInput = document.getElementById('profile-dob');

        const weightInput = document.getElementById('goal-bodyweight');
        const weightError = document.getElementById('weight-error-message');
        let weightValue = parseFloat(weightInput.value);

        // 1. Validation du minimum et des décimales
        if (isNaN(weightValue) || weightValue < 1) {
            weightValue = 1; // Force la valeur minimale à 1 si vide ou inférieur
        }
        // Arrondit à 2 décimales pour être sûr
        weightValue = Math.round(weightValue * 100) / 100;
        // Met à jour la valeur dans le champ pour que l'utilisateur la voie
        weightInput.value = weightValue.toFixed(2);

        // 2. Validation du maximum
        const maxWeight = 999.99;
        if (weightValue > maxWeight) {
            const weightHumor = [
                "Êtes-vous sûr de ne pas peser une voiture ?",
                "Félicitations, vous avez le poids d'un petit éléphant.",
                "Ce poids semble... gravitationnellement incorrect.",
                "Je pense que ma base de données va exploser.",
                "Même Thor ne pèse pas aussi lourd avec son marteau."
            ];

            let currentMessage;
            // On boucle tant que le message choisi est le même que le dernier message mémorisé
            do {
                currentMessage = weightHumor[Math.floor(Math.random() * weightHumor.length)];
            } while (weightHumor.length > 1 && currentMessage === lastWeightHumorMessage); // On utilise notre nouvelle variable dédiée

            // On mémorise le message qui va être affiché pour la prochaine fois
            lastWeightHumorMessage = currentMessage;
            // Affiche un message humoristique aléatoire
            weightError.textContent = currentMessage;
            
            // Ajoute l'animation de "secousse"
            weightInput.classList.add('animate-shake');
            weightInput.addEventListener('animationend', () => {
                weightInput.classList.remove('animate-shake');
            }, { once: true });
            
            return; // Bloque la sauvegarde
        }

        // Si tout est correct, on s'assure que le message d'erreur est vide
        weightError.textContent = '';

        const normalizedName = nameInput.value.trim().toLowerCase();
        const dob = dobInput.value;

        let titlesToUnlock = [];
        const titlesDatabase = {
            't-gymbro-originel': {
                names: ['léo liénard', 'mathéo duchemin', 'mathieu tornil', 'hugo revel', 'anouk le floch', 'nazim benhadid', 'léo pelofi', 'ewen lebourlay'],
                dobs: ['2004-01-03', '2004-09-07', '2004-05-26', '2004-06-04', '2003-11-05', '2004-03-26', '2004-07-13', '2004-06-12'],
                message: "Tu as débloqué le titre 'Gymbro Originel' !\nTu fais partie des fondateurs de FitFlow.\nTon soutien dès les débuts est inestimable.\nPorte fièrement ce titre !"
            },
            't-pompier-muscle': {
                names: ['guilhem papaseit'],
                dobs: ['2002-06-11'],
                message: "Tu as débloqué le titre 'Pompier Musclé' !\nUn grand bravo pour ta force et ton courage.\nPorte fièrement ce titre !"
            },
            't-the-bench-monster': {
                names: ['ewen lebourlay'],
                dobs: ['2004-06-12'],
                message: "Tu as débloqué le titre 'The Bench Monster' !\nTu êtes la force incarnée.\nPorte fièrement ce titre !"
            },
            't-createur-supreme': {
                names: ['lilian rivière'],
                dobs: ['2004-08-26'],
                message: "Tu as débloqué le titre 'The Gym Dev' !\nMerci pour ce travail acharné.\nPorte fièrement ce titre !"
            }
        };

        Object.keys(titlesDatabase).forEach(titleId => {
            const titleData = titlesDatabase[titleId];
            if (titleData.names.includes(normalizedName) && titleData.dobs.includes(dob) && !state.userProfile.inventory.titles.includes(titleId)) {
                titlesToUnlock.push({ id: titleId, message: titleData.message });
            }
        });

        state.userProfile.name = nameInput.value;
        state.userProfile.dob = dobInput.value;
        state.userGoals.bodyWeight = weightValue;
        state.userProfile.country = profileToEdit.country;
        state.userProfile.sex = profileToEdit.sex;
        state.userProfile.equipped = JSON.parse(JSON.stringify(profileToEdit.equipped));
        state.userProfile.profilePicUrl = profileToEdit.profilePicUrl;
        
        state.tempUserProfile = null;

        if (titlesToUnlock.length > 0) {
            let gymbroTitle = titlesToUnlock.find(t => t.id === 't-gymbro-originel');
            let benchMonsterTitle = titlesToUnlock.find(t => t.id === 't-the-bench-monster');

            if (gymbroTitle && benchMonsterTitle) {
                const combinedMessage = `Tu as débloqué les titres '${TITLES_DATABASE.find(t => t.id === 't-the-bench-monster').name}' et '${TITLES_DATABASE.find(t => t.id === 't-gymbro-originel').name}' !\nFélicitations pour cette double performance.\nPorte-les fièrement !`;
                state.userProfile.inventory.titles.push('t-the-bench-monster');
                state.userProfile.inventory.titles.push('t-gymbro-originel');
                showUnlockModal(['t-the-bench-monster', 't-gymbro-originel'], combinedMessage);
            } else {
                titlesToUnlock.forEach(unlockedTitle => {
                    state.userProfile.inventory.titles.push(unlockedTitle.id);
                    if (unlockedTitle.id === 't-createur-supreme') {
        updateAchievementProgress('secret_dev_achievement', 1, 'set');
    }
                    showUnlockModal([unlockedTitle.id], unlockedTitle.message);
                });
            }
        } else {
            await saveState();
            showToast('Profil sauvegardé avec succès !', 'success');
            navigate('Accueil');
        }
    } else if (e.target.closest('[data-action="cancel-profile-edit"]')) {
        state.tempUserProfile = null;
        navigate('Accueil');
    } else if (e.target.closest('#weight-info-btn')) {
        updateAchievementProgress('rewarded_curiosity', 'weight_info', 'add_to_set');
        const modalContent = `
        <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center relative">
            <button class="close-modal absolute top-4 right-4 w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
            <i class="fa-solid fa-weight-scale text-4xl mb-4" style="color: var(--theme-primary);"></i>
            <h2 class="text-xl font-bold mb-2">Importance du Poids</h2>
            <p class="text-gray-300">Votre poids est essentiel pour calculer la justesse de vos Rangs. Il nous permet d'évaluer votre force relative (force/poids) sur de nombreux exercices et d'ajuster les scores pour une progression juste et personnalisée.</p>
        </div>`;
        showModal(modalContent);
    }
}

async function handleCreatorSpaceEvents(e) {
    // Action : Créer un tout nouveau programme
    const createBtn = e.target.closest('#create-new-program-btn');
    if (createBtn) {
        // On initialise un nouveau programme vide basé sur notre schéma Blueprint
        state.editingProgram = {
            id: generateId(), // On assigne un ID unique dès le début
            status: 'draft',
            title: 'Nouveau Programme',
            description: '',
            bannerImageUrl: '',
            themeColor: '#A78BFA',
            price: 500,
            type: 'workout',
            // On pré-remplit avec une structure de base pour guider le créateur
            content: [
                {
                    id: generateId(),
                    title: "Phase 1: Nouvelle Phase",
                    goal: "Objectif à définir",
                    weeks: [
                        {
                            id: generateId(),
                            title: "Semaine 1",
                            notes: "",
                            days: [ // On commence avec 4 jours par défaut
                                { id: generateId(), title: `Jour 1`, blocks: [] },
                                { id: generateId(), title: `Jour 2`, blocks: [] },
                                { id: generateId(), title: `Jour 3`, blocks: [] },
                                { id: generateId(), title: `Jour 4`, blocks: [] }
                            ]
                        }
                    ]
                }
            ]
        };
        // On navigue vers notre nouvel éditeur
        navigate('ProgramStudio');
        return;
    }

    // Action : Modifier un brouillon existant
    const editBtn = e.target.closest('[data-action="edit-draft"]');
    if (editBtn) {
        const programId = editBtn.dataset.programId;
        const programToEdit = state.creatorPrograms.find(p => p.id === programId);
        
        if (programToEdit) {
            // On charge une copie du brouillon dans l'état d'édition
            state.editingProgram = JSON.parse(JSON.stringify(programToEdit));
            navigate('ProgramStudio');
        } else {
            showToast("Erreur : Impossible de trouver ce brouillon.", "error");
        }
        return;
    }
}

function findWeekInState(weekId) {
    // Sécurité : on vérifie que le programme et son contenu existent
    if (!state.editingProgram || !state.editingProgram.content) {
        return null;
    }

    // On parcourt chaque phase
    for (const phase of state.editingProgram.content) {
        // On vérifie si la phase a bien un tableau de semaines
        if (phase.weeks && Array.isArray(phase.weeks)) {
            // On cherche la semaine avec le bon ID
            const week = phase.weeks.find(w => w.id === weekId);
            // Si on la trouve, on la retourne immédiatement
            if (week) {
                return week;
            }
        }
    }

    // Si on a parcouru tout le programme sans trouver la semaine, on retourne null
    return null;
}

async function handleProgramStudioEvents(e) {
    if (!state.editingProgram || !e.target.closest('#program-studio-page')) return;

    // --- GESTION DES INPUTS ---
    if (e.type === 'input') {
        const target = e.target;
        // Onglet "Infos"
        if (target.dataset.field && state.programStudio.activeTab === 'info') {
            const field = target.dataset.field;
            if (['title', 'description', 'bannerImageUrl', 'themeColor'].includes(field)) {
                state.editingProgram[field] = target.value;
            } else if (field === 'price') {
                state.editingProgram[field] = parseInt(target.value, 10) || 0;
            }
        }
        // Titres des Phases et Semaines dans l'onglet "Structure"
        if (state.programStudio.activeTab === 'structure') {
            const phaseId = target.dataset.phaseId;
            const weekId = target.dataset.weekId;
            if (phaseId) {
                const phase = state.editingProgram.content.find(p => p.id === phaseId);
                if (phase) phase.title = target.value;
            } else if (weekId) {
                const week = findWeekById(weekId);
                if (week) week.title = target.value;
            }
        }
        return; // On arrête ici pour les inputs
    }

    if (e.type !== 'click') return;

    // --- GESTION DES CLICS ---
    const tabButton = e.target.closest('.studio-tab-btn');
    if (tabButton) {
        state.programStudio.activeTab = tabButton.dataset.tab;
        render();
        return;
    }

    const actionButton = e.target.closest('[data-action]');
    if (!actionButton) return;

    const { action, phaseId, weekId, dayId } = actionButton.dataset;

    const program = state.editingProgram;
    const tabs = ['info', 'structure', 'publish'];
    const currentIndex = tabs.indexOf(state.programStudio.activeTab);

    switch (action) {
        // --- Actions du Header ---
        case 'go-back': navigate('CreatorSpace'); break;
        case 'save-draft':
            const existingIndex = state.creatorPrograms.findIndex(p => p.id === program.id);
            if (existingIndex > -1) {
                state.creatorPrograms[existingIndex] = JSON.parse(JSON.stringify(program));
            } else {
                state.creatorPrograms.push(JSON.parse(JSON.stringify(program)));
            }
            showToast("Brouillon sauvegardé !", "success");
            navigate('CreatorSpace');
            break;
        case 'next-step':
            if (currentIndex < tabs.length - 1) {
                state.programStudio.activeTab = tabs[currentIndex + 1];
                render();
            }
            break;
        case 'prev-step':
            if (currentIndex > 0) {
                state.programStudio.activeTab = tabs[currentIndex - 1];
                render();
            }
            break;

        // --- Actions de la Toile de Structure ---
        case 'add-phase':
            program.content.push({ id: generateId(), title: `Phase ${program.content.length + 1}`, weeks: [] });
            render();
            break;
        case 'delete-phase':
            program.content = program.content.filter(p => p.id !== phaseId);
            render();
            break;
        case 'add-week-to-phase':
            const phaseForNewWeek = program.content.find(p => p.id === phaseId);
            if (phaseForNewWeek) {
                phaseForNewWeek.weeks.push({ id: generateId(), title: `Semaine ${phaseForNewWeek.weeks.length + 1}`, days: [] });
                render();
            }
            break;
        case 'delete-week':
            program.content.forEach(p => {
                p.weeks = p.weeks.filter(w => w.id !== weekId);
            });
            render();
            break;
        case 'add-day-to-week':
            const weekForNewDay = findWeekById(weekId);
            if (weekForNewDay) {
                weekForNewDay.days.push({ id: generateId(), title: `Jour ${weekForNewDay.days.length + 1}`, blocks: [] });
                render();
            }
            break;
        case 'delete-day':
             e.stopPropagation(); // Empêche l'ouverture de l'éditeur de jour
             const weekForDeletedDay = findWeekById(weekId);
             if(weekForDeletedDay){
                 weekForDeletedDay.days = weekForDeletedDay.days.filter(d => d.id !== dayId);
                 render();
             }
            break;
        case 'edit-day':
            const dayToEdit = findDayById(dayId);
            if (dayToEdit) {
                state.editingDay = dayToEdit;
                openBlockEditorPanel(); // Ouvre le panneau latéral
            }
            break;
    }
}

function findDayById(dayId) {
    if (!state.editingProgram || !state.editingProgram.content) return null;
    for (const phase of state.editingProgram.content) {
        for (const week of phase.weeks) {
            const day = week.days.find(d => d.id === dayId);
            if (day) return day;
        }
    }
    return null;
}

function findWeekById(weekId) {
    if (!state.editingProgram || !state.editingProgram.content) return null;
    for (const phase of state.editingProgram.content) {
        const week = phase.weeks.find(w => w.id === weekId);
        if (week) return week;
    }
    return null;
}

function openBlockLibraryModal() {
    const blockTypes = [
        // Blocs Actifs FitFlow
        { type: 'workout', name: 'Séance', icon: 'fa-dumbbell', color: 'text-violet-400' },
        { type: 'exercise_focus', name: 'Focus Exercice', icon: 'fa-bullseye', color: 'text-violet-400' },
        { type: 'pr_challenge', name: 'Défi PR', icon: 'fa-star', color: 'text-yellow-400' },
        { type: 'meal', name: 'Repas', icon: 'fa-utensils', color: 'text-green-400' },
        
        // Blocs Pédagogiques
        { type: 'text', name: 'Texte', icon: 'fa-paragraph', color: 'text-gray-300' },
        { type: 'video', name: 'Vidéo', icon: 'fa-video', color: 'text-red-400' },
        { type: 'image_gallery', name: 'Galerie', icon: 'fa-images', color: 'text-blue-400' },

        // Blocs Interactifs
        { type: 'checkpoint', name: 'Checkpoint', icon: 'fa-flag-checkered', color: 'text-green-400' },
        { type: 'quiz', name: 'Quiz', icon: 'fa-question-circle', color: 'text-orange-400' },
    ];

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <h2 class="text-2xl font-bold mb-4 text-center">Bibliothèque de Blocs</h2>
        <div class="grid grid-cols-3 gap-3">
            ${blockTypes.map(block => `
                <button data-block-type="${block.type}" class="add-block-type-btn glass-card hover:bg-white/10 p-4 rounded-lg flex flex-col items-center justify-center gap-2 aspect-square">
                    <i class="fa-solid ${block.icon} text-2xl ${block.color}"></i>
                    <span class="font-semibold text-xs text-center">${block.name}</span>
                </button>
            `).join('')}
        </div>
        <button class="close-modal w-full mt-6 glass-card p-3 rounded-lg font-bold">Annuler</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelectorAll('.add-block-type-btn').forEach(btn => {
            btn.onclick = () => {
                addBlockToDay(btn.dataset.blockType);
            };
        });
    }, null, true); // true = modale imbriquée
}

function openEditBlockModal(blockIndex) {
    const block = state.editingProgram.programContent[blockIndex];
    if (!block) return;

    switch(block.type) {
        case 'day_separator':
            openEditSeparatorModal(blockIndex);
            break;
        case 'text':
            openEditTextModal(blockIndex);
            break;
        case 'workout':
            openSelectWorkoutForBlockModal(blockIndex);
            break;
        case 'meal':
            openSelectMealForBlockModal(blockIndex);
            break;
        // Ajoutez d'autres cas ici pour les futurs types de blocs
        default:
            showToast("Ce type de bloc n'est pas encore éditable.", "info");
    }
}

function openEditSeparatorModal(blockIndex) {
    const block = state.editingProgram.programContent[blockIndex];
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl">
        <h2 class="text-xl font-bold mb-4">Modifier le Séparateur</h2>
        <input id="separator-title-input" type="text" class="input-glass" value="${block.content.title}">
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="save-separator-btn" class="w-full btn-primary">Valider</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#save-separator-btn').onclick = () => {
            block.content.title = wrapper.querySelector('#separator-title-input').value;
            closeModal();
            render();
        };
    });
}

// Modale pour éditer un bloc TEXTE (version simple)
function openEditTextModal(blockIndex) {
    const block = state.editingProgram.programContent[blockIndex];
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl">
        <h2 class="text-xl font-bold mb-4">Modifier le Texte</h2>
        <textarea id="text-content-input" class="input-glass h-48 resize-none">${block.content.html.replace(/<p>|<\/p>/g, '')}</textarea>
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="save-text-btn" class="w-full btn-primary">Valider</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#save-text-btn').onclick = () => {
            const rawText = wrapper.querySelector('#text-content-input').value;
            block.content.html = `<p>${rawText.replace(/\n/g, '</p><p>')}</p>`; // Conversion simple en HTML
            closeModal();
            render();
        };
    });
}

// Modale pour SÉLECTIONNER une séance
function openSelectWorkoutForBlockModal(blockIndex) {
    const block = state.editingProgram.programContent[blockIndex];
    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[70vh] flex flex-col">
        <h2 class="text-2xl font-bold mb-4">Changer la séance</h2>
        <div class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide">
            ${state.workouts.map(w => `
                <button data-id="${w.id}" class="select-item-for-program w-full text-left glass-card p-3 rounded-lg hover:bg-white/20 ${block.content.refId === w.id ? 'bg-white/10' : ''}">
                    <p class="font-semibold">${w.name}</p>
                </button>
            `).join('')}
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.addEventListener('click', e => {
            const selectBtn = e.target.closest('.select-item-for-program');
            if(selectBtn) {
                block.content.refId = selectBtn.dataset.id;
                closeModal();
                render();
            }
        });
    });
}

// Modale pour SÉLECTIONNER un repas
function openSelectMealForBlockModal(blockIndex) {
    const block = state.editingProgram.programContent[blockIndex];
    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[70vh] flex flex-col">
        <h2 class="text-2xl font-bold mb-4">Changer le repas</h2>
        <div class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide">
            ${state.meals.filter(m => !m.isQuickAdd).map(m => `
                <button data-id="${m.id}" class="select-item-for-program w-full text-left glass-card p-3 rounded-lg hover:bg-white/20 ${block.content.refId === m.id ? 'bg-white/10' : ''}">
                    <p class="font-semibold">${m.name}</p>
                </button>
            `).join('')}
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.addEventListener('click', e => {
            const selectBtn = e.target.closest('.select-item-for-program');
            if(selectBtn) {
                block.content.refId = selectBtn.dataset.id;
                closeModal();
                render();
            }
        });
    });
}

function openAddBlockModal() {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <h2 class="text-2xl font-bold mb-4 text-center">Ajouter un bloc</h2>
        <div class="grid grid-cols-2 gap-3">
            <button data-block-type="day_separator" class="add-block-option glass-card hover:bg-white/10 p-4 rounded-lg flex flex-col items-center justify-center gap-2"><i class="fa-solid fa-calendar-day text-2xl"></i><span class="font-semibold text-sm">Séparateur de Jour</span></button>
            <button data-block-type="text" class="add-block-option glass-card hover:bg-white/10 p-4 rounded-lg flex flex-col items-center justify-center gap-2"><i class="fa-solid fa-paragraph text-2xl"></i><span class="font-semibold text-sm">Texte Riche</span></button>
            <button data-block-type="workout" class="add-block-option glass-card hover:bg-white/10 p-4 rounded-lg flex flex-col items-center justify-center gap-2"><i class="fa-solid fa-dumbbell text-2xl text-violet-400"></i><span class="font-semibold text-sm">Séance</span></button>
            <button data-block-type="meal" class="add-block-option glass-card hover:bg-white/10 p-4 rounded-lg flex flex-col items-center justify-center gap-2"><i class="fa-solid fa-utensils text-2xl text-green-400"></i><span class="font-semibold text-sm">Repas</span></button>
        </div>
        <button class="close-modal w-full mt-6 glass-card p-3 rounded-lg font-bold">Annuler</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelectorAll('.add-block-option').forEach(btn => {
            btn.onclick = () => {
                const type = btn.dataset.blockType;
                // Pour l'instant, on ajoute des blocs avec du contenu par défaut
                let newBlock = { id: generateId(), type, content: {} };
                switch(type) {
                    case 'day_separator': newBlock.content.title = 'NOUVEAU JOUR'; break;
                    case 'text': newBlock.content.html = '<p>Votre texte ici...</p>'; break;
                    case 'workout':
                        // Logique pour sélectionner une séance (à venir)
                        if(state.workouts.length > 0) newBlock.content.refId = state.workouts[0].id;
                        else { showToast("Créez d'abord une séance.", "error"); return; }
                        break;
                    case 'meal':
                        // Logique pour sélectionner un repas (à venir)
                        if(state.meals.length > 0) newBlock.content.refId = state.meals[0].id;
                        else { showToast("Créez d'abord un repas.", "error"); return; }
                        break;
                }
                state.editingProgram.programContent.push(newBlock);
                closeModal();
                render();
            };
        });
    });
}

        function handleCalendarEvents(e) {
            if (e.target.closest('#prev-month-btn')) {
                state.calendarDate.setMonth(state.calendarDate.getMonth() - 1);
                render();
            } else if (e.target.closest('#next-month-btn')) {
    state.calendarDate.setMonth(state.calendarDate.getMonth() + 1);
    render();
} else if (e.target.closest('#open-recurrence-btn')) { // <-- Maintenant, il est indépendant et correct
    openRecurrenceModal();
} else if (e.target.closest('.calendar-day:not(.past-day)')) {
                const dayDiv = e.target.closest('.calendar-day');
                const date = dayDiv.dataset.date;
                const events = state.calendarEvents.filter(ev => ev.date === date);
                if(events.length > 0) openDayDetailsModal(date, events);
            } 
            // Clic sur la flèche droite
            else if (e.target.closest('#scroll-story-right-btn')) {
                if (isStoryScrolling) return; // Si une animation est en cours, on ignore le clic
                isStoryScrolling = true; // On bloque les clics suivants

                const container = document.getElementById('story-container');
                const firstAsset = container.querySelector('.draggable');
                if (!firstAsset) {
                    isStoryScrolling = false;
                    return;
                }
                const assetWidthWithGap = firstAsset.offsetWidth + 12;
                const itemsToScroll = Math.max(1, Math.floor(container.clientWidth / assetWidthWithGap));
                container.scrollLeft += itemsToScroll * assetWidthWithGap;

                // On débloque les clics après 400ms (temps de l'animation)
                setTimeout(() => { isStoryScrolling = false; }, 400);

            } 
            // Clic sur la flèche gauche
            else if (e.target.closest('#scroll-story-left-btn')) {
                if (isStoryScrolling) return; // Si une animation est en cours, on ignore le clic
                isStoryScrolling = true; // On bloque les clics suivants

                const container = document.getElementById('story-container');
                const firstAsset = container.querySelector('.draggable');
                if (!firstAsset) {
                    isStoryScrolling = false;
                    return;
                }
                const assetWidthWithGap = firstAsset.offsetWidth + 12;
                const itemsToScroll = Math.max(1, Math.floor(container.clientWidth / assetWidthWithGap));
                container.scrollLeft -= itemsToScroll * assetWidthWithGap;
                
                // On débloque les clics après 400ms (temps de l'animation)
                setTimeout(() => { isStoryScrolling = false; }, 400);
            }
        }

        function handleStatsEvents(e) {
    // La logique pour le tri et l'ouverture des autres modales reste
    const sortOption = e.target.closest('#custom-select-options .custom-select-option');
    if (sortOption) {
        const value = sortOption.dataset.value;
        state.statsSortOrder = value;

        const buttonText = document.getElementById('custom-select-value');
        if (buttonText) {
            buttonText.textContent = state.sortOrderLabels[value];
        }

        closeAllDropdowns();
        render();
        return;
    }

    if (e.target.closest('[data-action="open-sbd-vault"]')) {
        openSbdVaultModal();
        return;
    }
    
    // Le reste de la logique (open-rank-details, open-global-rank-details, etc.) reste ici...
    if (e.target.closest('[data-action="open-rank-details"]')) {
        openRankDetailsModal(e.target.closest('[data-action="open-rank-details"]').dataset.exerciseId);
    } else if (e.target.closest('[data-action="open-global-rank-details"]')) {
        openGlobalRankDetailsModal();
    } else if (e.target.closest('[data-action="open-rank-info"]')) {
        updateAchievementProgress('rewarded_curiosity', 'rank_info', 'add_to_set');
        openRankInfoModal();
    } else if (e.target.closest('[data-action="open-dashboard-modal"]')) {
        openDashboardModal();
    }
}

        async function createClan(name, iconId, iconColor, nameColor, nameIsAnimated, iconIsAnimated, clanMusic) {
            if (!currentUserId || name.length < 3 || !iconId) return false;

            const userRef = doc(db, 'users', currentUserId);
            const clanRef = doc(collection(db, 'clans'));

            const newClanData = {
                name: name,
                name_lowercase: name.toLowerCase(),
                iconId: iconId,
                iconColor: iconColor,
                chefUid: currentUserId,
                members: [currentUserId],
                createdAt: serverTimestamp(),
                pendingInvites: {},
                nameColor: nameColor,
                nameIsAnimated: nameIsAnimated,
                iconIsAnimated: iconIsAnimated,
                clanMusic: clanMusic
            };

            try {
                const batch = writeBatch(db);
                batch.set(clanRef, newClanData);
                batch.update(userRef, { 'userProfile.clanId': clanRef.id });
                await batch.commit();

                state.userProfile.clanId = clanRef.id;
                state.currentClanData = { id: clanRef.id, ...newClanData };

                // AJOUT : On force la navigation vers la page Social pour rafraîchir la vue et la musique.
                navigate('Social');
                
                // On garde render() au cas où, mais navigate s'en chargera.
                render();

                return true;
            } catch (error) {
                console.error("Erreur lors de la création du clan:", error);
                return false;
            }
        }

async function joinClan(clanId) {
    if (!currentUserId || state.userProfile.clanId) {
        showToast("Vous êtes déjà dans une équipe.", "error");
        return false;
    }

    // --- DÉBUT DE LA CORRECTION ---
    // On vérifie si le document de l'utilisateur existe avant de continuer.
    const userRefCheck = doc(db, 'users', currentUserId);
    const userDocCheck = await getDoc(userRefCheck);
    if (!userDocCheck.exists()) {
        showToast("Complétez d'abord votre profil pour rejoindre une équipe.", "error");
        return false;
    }
    // --- FIN DE LA CORRECTION ---

    const clanRef = doc(db, 'clans', clanId);
    const userRef = doc(db, 'users', currentUserId);

    try {
        // Le reste de la fonction est inchangé
        await runTransaction(db, async (transaction) => {
            const clanDoc = await transaction.get(clanRef);
            if (!clanDoc.exists()) throw new Error("Cette équipe n'existe plus.");
            const clanData = clanDoc.data();
            if (clanData.members.length >= 10) throw new Error("L'équipe est maintenant complète.");
            if (clanData.members.includes(currentUserId)) throw new Error("Vous êtes déjà dans cette équipe.");
            transaction.update(clanRef, { members: arrayUnion(currentUserId) });
            transaction.update(userRef, { 'userProfile.clanId': clanId });
        });

        const newClanDoc = await getDoc(clanRef);
        if (newClanDoc.exists()) {
            const clanData = { id: newClanDoc.id, ...newClanDoc.data() };
            const memberPromises = clanData.members.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
            const memberDocs = await Promise.all(memberPromises);
            const membersData = memberDocs.map(d => d.exists() ? d.data() : null).filter(Boolean);

            state.userProfile.clanId = clanId;
            state.currentClanData = clanData;
            state.currentClanMembersData = membersData;
            
            await saveState(); 
            
            playClanMusic(clanData.clanMusic);
            render();
        }

        showToast("Bienvenue dans l'équipe !", "success");
        return true;

    } catch (error) {
        console.error("Erreur pour rejoindre le clan:", error);
        showToast(error.message, "error");
        return false;
    }
}

async function sendClanInvite(friendId) {
    const clanData = state.currentClanData;
    if (!currentUserId || !clanData) return false;

    if (clanData.members.length >= 10) {
        showToast("L'équipe est complète.", "error");
        return false;
    }
    
    const clanRef = doc(db, 'clans', clanData.id);
    const inviteKey = `pendingInvites.${friendId}`;

    try {
        // Mettre à jour le document du clan
        await updateDoc(clanRef, { [inviteKey]: currentUserId });

        // Envoyer un message à l'ami
        await addDoc(collection(db, 'inboxMessages'), {
            recipientUid: friendId,
            senderUid: currentUserId,
            type: 'clanInvite',
            clanId: clanData.id,
            clanName: clanData.name,
            senderName: state.userProfile.name,
            timestamp: serverTimestamp(),
            isRead: false
        });

        // Mettre à jour l'état local pour refléter l'invitation
        if (!state.currentClanData.pendingInvites) {
            state.currentClanData.pendingInvites = {};
        }
        state.currentClanData.pendingInvites[friendId] = currentUserId;

        return true;
    } catch (error) {
        console.error("Erreur lors de l'envoi de l'invitation:", error);
        showToast("Une erreur est survenue.", "error");
        return false;
    }
}

async function leaveClan() {
    const clanId = state.userProfile.clanId;
    if (!currentUserId || !clanId) return false;

    const userRef = doc(db, 'users', currentUserId);
    const clanRef = doc(db, 'clans', clanId);

    try {
        await runTransaction(db, async (transaction) => {
            const clanDoc = await transaction.get(clanRef);
            if (!clanDoc.exists()) throw new Error("L'équipe n'existe plus.");
            
            const clanData = clanDoc.data();
            const updatedMembers = clanData.members.filter(uid => uid !== currentUserId);
            
            transaction.update(userRef, { 'userProfile.clanId': null });
            
            if (updatedMembers.length === 0) {
                transaction.delete(clanRef);
            } else {
                // Si le chef part, le membre le plus ancien devient le nouveau chef
                if (clanData.chefUid === currentUserId) {
                    transaction.update(clanRef, { members: updatedMembers, chefUid: updatedMembers[0] });
                } else {
                    transaction.update(clanRef, { members: updatedMembers });
                }
            }
        });

        // CORRECTION : On met à jour tout l'état local relatif au clan
        state.userProfile.clanId = null;
        state.currentClanData = null;
        state.currentClanMembersData = null; // <-- Ajouté pour la propreté

        stopClanMusic(); // On arrête la musique
        await saveState(); // On sauvegarde l'état APRÈS toutes les modifications

        showToast("Vous avez quitté l'équipe.", "success");
        return true;

    } catch (error) {
        console.error("Erreur pour quitter le clan:", error);
        showToast(error.message, "error");
        return false;
    }
}

async function leaveGym() {
    const gymId = state.userProfile.gymId;
    if (!currentUserId || !gymId) return false;

    const userRef = doc(db, 'users', currentUserId);
    const gymRef = doc(db, 'gyms', gymId);

    try {
        // La transaction met à jour uniquement les documents essentiels
        await runTransaction(db, async (transaction) => {
            transaction.update(userRef, { 'userProfile.gymId': null });
            transaction.update(gymRef, { members: arrayRemove(currentUserId) });
        });

        // CORRECTION : On met à jour l'état local APRES la transaction réussie
        state.userProfile.gymId = null;
        state.currentGymData = null; // <-- Très important d'effacer les données locales
        state.currentGymMembersData = null;

        // AJOUTÉ : On appelle saveState() pour synchroniser le profil public
        await saveState();

        showToast("Vous avez quitté la salle.", "success");
        return true;
    } catch (error) {
        console.error("Erreur pour quitter la salle:", error);
        showToast("Une erreur est survenue.", "error");
        return false;
    }
}

function openLeaveGymConfirmationModal() {
    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Quitter la salle ?</h2>
        <p class="text-gray-400 mb-6">Êtes-vous sûr de vouloir quitter cette salle ? Vos classements internes seront perdus.</p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-leave-gym" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Quitter</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#confirm-leave-gym').onclick = async () => {
            const success = await leaveGym();
            if (success) {
                closeModal();
                render(); // Re-render the Social page
            }
        };
    });
}

async function openPromoteNewChefModal() {
    const clanData = state.currentClanData;
    if (!clanData) return;

    // Récupérer les autres membres
    const otherMemberUids = clanData.members.filter(uid => uid !== currentUserId);
    const memberPromises = otherMemberUids.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
    const memberDocs = await Promise.all(memberPromises);
    const membersData = memberDocs.map(doc => doc.exists() ? doc.data() : null).filter(Boolean);

    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Nouveau Chef Requis</h2>
        <p class="text-gray-400 mb-6">En tant que chef, vous devez nommer un successeur avant de pouvoir quitter l'équipe. Veuillez en choisir un dans la liste ci-dessous.</p>
        <div class="space-y-3 max-h-60 overflow-y-auto pr-2 scrollbar-hide">
            ${membersData.map(member => {
                // On récupère les données des cosmétiques pour un affichage complet
                const equippedBorder = BORDERS_DATABASE.find(b => b.id === member.equipped?.border) || { style: '' };
                const equippedTitle = TITLES_DATABASE.find(t => t.id === member.equipped?.title) || { name: 'Débutant', rarity: 'Commun' };
                const titleClass = equippedTitle.color ? equippedTitle.color : `rarity-${normalizeString(equippedTitle.rarity)}-text`;

                return `
                <button data-action="promote-and-leave" data-new-chef-id="${member.uid}" class="w-full text-left glass-card p-3 rounded-xl flex items-center justify-between hover:bg-white/10 transition-colors">
                    <div class="flex items-center gap-3 min-w-0">
                        <div class="w-12 h-12 rounded-full flex-shrink-0" style="${equippedBorder.style}">
                            <div class="w-full h-full rounded-full" style="background-color: rgb(29, 31, 43);">
                                ${renderAvatar(member.profilePicUrl, "w-full h-full")}
                            </div>
                        </div>
                        <div class="min-w-0">
                            <p class="font-bold truncate">${member.name}</p>
                            <p class="text-sm truncate ${titleClass}" title="${equippedTitle.name}">${equippedTitle.name}</p>
                        </div>
                    </div>
                    <div class="w-12 h-12 ml-2 mr-2 flex-shrink-0">
                        ${getRankBadgeSVG(member.globalRank || 'Novice III', '48px')}
                    </div>
                </button>
                `;
            }).join('')}
        </div>
        <button class="cancel w-full mt-6 glass-card p-3 rounded-lg font-bold">Annuler</button>
    </div>`;

    showModal(modalContent);
}

async function openFinalPromotionConfirmationModal(newChefId) {
    const newChefDoc = await getDoc(doc(db, 'publicProfiles', newChefId));
    if (!newChefDoc.exists()) {
        showToast("Impossible de trouver ce membre.", "error");
        return;
    }
    const newChefName = newChefDoc.data().name;

    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Confirmer la promotion ?</h2>
        <p class="text-gray-400 mb-6">
            Vous êtes sur le point de nommer <strong class="text-white">${newChefName}</strong> comme nouveau chef.
            <br>Cette action vous fera quitter l'équipe.
        </p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-promotion" class="w-full bg-orange-600 text-white p-3 rounded-lg font-bold">Promouvoir et Quitter</button>
        </div>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#confirm-promotion').onclick = () => {
            // --- CORRECTION APPLIQUÉE ICI ---
            // On appelle simplement closeModal() une seule fois.
            closeModal();
            promoteAndLeave(newChefId);
            navigate('Social');
        };
    }, () => {}, true);
}

async function promoteAndLeave(newChefId) {
    const clanId = state.userProfile.clanId;
    if (!currentUserId || !clanId || !newChefId) return false;

    const userRef = doc(db, 'users', currentUserId);
    const clanRef = doc(db, 'clans', clanId);

    try {
        await runTransaction(db, async (transaction) => {
            const clanDoc = await transaction.get(clanRef);
            if (!clanDoc.exists()) throw new Error("L'équipe n'existe plus.");

            transaction.update(clanRef, {
                chefUid: newChefId,
                members: arrayRemove(currentUserId)
            });
            transaction.update(userRef, { 'userProfile.clanId': null });
        });

        state.userProfile.clanId = null;
        state.currentClanData = null;
        saveState();
        stopClanMusic();
        showToast("Nouveau chef nommé. Vous avez quitté l'équipe.", "success");
        return true;

    } catch (error) {
        console.error("Erreur de promotion:", error);
        showToast(error.message, "error");
        return false;
    }
}

        function openCreateClanModal() {
    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Créer une Équipe</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>

        <div class="glass-card p-4 rounded-xl mb-4 text-center flex-shrink-0">
            <div id="preview-icon-wrapper" class="w-20 h-20 mx-auto flex items-center justify-center"><i id="preview-icon" class="fa-solid text-5xl"></i></div>
            <h3 id="preview-name" class="text-3xl font-extrabold mt-2"></h3>
        </div>

        <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-4 min-h-0">
            <div>
                <label class="font-semibold text-gray-400">Nom</label>
                <input id="clan-name-input" type="text" class="input-glass mt-1" placeholder="Nom de l'équipe (3-20 caractères)" maxlength="20">
            </div>
            <div>
                <label class="font-semibold text-gray-400">Icône</label>
                <div id="clan-icon-selection" class="grid grid-cols-6 gap-2 bg-black/20 p-2 rounded-lg">
                    ${CLAN_ICONS.map(icon => `<button class="clan-icon-btn aspect-square rounded-md flex items-center justify-center text-2xl text-gray-500" data-icon-id="${icon.id}" data-icon-class="${icon.icon}"><i class="fa-solid ${icon.icon}"></i></button>`).join('')}
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="font-semibold text-gray-400">Couleur du Titre</label>
                    <input id="new-clan-name-color" type="color" class="w-full h-12 bg-transparent p-1 rounded-lg" value="#FFFFFF">
                </div>
                <div>
                    <label class="font-semibold text-gray-400">Couleur de l'Icône</label>
                    <input id="new-clan-icon-color" type="color" class="w-full h-12 bg-transparent p-1 rounded-lg" value="#A78BFA">
                </div>
            </div>
            <div class="flex items-center justify-between glass-card p-3 rounded-xl">
                <label class="font-semibold">Animer le titre</label>
                <label class="toggle-switch-v2"><input type="checkbox" id="name-animation-toggle-new"><span class="slider"></span></label>
            </div>
            <div class="flex items-center justify-between glass-card p-3 rounded-xl">
                <label class="font-semibold">Animer l'icône</label>
                <label class="toggle-switch-v2"><input type="checkbox" id="icon-animation-toggle-new"><span class="slider"></span></label>
            </div>
            <div class="pt-4 mt-4 border-t border-white/10">
                <label class="font-semibold text-gray-400 mb-2 block">Musique de l'Équipe</label>
                <div id="clan-music-selection" class="grid grid-cols-4 gap-3">
                    ${CLAN_MUSIC_DATABASE.map(m => `
                        <button data-music-id="${m.id}" class="clan-music-btn flex flex-col items-center justify-center gap-2 p-2 rounded-lg bg-black/20 aspect-square">
                            ${m.id === 'music_none' 
                                ? '<i class="fa-solid fa-volume-xmark text-2xl"></i>' 
                                : `
                                <img src="${m.image}" class="w-8 h-8 rounded-md object-cover" loading="lazy" decoding="async">
                                `
                            }
                            <span class="text-xs text-center font-semibold leading-tight">${m.name}</span>
                        </button>
                    `).join('')}
                </div>
            </div>
        </div>
        <button id="confirm-create-clan-btn" class="w-full mt-6 btn-primary flex-shrink-0" disabled>Créer</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        // ... la logique interne de la fonction reste exactement la même ...
        const nameInput = modalWrapper.querySelector('#clan-name-input');
        const iconSelection = modalWrapper.querySelector('#clan-icon-selection');
        const nameColorInput = modalWrapper.querySelector('#new-clan-name-color');
        const iconColorInput = modalWrapper.querySelector('#new-clan-icon-color');
        const nameAnimationToggle = modalWrapper.querySelector('#name-animation-toggle-new');
        const iconAnimationToggle = modalWrapper.querySelector('#icon-animation-toggle-new');
        const musicSelection = modalWrapper.querySelector('#clan-music-selection');
        const confirmBtn = modalWrapper.querySelector('#confirm-create-clan-btn');
        let selectedIconId = null;
        let selectedIconClass = null;
        let selectedMusicId = 'music_none';

        const updatePreview = () => {
            const previewName = modalWrapper.querySelector('#preview-name');
            const previewIcon = modalWrapper.querySelector('#preview-icon');
            const currentName = nameInput.value.trim() || 'Mon équipe';
            const currentNameColor = nameColorInput.value;
            const currentIconColor = iconColorInput.value;
            const nameIsAnimated = nameAnimationToggle.checked;
            const iconIsAnimated = iconAnimationToggle.checked;

            previewName.textContent = currentName;
            
            let nameClasses = 'text-3xl font-extrabold mt-2';
            let nameStyle = `color: ${currentNameColor};`;
            if (nameIsAnimated) {
                nameClasses += ' dynamic-animated-gradient-text';
                const lighterName = lightenColor(currentNameColor, 0.4);
                nameStyle = `--base-color: ${currentNameColor}; --highlight-color: ${lighterName};`;
            }
            previewName.className = nameClasses;
            previewName.style = nameStyle;

            if (selectedIconClass) {
                let iconClasses = `fa-solid ${selectedIconClass} text-5xl`;
                let iconStyle = `color: ${currentIconColor};`;
                if (iconIsAnimated) {
                    iconClasses += ' dynamic-animated-gradient-icon';
                    const lighterIcon = lightenColor(currentIconColor, 0.4);
                    iconStyle = `--base-color-icon: ${currentIconColor}; --highlight-color-icon: ${lighterIcon};`;
                }
                previewIcon.className = iconClasses;
                previewIcon.style = iconStyle;
            } else {
                previewIcon.className = 'fa-solid fa-question-circle text-5xl text-gray-500';
                previewIcon.style = '';
            }
        };

        const validate = () => {
            const nameIsValid = nameInput.value.trim().length >= 3;
            const iconIsSelected = selectedIconId !== null;
            confirmBtn.disabled = !(nameIsValid && iconIsSelected);
        };
        
        const stopMusicAndClearSelection = () => {
            stopClanMusic();
            modalWrapper.querySelectorAll('.clan-music-btn').forEach(b => b.classList.remove('bg-violet-500'));
        };

        modalWrapper.querySelectorAll('.clan-icon-btn').forEach(btn => {
            btn.onclick = () => {
                modalWrapper.querySelectorAll('.clan-icon-btn').forEach(b => b.classList.remove('bg-violet-500', 'text-white'));
                btn.classList.add('bg-violet-500', 'text-white');
                selectedIconId = btn.dataset.iconId;
                selectedIconClass = btn.dataset.iconClass;
                updatePreview();
                validate();
            };
        });

        musicSelection.addEventListener('click', (e) => {
            const musicBtn = e.target.closest('.clan-music-btn');
            if (musicBtn) {
                musicSelection.querySelectorAll('.clan-music-btn').forEach(b => b.classList.remove('bg-violet-500'));
                musicBtn.classList.add('bg-violet-500');
                selectedMusicId = musicBtn.dataset.musicId;
                playClanMusic(selectedMusicId);
            }
        });
        
        modalWrapper.querySelector('.close-modal').addEventListener('click', stopMusicAndClearSelection);

        nameInput.oninput = () => { updatePreview(); validate(); };
        nameColorInput.oninput = updatePreview;
        iconColorInput.oninput = updatePreview;
        nameAnimationToggle.onchange = updatePreview;
        iconAnimationToggle.onchange = updatePreview;
        
        updatePreview();

        confirmBtn.onclick = async () => {
            const name = nameInput.value.trim();
            const iconColor = iconColorInput.value;
            const nameColor = nameColorInput.value;
            const nameIsAnimated = nameAnimationToggle.checked;
            const iconIsAnimated = iconAnimationToggle.checked;
            if (confirmBtn.disabled) return;
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i>`;
            const success = await createClan(name, selectedIconId, iconColor, nameColor, nameIsAnimated, iconIsAnimated, selectedMusicId);
            if (success) {
                showToast("Équipe créée avec succès !", "success");
                closeModal();
            } else {
                showToast("Erreur lors de la création.", "error");
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = `Créer`;
            }
        };
    });
}

        function openLevelDetailsModal() {
    const { leveling } = state.userProfile;
    const displayInfo = getDisplayLevelInfo(leveling.realLevel);
    const levelColors = getLevelTierColors(leveling.realLevel);
    const xpPercentage = getExpPercentage();
    const exp = getExpValues();

    // NOUVEAU : L'en-tête est maintenant défini ici pour être réutilisé
    const modalHeaderHtml = `
        <header class="flex justify-between items-center w-full mb-6 z-10 flex-shrink-0">
            <h2 class="text-2xl font-bold">Progression</h2>
            <button id="open-level-system-info-btn" class="text-gray-500 hover:text-white transition-colors w-10 h-10 flex items-center justify-center">
                <i class="fa-solid fa-circle-question text-2xl"></i>
            </button>
        </header>
    `;

    if (leveling.isMaxedOut) {
        const modalContent = `
        <div class="level-details-modal level-details-modal-maxed p-6 rounded-3xl w-full max-w-sm text-center flex flex-col items-center min-h-[520px]">
            ${modalHeaderHtml} 
            <div class="starfield">
                <div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div>
                <div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div>
            </div>

            <div class="flex-grow flex flex-col justify-center w-full">
                <p class="font-bold text-yellow-300 uppercase tracking-widest z-10">Niveau Maximum Atteint</p>
                <h2 class="level-display-main max-level-animated-badge z-10" style="font-size: 8rem; filter: drop-shadow(0 0 15px #FDE047);">
                    MAX
                </h2>
                <div class="w-full border-t border-yellow-400/20 my-6 z-10"></div>
                <div class="grid grid-cols-2 gap-4 w-full z-10">
                    <div class="stat-card">
                        <p class="text-xs text-gray-400 font-semibold uppercase">Niveau Global</p>
                        <p id="global-level-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p>
                    </div>
                    <div class="stat-card">
                        <p class="text-xs text-gray-400 font-semibold uppercase">XP Total</p>
                        <p id="total-xp-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p>
                    </div>
                </div>
            </div>

            <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold z-10 flex-shrink-0">Fermer</button>
        </div>
        `;
        showModal(modalContent, (modalWrapper) => {
            modalWrapper.querySelector('#open-level-system-info-btn').onclick = openLevelSystemInfoModal;
            animateCounter(document.getElementById('global-level-counter'), 0, leveling.realLevel, 1500);
            animateCounter(document.getElementById('total-xp-counter'), 0, leveling.xp, 1500);
        });
        return;
    }

    const levelGlowStyle = `color: ${levelColors.color}; text-shadow: 0 0 ${displayInfo.displayLevel * 0.15}px ${levelColors.color};`;
    const xpBarGlowStyle = `width: ${xpPercentage}%; background-color: ${levelColors.color}; box-shadow: 0 0 12px ${levelColors.color}; opacity: ${0.4 + (xpPercentage * 0.006)};`;
    const titleAnimationClass = displayInfo.prestigeTier >= 9 ? 'max-level-animated-badge' : '';

    const modalContent = `
    <div class="level-details-modal p-6 rounded-3xl w-full max-w-sm text-center flex flex-col items-center min-h-[520px]">
        ${modalHeaderHtml}
        <div class="nebula-bg" style="--nebula-color: ${levelColors.color};"></div>
        
        <div class="grid grid-cols-2 gap-4 w-full z-10 flex-shrink-0">
            <div class="stat-card"><p class="text-xs text-gray-400 font-semibold uppercase">Niveau Global</p><p id="global-level-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p></div>
            <div class="stat-card"><p class="text-xs text-gray-400 font-semibold uppercase">XP Total</p><p id="total-xp-counter" class="text-2xl font-bold" style="color: ${levelColors.color};">0</p></div>
        </div>
        
        <div class="relative z-10 flex-grow flex flex-col justify-center w-full my-4">
            <h2 class="level-display-main ${titleAnimationClass}" style="${levelGlowStyle}">Niv. ${displayInfo.displayLevel}</h2>
            ${!leveling.isMaxedOut && displayInfo.prestige > 0 ? `<div class="flex items-center justify-center gap-2 mt-2">${Array.from({ length: displayInfo.prestige }, () => `<i class="fa-solid fa-star text-yellow-400 text-2xl" style="filter: drop-shadow(0 0 5px #FBBF24);"></i>`).join('')}</div>` : ''}
        </div>
        
        <div class="w-full relative z-10 flex-shrink-0">
            <div class="w-full h-2.5 bg-black/30 rounded-full border border-white/10"><div class="h-full rounded-full" style="${xpBarGlowStyle}"></div></div>
            <div class="w-full text-center mt-2"><span class="text-sm text-gray-300 font-semibold tracking-tighter">${formatXP(exp.current)} / ${formatXP(Math.ceil(exp.required))} XP</span></div>
        </div>

        <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold z-10 flex-shrink-0">Fermer</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#open-level-system-info-btn').onclick = openLevelSystemInfoModal;
        animateCounter(document.getElementById('global-level-counter'), 0, leveling.realLevel, 1500);
        animateCounter(document.getElementById('total-xp-counter'), 0, leveling.xp, 1500);
    });
}

// AJOUTEZ CETTE NOUVELLE FONCTION DANS VOTRE SCRIPT

function openLevelSystemInfoModal() {
    const tierNames = ['Acier', 'Bronze', 'Saphir', 'Émeraude', 'Rubis', 'Améthyste', 'Nébuleuse', 'Solaire', 'Platine', 'Divin'];

    const modalContent = `
    <div class="level-info-modal glass-card p-6 rounded-3xl w-full max-w-sm text-left flex flex-col min-h-[520px]">
        <header class="flex items-center gap-4 mb-6">
            <button id="back-to-level-details" class="text-gray-400 hover:text-white transition-colors">
                <i class="fa-solid fa-arrow-left text-xl"></i>
            </button>
            <h2 class="text-2xl font-bold">Système de Niveaux</h2>
        </header>

        <div class="space-y-6 flex-grow flex flex-col">
            <div>
                <div class="flex items-center gap-3 mb-2">
                    <i class="fa-solid fa-layer-group text-violet-300 w-6 text-center"></i>
                    <h3 class="font-bold text-lg">Niveaux</h3>
                </div>
                <p class="text-sm text-gray-300 pl-9">Chaque fois que vous gagnez de l'XP, vous progressez de <strong>Niveau 1 à 100</strong>.</p>
            </div>
            
            <div>
                <div class="flex items-center gap-3 mb-2">
                    <i class="fa-solid fa-star text-yellow-400 w-6 text-center"></i>
                    <h3 class="font-bold text-lg">Prestiges</h3>
                </div>
                <p class="text-sm text-gray-300 pl-9">En atteignant le niveau 100, vous gagnez une <strong>étoile de Prestige</strong> et revenez au niveau 1. Vous pouvez en accumuler jusqu'à 3.</p>
            </div>
            
            <div class="flex-grow flex flex-col">
                <div class="flex items-center gap-3 mb-2">
                    <i class="fa-solid fa-gem text-cyan-300 w-6 text-center"></i>
                    <h3 class="font-bold text-lg">Tiers de Prestige</h3>
                </div>
                <p class="text-sm text-gray-300 pl-9 mb-3">Après 3 étoiles, vous passez au <strong>Tier</strong> suivant, changeant la couleur de votre niveau pour symboliser votre nouvelle puissance.</p>
                
                <div class="tier-switcher-container flex-grow flex flex-col justify-center">
                    <div id="tier-switcher" class="flex items-center justify-between">
                        <button id="prev-tier-btn" class="tier-switcher-arrow"><i class="fa-solid fa-chevron-left"></i></button>
                        <div class="flex items-center gap-4">
                            <div id="tier-swatch-display" class="tier-color-swatch"></div>
                            <span id="tier-name-display" class="font-semibold text-lg"></span>
                        </div>
                        <button id="next-tier-btn" class="tier-switcher-arrow"><i class="fa-solid fa-chevron-right"></i></button>
                    </div>
                    <div id="tier-progress-display" class="text-center text-gray-500 font-mono text-sm mt-2"></div>
                </div>
            </div>
        </div>
    </div>
    `;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#back-to-level-details').onclick = openLevelDetailsModal;

        // --- Logique du sélecteur interactif ---
        let currentTierIndex = 0;
        const prevBtn = modalWrapper.querySelector('#prev-tier-btn');
        const nextBtn = modalWrapper.querySelector('#next-tier-btn');
        const swatchEl = modalWrapper.querySelector('#tier-swatch-display');
        const nameEl = modalWrapper.querySelector('#tier-name-display');
        const progressEl = modalWrapper.querySelector('#tier-progress-display');

        const updateTierDisplay = (index) => {
            const color = PRESTIGE_TIER_COLORS[index];
            const name = tierNames[index] || `Tier ${index}`;

            swatchEl.style.backgroundColor = color;
            swatchEl.style.boxShadow = `0 0 12px ${color}90`;
            nameEl.textContent = name;
            nameEl.style.color = color;
            progressEl.textContent = `${index + 1} / ${tierNames.length}`;

            prevBtn.disabled = index === 0;
            nextBtn.disabled = index === tierNames.length - 1;
        };

        prevBtn.onclick = () => {
            if (currentTierIndex > 0) {
                currentTierIndex--;
                updateTierDisplay(currentTierIndex);
            }
        };

        nextBtn.onclick = () => {
            if (currentTierIndex < tierNames.length - 1) {
                currentTierIndex++;
                updateTierDisplay(currentTierIndex);
            }
        };

        // Affichage initial
        updateTierDisplay(currentTierIndex);
    });
}

async function searchUsersByName(nameQuery) {
    const normalizedQuery = nameQuery.trim().toLowerCase();
    const resultsContainer = document.getElementById('user-search-results');

    if (normalizedQuery.length < 3) {
        resultsContainer.innerHTML = '<p class="text-center text-gray-500 pt-16">Entrez au moins 3 caractères.</p>';
        return;
    }
    
    resultsContainer.innerHTML = '<p class="text-center text-gray-400">Recherche en cours...</p>';

    try {
        const q = query(collection(db, 'publicProfiles'), 
            where('name_lowercase', '>=', normalizedQuery), 
            where('name_lowercase', '<=', normalizedQuery + '\uf8ff'),
            limit(20)
        );

        const querySnapshot = await getDocs(q);
        const users = [];
        querySnapshot.forEach(doc => {
            if (doc.id !== currentUserId) {
                users.push(doc.data());
            }
        });

        if (users.length === 0) {
            resultsContainer.innerHTML = '<p class="text-center text-gray-500">Aucun utilisateur trouvé.</p>';
            return;
        }

        resultsContainer.innerHTML = users.map(user => renderUnifiedUserCard(user, 'user-search')).join('');
    } catch (error) {
        console.error("Erreur de recherche:", error);
        resultsContainer.innerHTML = '<p class="text-center text-red-500">Erreur lors de la recherche.</p>';
    }
}

        // CORRECTION N°2 : Traiter la récompense ET mettre à jour l'interface.
async function processRewardClaim(achId, tierIndex) {
    const achievement = ACHIEVEMENTS_DATABASE.find(ach => ach.id === achId);
    if (!achievement) return;

    if (!state.userProfile.achievements[achId]) {
        state.userProfile.achievements[achId] = { progress: 0, claimedTiers: [], qualifyingData: new Set() };
    }
    const achData = state.userProfile.achievements[achId];
    const tier = achievement.tiers[tierIndex];

    if (achData.claimedTiers.includes(tierIndex)) return;
    if (!tier || !tier.reward) return;

    let isUnlocked = false;
    if (achievement.checkCondition) {
        isUnlocked = achievement.checkCondition(state) >= tier.goal;
    } else {
        isUnlocked = achData.progress >= tier.goal;
    }

    if (!isUnlocked) {
        showToast("La condition pour ce succès n'est pas remplie.", "error");
        return;
    }

    const reward = tier.reward;
    let rewardMessage = 'Récompense récupérée !';

    // --- NOUVEAU : On ajoute l'XP AVANT de traiter le reste ---
    if (reward.xp && reward.xp > 0) {
        addXP(reward.xp);
    }
    // -----------------------------------------------------------

    // --- Distribution des récompenses (inchangé) ---
    switch(reward.type) {
        case 'coins':
            state.userProfile.coins += reward.amount;
            rewardMessage = `+${reward.amount} Pièces !`;
            break;
        case 'title':
            const title = TITLES_DATABASE.find(t => t.id === reward.id);
            if (title && !state.userProfile.inventory.titles.includes(reward.id)) {
                state.userProfile.inventory.titles.push(reward.id);
                rewardMessage = `Titre débloqué : "${title.name}"`;
            }
            break;
        case 'border':
            const border = BORDERS_DATABASE.find(b => b.id === reward.id);
            if (border && !state.userProfile.inventory.borders.includes(reward.id)) {
                state.userProfile.inventory.borders.push(reward.id);
                rewardMessage = `Bordure débloquée : "${border.name}"`;
            }
            break;
        case 'collectible':
            const collectible = COLLECTIBLES_DATABASE.find(c => c.id === reward.id);
            if (collectible && !state.userProfile.inventory.collectibles.includes(reward.id)) {
                state.userProfile.inventory.collectibles.push(reward.id);
                rewardMessage = `Objet obtenu : "${collectible.name}"`;
            }
            break;
    }

    showToast(rewardMessage, 'success');
    achData.claimedTiers.push(tierIndex);
    
    // Le reste de la fonction pour mettre à jour l'UI est inchangé
    const modalWrapper = document.querySelector('.modal-bg');
    if (modalWrapper) {
        const claimButton = modalWrapper.querySelector(`[data-action="claim-reward"][data-tier-index="${tierIndex}"]`);
        if (claimButton) {
            claimButton.innerHTML = `<i class="fa-solid fa-check mr-1.5"></i>Récupéré`;
            claimButton.disabled = true;
            claimButton.classList.remove('claim-btn');
            claimButton.classList.add('claimed-btn');
            claimButton.removeAttribute('data-action');
        }

        const tierItem = claimButton.closest('.tier-item');
        if (tierItem) {
            const rewardTextElement = tierItem.querySelector('.tier-reward');
            rewardTextElement.classList.remove('claimable');
            rewardTextElement.classList.add('claimed');
        }
    }

    if(state.activePage === 'Achievements' || state.activePage === 'Profil') {
        setTimeout(() => render(), 300);
    }
    await saveState();
}

function showUnlockModal(titleIds, message) {
    if (!Array.isArray(titleIds) || titleIds.length === 0) return;

    const titlesHtml = titleIds.map(titleId => {
        const title = TITLES_DATABASE.find(t => t.id === titleId);
        if (!title) return '';

        // --- NOUVELLE LOGIQUE POUR LES TITRES SECRETS ---
        let titleClass = '';
        if (title.source === 'secret') {
            if (title.id === 't-gymbro-originel') titleClass = 'title-gymbro-originel';
            else if (title.id === 't-pompier-muscle' || title.id === 't-the-bench-monster') titleClass = 'title-pompier-muscle';
            else if (title.id === 't-createur-supreme') titleClass = 'title-createur-supreme';
            else titleClass = `rarity-${normalizeString(title.rarity)}-text`;
        } else {
            titleClass = `rarity-${normalizeString(title.rarity)}-text`;
        }
        // --- FIN DE LA LOGIQUE ---

        return `<p class="text-lg font-semibold truncate ${titleClass}">${title.name}</p>`;
    }).join('');

    const formattedMessage = message.replace(/\n/g, '<br>');

    const modalContent = `
    <div class="glass-card p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
        <i class="fa-solid fa-trophy text-6xl text-yellow-400 animated-glow mb-4"></i>
        <h3 class="text-2xl font-bold">Titre débloqué !</h3>
        <div class="space-y-1">
            ${titlesHtml}
        </div>
        <p class="text-sm text-gray-400 mt-2 mb-6">${formattedMessage}</p>
        <button class="close-modal w-full btn-primary">Fermer</button>
    </div>`;

    showModal(modalContent, null, () => {
        showToast('Profil sauvegardé avec succès !', 'success');
        navigate('Accueil');
    });
}

// CORRECTION N°1 : Assurer que l'identifiant du succès est bien récupéré.
function openAchievementDetailsModal(achievementId) {
    const achievement = ACHIEVEMENTS_DATABASE.find(ach => ach.id === achievementId);
    if (!achievement) return;

    const userAchievementData = state.userProfile.achievements[achievement.id] || { progress: 0, claimedTiers: [] };
    
    let currentValue = userAchievementData.progress;
    if (achievement.checkCondition) {
        currentValue = achievement.checkCondition(state);
    }
    
    const claimedTiers = userAchievementData.claimedTiers;
    const hourglassAnimationHtml = `<div class="sablier"></div>`;

    const tiersHtml = achievement.tiers.map((tier, index) => {
        const isUnlocked = currentValue >= tier.goal;
        const isClaimed = claimedTiers.includes(index);
        const prevTierGoal = index > 0 ? achievement.tiers[index - 1].goal : 0;
        const isCurrent = currentValue < tier.goal && currentValue >= prevTierGoal && !achievement.checkCondition;
        const rewardText = getRewardText(tier.reward);
        
        let statusClass = 'locked';
        let rewardStatusClass = 'locked';
        if (isUnlocked) {
            statusClass = 'unlocked';
            rewardStatusClass = isClaimed ? 'claimed' : 'claimable';
        }
        if (isCurrent) {
            statusClass = 'current';
        }

        let actionHtml = '';
        if (isUnlocked) {
            if (isClaimed) {
                actionHtml = `<button class="reward-btn claimed-btn" disabled><i class="fa-solid fa-check mr-1.5"></i>Récupéré</button>`;
            } else {
                actionHtml = `<button class="reward-btn claim-btn" data-action="claim-reward" data-tier-index="${index}"><i class="fa-solid fa-gift mr-1.5"></i>Collecter</button>`;
            }
        } else {
            actionHtml = `<button class="reward-btn locked-btn" disabled><i class="fa-solid fa-lock mr-1.5"></i>Bloqué</button>`;
        }

        let tierIconContent = `<i class="fa-solid fa-lock"></i>`;
        if(isCurrent) {
            tierIconContent = hourglassAnimationHtml;
        } else if (isUnlocked) {
            tierIconContent = `<i class="fa-solid fa-check"></i>`;
        }

        return `
        <li class="tier-item ${statusClass}">
            <div class="tier-timeline">
                <div class="tier-icon">${tierIconContent}</div>
                <div class="tier-connector"></div>
            </div>
            <div class="tier-details">
                <div class="flex-grow">
                    <h4 class="font-bold">${achievement.name} - Niveau ${index + 1}</h4>
                    <p class="text-sm text-gray-400">${achievement.description(tier.goal)}</p>
                    <div class="flex items-center justify-between mt-2">
                        <div class="tier-reward ${rewardStatusClass}"><span>${rewardText}</span></div>
                        ${actionHtml}
                    </div>
                </div>
            </div>
        </li>
        `;
    }).join('');

    const modalContent = `
    <div class="relative glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[80vh] flex flex-col" data-achievement-id="${achievementId}">
        <header class="text-center mb-4 pt-4">
            <h2 class="text-2xl font-bold">${achievement.name}</h2>
            <p class="text-sm text-gray-400">Suivez votre progression palier par palier.</p>
        </header>
        <ul class="tier-list-container flex-grow overflow-y-auto pr-2 scrollbar-hide">${tiersHtml}</ul>
        <button class="close-modal w-full mt-6 btn-primary">Fermer</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.addEventListener('click', (e) => {
            const claimButton = e.target.closest('[data-action="claim-reward"]');
            const previewButton = e.target.closest('[data-action="preview-reward"]');

            if (claimButton) {
                // --- CORRECTION CLÉ ---
                // On cherche l'élément qui contient l'ID du succès DANS la modale.
                const contentElement = modalWrapper.querySelector('[data-achievement-id]');
                if (!contentElement) return; // Sécurité

                const achId = contentElement.dataset.achievementId;
                // --- FIN DE LA CORRECTION ---
                
                const tierIndex = parseInt(claimButton.dataset.tierIndex);
                processRewardClaim(achId, tierIndex);
            } 
            else if (previewButton) {
                e.stopPropagation();
                const { rewardType, rewardId } = previewButton.dataset;
                openRewardPreviewModal(rewardType, rewardId, () => openAchievementDetailsModal(achievementId));
            }
        });
    });
}

function openRewardPreviewModal(rewardType, rewardId, onCloseCallback) {
    let item;
    let previewHtml = '';

    switch(rewardType) {
        case 'title':
            item = TITLES_DATABASE.find(t => t.id === rewardId);
            if(item) {
                // On réutilise la même logique complexe pour les titres secrets/spéciaux
                let titleClass = `rarity-${normalizeString(item.rarity)}-text`;
                if (item.source === 'secret') {
                    if (item.id === 't-gymbro-originel') titleClass = 'title-gymbro-originel';
                    else if (item.id === 't-pompier-muscle' || item.id === 't-the-bench-monster') titleClass = 'title-pompier-muscle';
                    else if (item.id === 't-createur-supreme') titleClass = 'title-createur-supreme';
                }
                previewHtml = `<p class="text-4xl font-bold ${titleClass}">${item.name}</p>`;
            }
            break;
        case 'border':
            item = BORDERS_DATABASE.find(b => b.id === rewardId);
            if(item) {
                 previewHtml = `
                    <div class="w-48 h-48 rounded-full mx-auto relative" style="${item.style}">
                        <div class="w-full h-full rounded-full flex items-center justify-center" style="background-color: rgb(29, 31, 43);">
                            <i class="fa-solid fa-user text-8xl text-gray-500"></i>
                        </div>
                    </div>`;
            }
            break;
        case 'collectible':
            item = COLLECTIBLES_DATABASE.find(c => c.id === rewardId);
            if(item) {
                previewHtml = `<i class="fa-solid ${item.icon} text-9xl ${item.color} ${item.effect || ''}"></i>`;
            }
            break;
    }

    if (!item) {
        previewHtml = `<p class="text-gray-400">Aperçu indisponible.</p>`;
    }

    const modalContent = `
    <div class="glass-card p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
        <h3 class="text-xl font-bold mb-2">Aperçu de la récompense</h3>
        <p class="text-sm text-gray-400 mb-6">${item ? item.name : ''} - ${item ? item.rarity : ''}</p>
        <div class="h-48 flex items-center justify-center">
            ${previewHtml}
        </div>
        <button class="close-modal w-full mt-8 btn-primary">Fermer</button>
    </div>`;

    // On utilise le callback à la fermeture, qui est maintenant correctement reçu par la fonction
    showModal(modalContent, null, onCloseCallback);
}
        
        function renderStatsList() {
            const practicedExercises = EXERCISE_DATABASE.filter(exo => state.exerciseStats.hasOwnProperty(exo.id));
            
            const sortedExercises = [...practicedExercises].sort((a, b) => {
                const statsA = state.exerciseStats[a.id]?.rankPr || { score: 0 };
                const statsB = state.exerciseStats[b.id]?.rankPr || { score: 0 };
                switch(state.statsSortOrder) {
                    case 'rank_desc': return (statsB.score - statsA.score) || a.name.localeCompare(b.name);
                    case 'rank_asc': return (statsA.score - statsB.score) || a.name.localeCompare(b.name);
                    default: return a.name.localeCompare(b.name);
                }
            });

            if (sortedExercises.length === 0) {
                return `<div class="text-center py-16"><i class="fa-solid fa-ranking-star text-5xl text-gray-600 mb-4"></i><p class="font-semibold text-lg">Aucun rang</p><p class="text-sm text-gray-500">Terminez une séance pour voir vos rangs ici.</p></div>`;
            }

            return sortedExercises.map(exercise => {
                const rankPrScore = state.exerciseStats[exercise.id]?.rankPr?.score || 0;
                const rankInfo = getRankFromScore(rankPrScore, exercise.id);
                
                const progress = rankInfo.progress;
                const tier1Width = Math.min(100, Math.max(0, (progress - 0) * 3));
                const tier2Width = Math.min(100, Math.max(0, (progress - 33) * 3));
                const tier3Width = Math.min(100, Math.max(0, (progress - 66) * 3));
                const rankColor = rankInfo.color.main;

                return `
                <button class="w-full text-left glass-card p-4 rounded-xl hover:bg-white/10 transition-colors duration-200" data-action="open-rank-details" data-exercise-id="${exercise.id}">
                    <div class="flex items-center justify-between gap-2">
                        <div class="flex items-center gap-3 min-w-0">
                            <div class="w-8 h-8 flex-shrink-0">${getRankBadgeSVG(rankInfo.name)}</div>
                            <span class="font-semibold flex-1 truncate">${exercise.name}</span>
                        </div>
                        <span class="text-sm font-bold text-gray-200 w-auto text-right flex-shrink-0">${rankInfo.name}</span>
                    </div>
                    <div class="mt-3">
                        <div class="progress-bar-tiers">
                            <div style="background: linear-gradient(90deg, ${rankColor} ${tier1Width}%, transparent ${tier1Width}%)" class="opacity-40"></div>
                            <div style="background: linear-gradient(90deg, ${rankColor} ${tier2Width}%, transparent ${tier2Width}%)" class="opacity-70"></div>
                            <div style="background: linear-gradient(90deg, ${rankColor} ${tier3Width}%, transparent ${tier3Width}%)"></div>
                        </div>
                        <p class="text-right text-xs text-gray-400 mt-1">${rankInfo.progress < 100 ? `${rankInfo.progress}% vers ${rankInfo.nextRankName}` : 'Rang Maximum Atteint'}</p>
                    </div>
                </button>
                `;
            }).join('');
        }
        
        function launchConfetti() {
            const container = document.getElementById('page-container');
            if (!container) return;
            const confettiCount = 100;
            const colors = ['#A78BFA', '#F87171', '#34D399', '#F59E0B', '#6366F1', '#fde047'];
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.top = '-20px';
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                confetti.style.setProperty('--color', colors[Math.floor(Math.random() * colors.length)]);
                if (Math.random() > 0.5) {
                    confetti.style.borderRadius = '50%';
                }
                container.appendChild(confetti);

                setTimeout(() => {
                    confetti.remove();
                }, 5000);
            }
        }
        
        function renderRankInfoDetails(rankName) {
            const color = getRankColor(rankName);
            const description = RANK_DESCRIPTIONS[rankName] || "";
            return `
                <div class="p-4 text-center">
                    <div class="w-32 h-32 mx-auto mb-4">${getRankBadgeSVG(rankName + ' I')}</div>
                    <h3 class="text-3xl font-bold" style="color: ${color.main}">${rankName}</h3>
                    <p class="text-gray-400 mt-2 text-sm italic">"${description}"</p>
                </div>
                <div class="mt-6 space-y-4 px-2">
                    <div class="flex items-center gap-4">
                        <div class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-white/5 rounded-lg font-mono font-bold text-lg" style="color:${color.accent}; opacity:0.5">III</div>
                        <div>
                             <h4 class="font-bold">Tiers III</h4>
                             <p class="text-sm text-gray-400">Le début de votre ascension dans ce nouveau rang.</p>
                        </div>
                    </div>
                     <div class="flex items-center gap-4">
                        <div class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-white/5 rounded-lg font-mono font-bold text-lg" style="color:${color.accent}; opacity:0.75">II</div>
                        <div>
                             <h4 class="font-bold">Tiers II</h4>
                             <p class="text-sm text-gray-400">Vous maîtrisez les bases, continuez comme ça.</p>
                        </div>
                    </div>
                     <div class="flex items-center gap-4">
                        <div class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-white/5 rounded-lg font-mono font-bold text-lg" style="color:${color.accent};">I</div>
                        <div>
                             <h4 class="font-bold">Tiers I</h4>
                             <p class="text-sm text-gray-400">La promotion est proche ! Donnez tout !</p>
                        </div>
                    </div>
                </div>
                 <div class="mt-6 p-4 bg-black/20 rounded-xl mx-2">
                    <h4 class="font-bold text-center mb-2">Progression</h4>
                    <div class="progress-bar-tiers">
                        <div style="background: ${color.main}" class="opacity-50"></div>
                        <div style="background: ${color.main}" class="opacity-75"></div>
                        <div style="background: ${color.main}"></div>
                    </div>
                    <p class="text-xs text-gray-400 text-center mt-2">Atteignez 100% pour passer au rang suivant.</p>
                </div>
            `;
        }

        function openRankInfoModal() {
            const initialRank = state.rankInfoModal.selectedRank;
            
            const modalContent = `
                <div id="rank-info-modal" class="glass-card w-full max-w-md p-0 rounded-t-3xl border-none h-[85vh] flex flex-col overflow-hidden">
                    <header class="p-4 flex items-center justify-between flex-shrink-0 border-b border-white/10">
                        <h2 class="text-2xl font-bold">Système de Rangs</h2>
                        <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
                    </header>
                    <div class="flex-grow flex overflow-hidden">
                        <div class="w-1/3 border-r border-white/10 overflow-y-auto scrollbar-hide">
                            ${RANK_NAMES.map(rankName => `
                                <button class="rank-info-list-item w-full p-3 text-left flex items-center gap-3 transition-colors hover:bg-white/5 ${initialRank === rankName ? 'bg-white/10' : ''}" data-rank="${rankName}">
                                    <div class="w-8 h-8 flex-shrink-0">${getRankBadgeSVG(rankName + ' I')}</div>
                                    <span class="font-semibold text-sm">${rankName}</span>
                                </button>
                            `).join('')}
                        </div>
                        <div id="rank-info-details" class="w-2/3 p-4 overflow-y-auto scrollbar-hide">
                            ${renderRankInfoDetails(initialRank)}
                        </div>
                    </div>
                </div>
            `;
            showModal(modalContent, (modalWrapper) => {
                 modalWrapper.querySelector('.close-modal').onclick = closeModal;
                 modalWrapper.onclick = (e) => {
                    const rankItem = e.target.closest('.rank-info-list-item');
                    if (rankItem) {
                         const rankName = rankItem.dataset.rank;
                         state.rankInfoModal.selectedRank = rankName;
                         modalWrapper.querySelector('#rank-info-details').innerHTML = renderRankInfoDetails(rankName);
                         
                         modalWrapper.querySelectorAll('.rank-info-list-item').forEach(item => {
                             item.classList.remove('bg-white/10');
                             if(item.dataset.rank === rankName) item.classList.add('bg-white/10');
                         });
                    }
                 }
            });
        }

        function openRarityInfoModal() {
    const rarityItemsHtml = RARITY_INFO_DATA.map(rarity => {
        const rarityClass = `rarity-${normalizeString(rarity.name)}-text`;
        return `
        <div class="flex items-center gap-4">
            <div class="w-10 h-10 flex-shrink-0 flex items-center justify-center">
                <span class="text-3xl font-extrabold ${rarityClass}">◆</span>
            </div>
            <div class="flex-grow">
                <h4 class="font-bold ${rarityClass}">${rarity.name}</h4>
                <p class="text-sm text-gray-400">${rarity.description}</p>
            </div>
        </div>`;
    }).join('');

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[85vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Niveaux de Rareté</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
        </header>
        <div class="flex-grow overflow-y-auto space-y-4 pr-2 scrollbar-hide">
            ${rarityItemsHtml}
        </div>
    </div>`;

    showModal(modalContent);
}

function openProgramItemSelectorModal(type) {
    const isWorkout = type === 'workout';
    const items = isWorkout ? state.workouts : state.meals.filter(m => !m.isQuickAdd);
    
    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[70vh] flex flex-col">
        <h2 class="text-2xl font-bold mb-4">Ajouter ${isWorkout ? 'une séance' : 'un repas'}</h2>
        <div class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide">
            ${items.length > 0 ? items.map(item => `
                <button data-id="${item.id}" class="select-item-for-program w-full text-left glass-card p-3 rounded-lg hover:bg-white/20">
                    <p class="font-semibold">${item.name}</p>
                </button>
            `).join('') : '<p class="text-gray-500 text-center">Votre bibliothèque est vide.</p>'}
        </div>
        <button class="close-modal w-full mt-6 glass-card p-3 rounded-lg font-bold">Annuler</button>
    </div>
    `;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.addEventListener('click', (e) => {
            const selectBtn = e.target.closest('.select-item-for-program');
            if (selectBtn) {
                const itemId = selectBtn.dataset.id;
                const program = state.editingProgram;
                const targetArray = isWorkout ? program.programData.workouts : program.programData.meals;

                // On vérifie que l'élément n'est pas déjà ajouté
                if (!targetArray.some(item => item.id === itemId)) {
                    targetArray.push({ id: itemId }); // Pour l'instant on ne stocke que l'ID
                }
                closeModal();
                render();
            }
        });
    });
}

        function openStreakInfoModal(type) {
            const workoutRulesData = [
                { icon: 'fa-plus', color: 'text-green-400', text: "Effectuez au moins <strong>une séance</strong> dans la journée pour gagner <strong>+1</strong>." },
                { icon: 'fa-couch', color: 'text-blue-400', text: "Vous avez le droit à <strong>2 jours de repos</strong> consécutifs." },
                { icon: 'fa-xmark', color: 'text-red-400', text: "Après <strong>3 jours d'inactivité</strong>, votre série retombe à zéro." }
            ];
            const nutritionRulesData = [
                { icon: 'fa-check-double', color: 'text-green-400', text: "Atteignez vos <strong>2 objectifs</strong> (calories & protéines) pour gagner <strong>+1</strong>." },
                { icon: 'fa-check', color: 'text-yellow-400', text: "Atteignez <strong>1 seul objectif</strong> pour <strong>maintenir</strong> votre série actuelle." },
                { icon: 'fa-xmark', color: 'text-red-400', text: "Si vous n'atteignez <strong>aucun objectif</strong>, votre série retombe à zéro." }
            ];

            const isWorkout = type === 'workout';
            const title = isWorkout ? "Série d'Entraînements" : "Série Nutrition";
            const icon = isWorkout ? '<i class="fa-solid fa-fire-flame-curved streak-flame-gradient"></i>' : `<i class="fa-solid fa-fire-flame-curved streak-flame-gradient"></i>`;
            const rulesData = isWorkout ? workoutRulesData : nutritionRulesData;

            const modalContent = `
                <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
                    <div class="w-12 h-1.5 bg-gray-600 rounded-full mx-auto mb-4 flex-shrink-0"></div>
                    <div class="text-center mb-6">
                        <div class="text-4xl mb-2">${icon}</div>
                        <h2 class="text-2xl font-bold">${title}</h2>
                    </div>
                    
                    <div class="space-y-3">
                        ${rulesData.map(rule => `
                            <div class="flex items-start gap-4 p-4 bg-black/20 rounded-xl">
                                <div class="w-8 h-8 mt-1 flex-shrink-0 flex items-center justify-center rounded-full bg-gray-900/50">
                                    <i class="fa-solid ${rule.icon} ${rule.color}"></i>
                                </div>
                                <p class="text-gray-300 text-sm leading-relaxed">${rule.text}</p>
                            </div>
                        `).join('')}
                    </div>

                    <button class="close-modal w-full mt-8 btn-primary">J'ai compris !</button>
                </div>
            `;
            
            showModal(modalContent);
        }

function openTagSelectionModal(type) {
    const isWorkout = type === 'workout';
    const availableTags = isWorkout ? state.workoutTags : state.mealTags;
    const itemTags = (isWorkout ? state.editingWorkout.tags : state.editingMeal.tags) || [];

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Sélectionner des Tags</h2>
            <button id="manage-tags-btn" data-type="${type}" class="text-sm font-semibold hover:text-gray-300" style="color: var(--theme-primary);">Gérer les tags</button>
        </header>
        <div class="flex-grow flex flex-wrap gap-3 py-2">
            ${availableTags.map(tag => {
                const isSelected = itemTags.includes(tag.id);
                const bgColor = isSelected ? tag.color : `${tag.color}30`; // Fond opaque si sélectionné, transparent sinon
    const textColor = isSelected ? `black` : tag.color; // Texte noir si sélectionné, coloré sinon
    const border = isSelected ? `2px solid ${tag.color}` : '2px solid transparent';

    return `
    <button class="toggle-tag-btn text-base font-semibold px-4 py-2 rounded-full transition-all duration-200" 
            data-tag-id="${tag.id}" 
            style="background-color:${bgColor}; color:${textColor}; border: ${border};">
        ${tag.name}
    </button>`
            }).join('')}
        </div>
        <button class="close-modal btn-primary w-full mt-6">Valider</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.addEventListener('click', (e) => {
            const toggleBtn = e.target.closest('.toggle-tag-btn');
            const manageBtn = e.target.closest('#manage-tags-btn');

            if (toggleBtn) {
                const tagId = toggleBtn.dataset.tagId;
            const currentItem = isWorkout ? state.editingWorkout : state.editingMeal;

            // 1. On met à jour le tag dans l'état de l'application
            if (currentItem.tags[0] === tagId) {
                currentItem.tags = []; // Désélectionne
            } else {
                currentItem.tags = [tagId]; // Sélectionne
            }

            // 2. On met à jour l'apparence de TOUS les boutons dans la modale SANS la fermer
            const allTagButtons = modalWrapper.querySelectorAll('.toggle-tag-btn');
    allTagButtons.forEach(button => {
        const buttonTagId = button.dataset.tagId;
        const tagData = availableTags.find(t => t.id === buttonTagId);
        
        if (tagData) {
            if (currentItem.tags[0] === buttonTagId) {
                // Style "sélectionné"
                button.style.backgroundColor = tagData.color;
                button.style.color = 'black';
                button.style.border = `2px solid ${tagData.color}`;
            } else {
                // Style "non sélectionné" mais coloré
                button.style.backgroundColor = `${tagData.color}30`;
                button.style.color = tagData.color;
                button.style.border = '2px solid transparent';
            }
        }
    });

    render();
}
        
        if (manageBtn) {
            // Cette partie ne change pas et devrait déjà fonctionner
            openTagEditorModal(type);
        }
    });
});
}

function openGuideModal() {
            // On définit le contenu de notre guide de manière structurée
            const guideSections = [
                {
                    icon: 'fa-brain',
                    title: 'Le Concept Principal',
                    content: `
                        <p>FitFlow est une application à <strong>deux facettes</strong> : Workout et Nutrition. Le gros bouton au centre de la barre de navigation, le <strong>"Flow Switcher"</strong>, est la clé. Il vous permet de basculer instantanément tout le contexte de l'application entre ces deux modes.</p>
                        <p>Chaque page, de l'accueil au calendrier, s'adaptera pour afficher les informations pertinentes au mode que vous avez choisi.</p>
                    `
                },
                {
                    icon: 'fa-trophy',
                    title: 'Votre Progression',
                    content: `
                        <p>Votre aventure sur FitFlow est rythmée par deux systèmes de progression :</p>
                        <p><strong>1. Niveaux & XP :</strong> Gagnez de l'expérience (XP) et des pièces en terminant des séances et des quêtes. Chaque niveau atteint témoigne de votre assiduité !</p>
                        <p><strong>2. Les Rangs :</strong> De <strong>Novice</strong> à <strong>Demi-Dieu</strong>, chaque exercice possède son propre rang. Ce n'est pas une question de temps, mais de <strong>performance pure</strong>. Plus vous soulevez lourd et effectuez de répétitions, plus votre score et votre rang pour cet exercice augmentent !</p>
                    `
                },
                {
                    icon: 'fa-gift',
                    title: 'Quêtes & Récompenses',
                    content: `
                        <p>Chaque jour et chaque semaine, de nouvelles <strong>quêtes</strong> vous sont proposées. Les accomplir vous rapporte de l'XP et des <strong>pièces d'or</strong>.</p>
                        <p>Utilisez vos pièces dans la <strong>Boutique</strong> pour acheter des objets cosmétiques uniques comme des bordures de profil et des titres, et personnalisez votre identité dans l'application.</p>
                    `
                },
                {
                    icon: 'fa-calendar-days',
                    title: 'La Planification',
                    content: `
                        <p>Le secret de la réussite est un bon plan ! Rendez-vous dans les pages <strong>Bibliothèque</strong> (l'icône <i class="fa-solid fa-book-bookmark"></i>) pour créer vos propres modèles de séances ou de repas.</p>
                        <p>Ensuite, allez sur la page <strong>"Planifier"</strong> et faites simplement glisser-déposer vos modèles sur les jours du calendrier pour construire votre programme sur mesure.</p>
                    `
                },
                {
                    icon: 'fa-users',
                    title: 'Le Social (Bientôt !)',
                    content: `
                        <p>FitFlow ne fait que commencer. Prochainement, vous pourrez <strong>ajouter des amis</strong>, comparer vos statistiques, participer à des <strong>classements</strong> et relever des <strong>défis communautaires</strong>. Restez à l'écoute !</p>
                    `
                }
            ];

            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[85vh] flex flex-col">
                <header class="flex flex-col items-center mb-4 flex-shrink-0">
                    <div class="w-12 h-1.5 bg-gray-600 rounded-full mb-4"></div>
                    <h2 class="text-3xl font-bold">Guide de Démarrage</h2>
                    <p class="text-gray-400">Les bases pour bien commencer sur FitFlow</p>
                </header>
                <div id="guide-accordion-container" class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-3">
                    ${guideSections.map(section => `
                        <div>
                            <button class="guide-accordion-header">
                                <span class="flex items-center gap-3">
                                    <i class="fa-solid ${section.icon} w-6 text-center" style="color: var(--theme-light);"></i>
                                    <span>${section.title}</span>
                                </span>
                                <i class="fa-solid fa-chevron-down icon-rotate text-gray-500"></i>
                            </button>
                            <div class="guide-accordion-panel">
                                <div class="pt-4">${section.content}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                 <button class="close-modal w-full mt-6 btn-primary">C'est parti !</button>
            </div>`;
            
            showModal(modalContent, (modalWrapper) => {
                const accordionContainer = modalWrapper.querySelector('#guide-accordion-container');
                accordionContainer.addEventListener('click', e => {
                    const header = e.target.closest('.guide-accordion-header');
                    if (!header) return;

                    const panel = header.nextElementSibling;
                    
                    // Fermer tous les panneaux ouverts
                    accordionContainer.querySelectorAll('.guide-accordion-panel').forEach(p => {
                        if (p !== panel) {
                            p.style.maxHeight = null;
                            p.previousElementSibling.classList.remove('active');
                        }
                    });

                    // Ouvrir ou fermer le panneau cliqué
                    header.classList.toggle('active');
                    if (panel.style.maxHeight) {
                        panel.style.maxHeight = null;
                    } else {
                        panel.style.maxHeight = panel.scrollHeight + "px";
                    }
                });
            });
        }

function openDashboardModal() {
    const stats = getDashboardStats();
    const insights = getAdvancedInsights();
    const performedExercises = EXERCISE_DATABASE.filter(exo => state.exerciseStats[exo.id]);
    
    if (!state.selectedChartExerciseId && performedExercises.length > 0) {
        state.selectedChartExerciseId = performedExercises[0].id;
    }
    
    const selectedExercise = getExerciseById(state.selectedChartExerciseId);
    const prStats = selectedExercise ? state.exerciseStats[selectedExercise.id] : null;
    const rmValues = prStats && prStats.allTimeBest ? calculate1RM(prStats.allTimeBest.bestSet, selectedExercise) : { total1RM: 0, lest1RM: 0 };
    
    // Correction pour n'afficher que le poids d'un haltère pour les exercices bilatéraux
    let display1RM = rmValues.total1RM;
    if (selectedExercise && selectedExercise.bilateral) {
        display1RM /= 2;
    }

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[85vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Statistiques Détaillées</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">×</button>
        </header>
        
        <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide">
            <div class="grid grid-cols-3 gap-3 mb-8">
                <button data-action="open-sessions-details" class="glass-card p-3 rounded-xl text-center hover:bg-white/10 transition-colors">
                    <p class="text-xs text-gray-400">Séances</p>
                    <p class="text-2xl font-bold">${stats.totalSessions}</p>
                </button>
                <button data-action="open-time-details" class="glass-card p-3 rounded-xl text-center hover:bg-white/10 transition-colors">
                    <p class="text-xs text-gray-400">Temps Total</p>
                    <p class="text-xl font-bold">${stats.totalTime}</p>
                </button>
                <button data-action="open-volume-details" class="glass-card p-3 rounded-xl text-center hover:bg-white/10 transition-colors">
                    <p class="text-xs text-gray-400">Volume</p>
                    <p class="text-xl font-bold">${stats.totalVolume}</p>
                </button>
            </div>

            <div class="glass-card p-4 rounded-2xl mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">Analyse de Progression</h2>
                    <button data-action="open-dashboard-help" class="text-gray-500 hover:text-violet-400"><i class="fa-solid fa-circle-question text-xl"></i></button>
                </div>
                
                <div class="relative custom-select-container mb-4">
                    <button id="exercise-select-button" class="custom-select-button">
                        <span class="font-semibold">${selectedExercise ? selectedExercise.name : 'Choisir un exercice'}</span>
                        <i class="fa-solid fa-chevron-down text-gray-500"></i>
                    </button>
                    <div id="exercise-select-options" class="custom-select-options">
                        ${performedExercises.length > 0 ? performedExercises.map(exo => `<div class="custom-select-option" data-value="${exo.id}">${exo.name}</div>`).join('') : '<div class="p-3 text-gray-500">Aucun exercice pratiqué</div>'}
                    </div>
                </div>

                <div class="h-56 mb-4"><canvas id="progression-chart"></canvas></div>
                
                <div class="text-center">
                    <p class="text-sm font-semibold text-gray-400">1-Rep Max (1RM) Estimé</p>
                    <p class="text-5xl font-bold text-violet-400">${formatVolume(display1RM)}</p>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-4">
                 <div class="glass-card p-4 rounded-xl">
                     <p class="font-bold text-sm mb-2">⚡ Vos Insights</p>
                     <p class="text-xs text-gray-300">Jour fétiche : <span class="font-bold text-white">${insights.bestDay}</span></p>
                     <p class="text-xs text-gray-300">Focus sur : <span class="font-bold text-white">${insights.mostTrainedGroup}</span></p>
                 </div>
                 <button id="show-history-btn" class="glass-card p-4 rounded-xl flex flex-col justify-center items-center text-center hover:bg-white/10">
                    <i class="fa-solid fa-clock-rotate-left text-2xl mb-2"></i>
                    <p class="font-bold text-sm">Historique complet</p>
                 </button>
            </div>
        </div>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        renderProgressionChart(); 

        // Gestionnaire d'événements pour la modale
        modalWrapper.addEventListener('click', e => {
            // La logique pour ouvrir le menu est maintenant gérée par le `mainClickHandler` global.
            // On ne gère ici que la SÉLECTION d'une option.
            const dropdownOption = e.target.closest('#exercise-select-options .custom-select-option');
            
            if (dropdownOption) {
                state.selectedChartExerciseId = dropdownOption.dataset.value;
                const newExercise = getExerciseById(state.selectedChartExerciseId);

                // Mettre à jour le texte du bouton et le 1RM affiché
                const button = modalWrapper.querySelector('#exercise-select-button');
                if(button) button.querySelector('.font-semibold').textContent = newExercise.name;
                
                const prStats = newExercise ? state.exerciseStats[newExercise.id] : null;
                const rmValues = prStats && prStats.allTimeBest ? calculate1RM(prStats.allTimeBest.bestSet, newExercise) : { total1RM: 0 };
                let newDisplay1RM = rmValues.total1RM;
                if (newExercise && newExercise.bilateral) {
                    newDisplay1RM /= 2;
                }
                modalWrapper.querySelector('.text-5xl.font-bold').textContent = formatVolume(newDisplay1RM);
                
                // Redessiner le graphique et fermer le menu
                renderProgressionChart();
                closeAllDropdowns();
            } else if (e.target.closest('[data-action="open-dashboard-help"]')) {
                openDashboardHelpModal();
            } else if (e.target.closest('#show-history-btn')) {
                openSessionHistoryModal();
            } else if (e.target.closest('[data-action="open-sessions-details"]')) {
                openSessionsModal();
            } else if (e.target.closest('[data-action="open-time-details"]')) {
                openTimeModal();
            } else if (e.target.closest('[data-action="open-volume-details"]')) {
                openVolumeModal();
            }
        });
    });
}

async function openTagEditorModal(type) {
    const isWorkout = type === 'workout';
    let tagList = isWorkout ? state.workoutTags : state.mealTags;

    const renderTagList = () => {
        return tagList.map(tag => `
            <div class="flex items-center justify-between p-2 glass-card rounded-lg">
                <div class="flex items-center gap-3">
                    <input type="color" class="tag-color-input w-8 h-8 bg-transparent border-none rounded-md cursor-pointer" value="${tag.color}" data-tag-id="${tag.id}">
                    <span class="font-semibold">${tag.name}</span>
                </div>
                <button class="delete-tag-btn text-red-400 p-2" data-tag-id="${tag.id}"><i class="fa-solid fa-trash-can"></i></button>
            </div>
        `).join('');
    };

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Gérer les Tags</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        <div id="tag-editor-list" class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-hide">${renderTagList()}</div>
        <div class="mt-4 pt-4 border-t border-white/10">
            <h3 class="font-bold mb-2">Ajouter un tag</h3>
            <div class="flex gap-2">
                <input id="new-tag-name" type="text" class="input-glass flex-grow" placeholder="Nom du tag">
                <input id="new-tag-color" type="color" class="w-14 h-14 bg-transparent p-1 rounded-lg" value="#A78BFA">
                <button id="add-new-tag-btn" class="btn-primary flex-shrink-0 px-4">Ajouter</button>
            </div>
        </div>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
    const listContainer = modalWrapper.querySelector('#tag-editor-list');

    // On rend l'écouteur d'événement "click" asynchrone
    modalWrapper.addEventListener('click', async (e) => { // <-- 1. AJOUT DE ASYNC ICI
        // Logique pour ajouter un nouveau tag
        if (e.target.closest('#add-new-tag-btn')) {
            const nameInput = modalWrapper.querySelector('#new-tag-name');
            const colorInput = modalWrapper.querySelector('#new-tag-color');
            const name = nameInput.value.trim();
            if (name) {
                const newTag = { id: generateId(), name, color: colorInput.value };
                tagList.push(newTag);
                nameInput.value = '';

                // On sauvegarde l'état APRÈS avoir ajouté le tag à la liste
                await saveState();
                
                // Puis on met à jour l'affichage
                listContainer.innerHTML = renderTagList();
            }
        }
        
        // Logique pour supprimer un tag
        const deleteBtn = e.target.closest('.delete-tag-btn');
        if (deleteBtn) {
            const tagId = deleteBtn.dataset.tagId;
            // Supprimer le tag de la liste principale
            tagList = tagList.filter(t => t.id !== tagId);
            if (isWorkout) state.workoutTags = tagList; else state.mealTags = tagList;
            
            // Le retirer de toutes les séances/repas qui l'utilisent
            const items = isWorkout ? state.workouts : state.meals;
            items.forEach(item => {
                if (item.tags) {
                    item.tags = item.tags.filter(id => id !== tagId);
                }
            });

            // On sauvegarde l'état APRÈS toutes les modifications
            await saveState(); // <-- 2. AJOUT DE LA SAUVEGARDE ICI

            // Puis on met à jour l'affichage
            listContainer.innerHTML = renderTagList();
        }
    });

    // L'écouteur "input" ne change pas. Il modifie l'état local,
    // mais nous ne sauvegardons qu'à la fin pour éviter trop d'appels à la base de données.
    modalWrapper.addEventListener('input', (e) => {
        const colorInput = e.target.closest('.tag-color-input');
        if (colorInput) {
            const tagId = colorInput.dataset.tagId;
            const tag = tagList.find(t => t.id === tagId);
            if (tag) {
                tag.color = colorInput.value;
            }
        }
    });
    
    // On rend l'écouteur du bouton "Fermer" asynchrone pour sauvegarder les changements de couleur
    modalWrapper.querySelector('.close-modal').addEventListener('click', async () => { // <-- 3. AJOUT DE ASYNC ICI
        // On sauvegarde toutes les modifications (notamment les couleurs) avant de fermer
        await saveState(); // <-- 4. AJOUT DE LA SAUVEGARDE ICI
        
        render(); // Re-render la page en arrière-plan pour refléter tous les changements
    });
});
}

async function openPublicProfileModal(userId, isNested = false) {
    showToast("Chargement du profil...", "info");

    try {
        const userDoc = await getDoc(doc(db, 'publicProfiles', userId));
        if (!userDoc.exists()) {
            showToast("Impossible de trouver le profil de cet utilisateur.", "error");
            return;
        }

        const profile = userDoc.data();
        
        const displayInfo = getDisplayLevelInfo(profile.leveling.realLevel);
        const levelColors = getLevelTierColors(profile.leveling.realLevel);
        const equippedTitle = TITLES_DATABASE.find(t => t.id === profile.equipped.title) || { name: 'Aucun titre', rarity: 'Commun' };
        const equippedBorder = BORDERS_DATABASE.find(b => b.id === profile.equipped.border) || { style: '' };
        let titleClass = equippedTitle.color ? equippedTitle.color : `rarity-${normalizeString(equippedTitle.rarity)}-text`;
        const rankData = calculateGlobalRank(profile.globalRank);

        let buttonHtml = '';
        if (userId === currentUserId) {
            buttonHtml = `<button class="w-full mt-6 btn-primary opacity-60 cursor-not-allowed flex items-center justify-center gap-2" disabled><i class="fa-solid fa-user-astronaut"></i><span>C'est votre profil</span></button>`;
        } else {
            const status = getFriendshipStatus(profile.uid);
            switch (status) {
                case 'friends':
                    buttonHtml = `<button class="w-full mt-6 btn-primary opacity-60 cursor-not-allowed flex items-center justify-center gap-2" disabled><i class="fa-solid fa-user-check"></i><span>Vous êtes amis</span></button>`;
                    const ts = state.friends.friendshipTimestamps?.[profile.uid];
                    if (ts && typeof ts.toDate === 'function') {
                        const date = ts.toDate().toLocaleDateString('fr-FR', { day: 'numeric', month: 'long' });
                        buttonHtml += `<p class="text-xs text-gray-400 mt-2">Ami depuis le ${date}</p>`;
                    }
                    break;
                case 'pending':
                    buttonHtml = `<button data-action="cancel-friend-request" data-uid="${profile.uid}" class="w-full mt-6 secondary-btn">Annuler la demande</button>`;
                    break;
                case 'received':
                    buttonHtml = `<button data-action="go-to-inbox-and-close" class="w-full mt-6 btn-primary">Répondre à la demande</button>`;
                    break;
                default:
                    buttonHtml = `<button data-action="send-friend-request" data-uid="${profile.uid}" class="w-full mt-6 btn-primary">Ajouter en ami</button>`;
            }
        }
        
        const gymHtml = profile.gymId ? `
            <button data-action="view-public-gym" data-gym-id="${profile.gymId}" class="arc-stat-block hover:bg-white/5 rounded-lg">
                <p class="text-xs text-gray-400 font-semibold uppercase">Salle</p>
                <i class="fa-solid fa-dumbbell text-2xl text-violet-300 mt-2"></i>
            </button>` : `
            <div class="arc-stat-block opacity-40">
                <p class="text-xs text-gray-400 font-semibold uppercase">Salle</p>
                <span class="fa-stack fa-1x mt-2">
                    <i class="fa-solid fa-dumbbell fa-stack-1x text-gray-700"></i>
                    <i class="fa-solid fa-ban fa-stack-2x text-gray-500"></i>
                </span>
            </div>`;

        const clanIconData = profile.clanIconId ? CLAN_ICONS.find(i => i.id === profile.clanIconId) : null;
        const clanIconClass = clanIconData ? clanIconData.icon : 'fa-users';
        
        let iconFinalClasses = `fa-solid ${clanIconClass} text-2xl mt-2`;
        let iconFinalStyle = `color: ${profile.clanIconColor || 'text-violet-300'};`;

        if (profile.iconIsAnimated) {
            iconFinalClasses += ' dynamic-animated-gradient-icon';
            iconFinalStyle = `--base-color-icon: ${profile.clanIconColor}; --highlight-color-icon: ${lightenColor(profile.clanIconColor, 0.4)};`;
        }

        const clanHtml = profile.clanId ? `
            <button data-action="view-public-clan" data-clan-id="${profile.clanId}" class="arc-stat-block hover:bg-white/5 rounded-lg">
                <p class="text-xs text-gray-400 font-semibold uppercase">Équipe</p>
                <i class="${iconFinalClasses}" style="${iconFinalStyle}"></i>
            </button>` : `
            <div class="arc-stat-block opacity-40">
                <p class="text-xs text-gray-400 font-semibold uppercase">Équipe</p>
                <span class="fa-stack fa-1x mt-2">
                    <i class="fa-solid fa-users fa-stack-1x text-gray-700"></i>
                    <i class="fa-solid fa-ban fa-stack-2x text-gray-500"></i>
                </span>
            </div>`;

        let levelDisplayHtml;
        if (profile.leveling.isMaxedOut) {
            levelDisplayHtml = `<p class="text-2xl font-extrabold max-level-animated-badge">MAX</p>`;
        } else {
            const starsHtml = displayInfo.prestige > 0 
                ? `<div class="flex items-center justify-center gap-1">${Array.from({ length: displayInfo.prestige }, () => `<i class="fa-solid fa-star text-yellow-400 text-[10px]"></i>`).join('')}</div>`
                : '';
            levelDisplayHtml = `
                <p class="text-2xl font-extrabold" style="color:${levelColors.color};">${displayInfo.displayLevel}</p>
                <div class="h-4 mt-1">${starsHtml}</div>
            `;
        }
        
        const modalContent = `
        <style>
            .profile-modal-final { 
                background-color: #1a1c2a;
                background-image: 
                    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
                    radial-gradient(at 0% 0%, var(--rank-glow-color) 0px, transparent 50%);
                background-size: 20px 20px, 20px 20px, 100% 100%;
            }
            .profile-arc {
                background: linear-gradient(180deg, rgba(38, 41, 61, 0.7), rgba(30, 32, 48, 0.7));
                backdrop-filter: blur(10px);
                border-top: 2px solid rgba(255,255,255,0.1);
                border-radius: 100% / 50%;
                border-bottom-left-radius: 0; border-bottom-right-radius: 0;
                padding-top: 1rem; padding-bottom: 0.5rem;
                position: relative;
                box-shadow: inset 0 4px 10px -5px rgba(255, 255, 255, 0.25);
            }
            .showcase-item-final {
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 0.75rem; 
                border: 2px solid transparent;
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
            }
            .showcase-item-default-border {
                border-color: rgba(255, 255, 255, 0.1);
            }
            .showcase-item-final::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 30%;
                height: 100%;
                background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.25) 50%, rgba(255, 255, 255, 0) 100%);
                animation: final-glare-animation 2.8s infinite cubic-bezier(0.83, 0, 0.17, 1);
                pointer-events: none;
            }
            @keyframes final-glare-animation {
                0% { transform: translateX(-200%) skewX(-25deg); }
                25% { transform: translateX(400%) skewX(-25deg); }
                100% { transform: translateX(400%) skewX(-25deg); }
            }
            .rarity-commun-border { border-color: #6B7280; }
            .rarity-rare-border { border-color: #60A5FA; }
            .rarity-epique-border { border-color: #8d62f0; }
            .rarity-legendaire-border { border-color: #ffffff; }
            .rarity-mythique-border { border-color: #f0d133; }
            .rarity-divin-border { border-color: #06B6D4; }
            .rarity-createur-border { border-color: #B91C1C; }
        </style>

        <div class="profile-modal-final p-6 rounded-3xl w-full max-w-sm flex flex-col items-center relative overflow-hidden border border-white/10" style="--rank-glow-color: ${rankData.globalRankColor.main}30;">
            <button class="close-modal absolute top-4 right-4 w-8 h-8 rounded-full bg-black/30 z-20 flex items-center justify-center">&times;</button>
            
            <div class="flex flex-col items-center z-10">
                <div class="relative w-28 h-28">
                    <div class="w-full h-full rounded-full p-1" style="${equippedBorder.style}">
                        <div class="w-full h-full bg-gray-900 rounded-full overflow-hidden">
                           ${renderAvatar(profile.profilePicUrl, "w-full h-full object-cover")}
                        </div>
                    </div>
                </div>
                <h2 class="text-3xl font-bold mt-3">${profile.name}</h2>
                <p class="font-bold text-lg truncate ${titleClass}" title="${equippedTitle.name}">${equippedTitle.name}</p>
            </div>
            
            <div class="w-full z-10 mt-6 grid grid-cols-3 gap-1 justify-center">
                ${profile.equipped.showcase.map((itemId) => {
                    const item = COLLECTIBLES_DATABASE.find(c => c.id === itemId);
                    const rarityBorderClass = item ? `rarity-${normalizeString(item.rarity)}-border` : 'showcase-item-default-border';
                    return `
                    <div class="showcase-item-final w-20 h-20 mx-auto flex items-center justify-center ${rarityBorderClass}">
                        ${item ? `<i class="fa-solid ${item.icon} text-3xl ${item.color || ''}"></i>` : '<i class="fa-solid fa-plus text-xl text-gray-600"></i>'}
                    </div>`;
                }).join('')}
            </div>

            <div class="w-full max-w-xs z-10 mt-6">
                <div class="profile-arc flex justify-around items-start">
                    <button data-action="view-public-level-details" class="arc-stat-block text-center hover:bg-white/5 rounded-lg">
                        <p class="text-xs text-gray-400 font-semibold uppercase">Niveau</p>
                        <div class="flex flex-col items-center justify-center min-h-[50px] pt-1">
                           ${levelDisplayHtml}
                        </div>
                    </button>
                    <button data-action="view-public-rank-details" class="arc-stat-block hover:bg-white/5 rounded-lg">
                        <p class="text-xs text-gray-400 font-semibold uppercase">Rank</p>
                        <div class="w-10 h-10 mx-auto mt-1">${getRankBadgeSVG(profile.globalRank, '100%')}</div>
                    </button>
                    ${gymHtml}
                    ${clanHtml}
                </div>
            </div>

            <div class="w-full z-10">
                ${buttonHtml}
            </div>
        </div>
        `;

        const setupCallback = (modalWrapper) => {
            modalWrapper.addEventListener('click', async (e) => {
                const actionButton = e.target.closest('button[data-action]');
                if (!actionButton || actionButton.disabled) return;

                const action = actionButton.dataset.action;
                
                if (action === 'view-public-level-details') {
                    openPublicUserLevelDetailsModal(profile);
                    return;
                }
                if (action === 'view-public-rank-details') {
                    openPublicUserRankDetailsModal(profile);
                    return;
                }

                const uid = actionButton.dataset.uid;
                const clanId = actionButton.dataset.clanId;
                const gymId = actionButton.dataset.gymId;

                if (action === 'send-friend-request') {
                    actionButton.disabled = true;
                    actionButton.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> Envoi...`;
                    const success = await sendFriendRequest(uid);
                    if (success) {
                        actionButton.textContent = 'Annuler la demande';
                        actionButton.dataset.action = 'cancel-friend-request';
                        actionButton.classList.remove('btn-primary');
                        actionButton.classList.add('secondary-btn');
                    } else {
                        actionButton.textContent = 'Ajouter en ami';
                    }
                    actionButton.disabled = false;
                }

                if (action === 'cancel-friend-request') {
                    actionButton.disabled = true;
                    actionButton.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> Annulation...`;
                    const success = await cancelFriendRequest(uid);
                    if (success) {
                        actionButton.textContent = 'Ajouter en ami';
                        actionButton.dataset.action = 'send-friend-request';
                        actionButton.classList.remove('secondary-btn');
                        actionButton.classList.add('btn-primary');
                    } else {
                         actionButton.textContent = 'Annuler la demande';
                    }
                    actionButton.disabled = false;
                }

                if (action === 'go-to-inbox-and-close') {
                    closeModal();
                    navigate('Inbox');
                }

                if (action === 'view-public-clan') {
                    e.stopPropagation();
                    openPublicClanViewModal(clanId, true);
                }

                if (action === 'view-public-gym') {
                    e.stopPropagation();
                    openPublicGymViewModalFromId(gymId, true);
                }
            });
        };

        showModal(modalContent, setupCallback, null, isNested);

    } catch (error) {
        console.error("Erreur lors de l'ouverture du profil public:", error);
        showToast("Une erreur est survenue.", "error");
    }
}

function openLeaveClanConfirmationModal() {
    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-2">Quitter l'équipe ?</h2>
        <p class="text-gray-400 mb-6">Êtes-vous sûr de vouloir quitter cette équipe ? Cette action est irréversible.</p>
        <div class="flex gap-4">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-leave-clan" class="w-full bg-red-600 text-white p-3 rounded-lg font-bold">Quitter</button>
        </div>
    </div>`;
    showModal(modalContent, (wrapper) => {
        wrapper.querySelector('#confirm-leave-clan').onclick = async () => {
            const success = await leaveClan();
            if (success) {
                closeModal();
                if (state.activePage === 'Social') {
                    renderSocialContent();
                }
            }
        };
    });
}

function openCollectionModal() {
            const rarityOrder = { 'Commun': 1, 'Rare': 2, 'Épique': 3, 'Légendaire': 4, 'Mythique': 5 };

            const renderCollectionGrid = (sortOrder) => {
                const ownedItems = state.userProfile.inventory.collectibles.map(id => 
                    COLLECTIBLES_DATABASE.find(item => item.id === id)
                ).filter(Boolean); // Filtre pour enlever les items non trouvés

                ownedItems.sort((a, b) => {
                    switch(sortOrder) {
                        case 'rarity_asc':
                            return rarityOrder[a.rarity] - rarityOrder[b.rarity] || a.name.localeCompare(b.name);
                        case 'rarity_desc':
                            return rarityOrder[b.rarity] - rarityOrder[a.rarity] || a.name.localeCompare(b.name);
                        case 'alpha':
                        default:
                            return a.name.localeCompare(b.name);
                    }
                });

                if (ownedItems.length === 0) {
                    return `<div class="text-center text-gray-500 pt-16">Votre collection est vide. Achetez des box pour la remplir !</div>`;
                }

                return `<div class="grid grid-cols-3 sm:grid-cols-4 gap-4">
                    ${ownedItems.map(item => `
                        <div class="glass-card p-3 rounded-xl text-center">
                            <i class="fa-solid ${item.icon} text-4xl ${item.color}"></i>
                            <p class="text-xs font-bold mt-2 truncate">${item.name}</p>
                            <p class="text-[10px] text-gray-400">${item.rarity}</p>
                        </div>
                    `).join('')}
                </div>`;
            };

            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[85vh] flex flex-col">
                <header class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h2 class="text-2xl font-bold">Ma Collection</h2>
                    <div class="relative custom-select-container w-48">
                         <button id="collection-sort-button" class="custom-select-button !py-2 !text-sm">
                            <span>Trier par...</span><i class="fa-solid fa-chevron-down text-gray-500"></i>
                         </button>
                         <div id="collection-sort-options" class="custom-select-options">
                            <div class="custom-select-option" data-value="alpha">Alphabétique</div>
                            <div class="custom-select-option" data-value="rarity_desc">Rareté ⬇</div>
                            <div class="custom-select-option" data-value="rarity_asc">Rareté ⬆</div>
                         </div>
                    </div>
                </header>
                <div id="collection-grid" class="flex-grow overflow-y-auto pr-2 scrollbar-hide">
                    ${renderCollectionGrid(state.collectionSortOrder || 'alpha')}
                </div>
            </div>`;

            showModal(modalContent, (modalWrapper) => {
                modalWrapper.querySelector('#collection-sort-button').onclick = () => {
                    modalWrapper.querySelector('#collection-sort-options').classList.toggle('active');
                };
                modalWrapper.querySelector('#collection-sort-options').onclick = (e) => {
                    const option = e.target.closest('.custom-select-option');
                    if (option) {
                        state.collectionSortOrder = option.dataset.value;
                        modalWrapper.querySelector('#collection-grid').innerHTML = renderCollectionGrid(state.collectionSortOrder);
                        modalWrapper.querySelector('#collection-sort-options').classList.remove('active');
                    }
                };
            });
        }

        function openRankDetailsModal(exerciseId) {
            const exercise = getExerciseById(exerciseId);
            const stats = state.exerciseStats[exerciseId] || { rankPr: null, allTimeBest: null };
            const rankPr = stats.rankPr;
            const allTimeBest = stats.allTimeBest;

            const rankInfo = getRankFromScore(rankPr?.score || 0, exerciseId);

            const rankPrDate = rankPr?.dateAchieved ? new Date(rankPr.dateAchieved).toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' }) : 'Jamais';

            let rankPrText = 'Aucune donnée';
            if (rankPr?.bestSet) {
                rankPrText = `${rankPr.bestSet.weight} kg x ${rankPr.bestSet.reps} reps`;
            }

            let allTimeBestText = '';
            if (allTimeBest?.bestSet) {
                const bestPerfText = `${allTimeBest.bestSet.weight} kg x ${allTimeBest.bestSet.reps} reps`;
                if (!rankPr?.bestSet || (rankPr.bestSet.weight !== allTimeBest.bestSet.weight || rankPr.bestSet.reps !== allTimeBest.bestSet.reps)) {
                     allTimeBestText = `<p class="text-xs text-gray-500 mt-1 italic">(Meilleure perf. brute: ${bestPerfText})</p>`;
                }
            }

            const modalContent = `
                <div class="rank-modal-content p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
                    <h3 class="font-semibold text-lg text-gray-300 mb-2 z-10">${exercise.name}</h3>
                    <div class="relative w-32 h-32 mb-4 rank-badge-container">${getRankBadgeSVG(rankInfo.name)}</div>
                    <div class="relative z-10 w-full">
                        <h2 class="text-4xl font-extrabold mb-1">${rankInfo.name}</h2>
                        ${rankInfo.sr > 0 ? `<p class="text-2xl font-bold text-yellow-300">+${rankInfo.sr} SR</p>` : ''}
                        <p class="text-sm text-gray-400 mb-6">${rankPrDate !== 'Jamais' ? 'Atteint le ' + rankPrDate : 'Jamais atteint'}</p>
                        
                        <div class="w-full bg-black/20 p-4 rounded-xl text-center">
                            <p class="text-sm font-semibold text-gray-300 uppercase tracking-wider">Record de Rang</p>
                            <p class="text-2xl font-bold mt-1">${rankPrText}</p>
                            ${rankPr?.bodyWeightAtPR ? `<p class="text-xs text-gray-400">(à ${rankPr.bodyWeightAtPR} kg de poids de corps)</p>` : ''}
                            ${allTimeBestText}
                        </div>

                        <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold">Fermer</button>
                    </div>
                </div>
            `;
            showModal(modalContent);
        }


function calculateMuscleGroupRank(groupKey) {
    const exercisesForGroup = EXERCISE_DATABASE.filter(exo => exo.groups && exo.groups[groupKey]);
    if (exercisesForGroup.length === 0) return { globalRank: 'N/A', globalRankColor: getRankColor('Novice') };
    
    const practicedExercises = exercisesForGroup.filter(exo => state.exerciseStats[exo.id]);
    if (practicedExercises.length === 0) return { globalRank: 'N/A', globalRankColor: getRankColor('Novice') };

    const totalPoints = practicedExercises.reduce((sum, exo) => {
        const score = state.exerciseStats[exo.id].rankPr.score || 0;
        const rankInfo = getRankFromScore(score, exo.id);
        return sum + rankInfo.points;
    }, 0);

    const avgPoints = Math.round(totalPoints / practicedExercises.length);
    const rankInfo = getRankFromPoints(avgPoints);
    
    return { globalRank: rankInfo.name, globalRankColor: getRankColor(rankInfo.baseName) };
}

function calculateGlobalAchievementProgress() {
    // 1. On filtre les succès pour exclure ceux qui sont cachés
    const relevantAchievements = ACHIEVEMENTS_DATABASE.filter(ach => !ach.isHidden);
    
    let userTotalPoints = 0;
    let totalPossiblePoints = 0;
    let fullyCompletedCount = 0;

    // 2. On parcourt chaque succès pour calculer les scores
    relevantAchievements.forEach(ach => {
        // Le maximum de points pour un succès est le nombre de paliers * 100
        const maxPointsForThisAch = ach.tiers.length * 100;
        totalPossiblePoints += maxPointsForThisAch;

        // On utilise la fonction existante pour obtenir le score actuel de l'utilisateur pour ce succès
        const userScoreForThisAch = calculateComprehensiveAchievementScore(ach);
        userTotalPoints += userScoreForThisAch;

        // On vérifie si ce succès est complété à 100%
        if (userScoreForThisAch >= maxPointsForThisAch) {
            fullyCompletedCount++;
        }
    });

    // 3. On calcule le pourcentage final
    const percentage = totalPossiblePoints > 0 ? (userTotalPoints / totalPossiblePoints) * 100 : 0;

    // 4. On retourne un objet complet avec toutes les infos nécessaires
    return {
        percentage: percentage.toFixed(1),
        fullyCompletedCount: fullyCompletedCount,
        total: relevantAchievements.length
    };
}

        async function openEditIngredientModal(ingredientId) {
    if (!state.editingMeal) return;
    const ingredient = state.editingMeal.ingredients.find(ing => ing.id === ingredientId);
    if (!ingredient) return;

    const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <h2 class="text-xl font-bold mb-4">Modifier: ${ingredient.name}</h2>
        <div class="relative">
            <input id="quantity-input-edit" type="number" class="input-glass text-center" value="${ingredient.quantity}">
            <span class="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400">grammes</span>
        </div>
        <div class="flex gap-4 mt-6">
            <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
            <button id="confirm-quantity-edit-btn" class="w-full btn-primary">Valider</button>
        </div>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#confirm-quantity-edit-btn').onclick = async () => {
    const newQuantity = parseFloat(modalWrapper.querySelector('#quantity-input-edit').value);
    if (!newQuantity || newQuantity <= 0) return;

    // Met à jour la quantité (déjà présent)
    ingredient.quantity = newQuantity;

    // --- BLOC À AJOUTER ---
    // Recalcule les nutriments de la portion immédiatement
    const base = ingredient.base_100g;
    ingredient.nutrition = {
        calories: (base.calories / 100) * newQuantity,
        protein: (base.protein / 100) * newQuantity,
        carbs: (base.carbs / 100) * newQuantity,
        fat: (base.fat / 100) * newQuantity,
        sugars: (base.sugars / 100) * newQuantity,
        fiber: (base.fiber / 100) * newQuantity,
        saturated_fat: (base.saturated_fat / 100) * newQuantity
    };
            await saveState();
            closeModal();
            render();
        };
    });
}

// DANS index.html, REMPLACEZ CETTE FONCTION
function openMealDetailsModal() {
    if (!state.editingMeal) return;
    const meal = state.editingMeal;
    
    // Le calcul des totaux reste le même, il inclut tous les ingrédients.
    const allTotals = meal.ingredients.reduce((acc, ing) => {
        const nut = ing.nutrition;
        acc.calories += nut.calories || 0;
        acc.protein += nut.protein || 0;
        acc.carbs += nut.carbs || 0;
        acc.fat += nut.fat || 0;
        acc.sugars += nut.sugars || 0;
        acc.fiber += nut.fiber || 0;
        acc.saturated_fat += nut.saturated_fat || 0;
        return acc;
    }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugars: 0, fiber: 0, saturated_fat: 0 });

    // --- NOUVELLE LOGIQUE DE DÉTECTION (CORRIGÉE) ---
    // Ce bloc vérifie maintenant chaque nutriment, indépendamment du Nutri-Score.
    const incompleteIngredientsForDisclaimer = [];
    meal.ingredients.forEach(ing => {
        const missingNutrients = [];
        const fieldsToCheck = {
            calories: 'Calories',
            protein: 'Protéines',
            carbs: 'Glucides',
            sugars: 'Sucres',
            fat: 'Lipides',
            saturated_fat: 'Graisses saturées',
            fiber: 'Fibres'
        };

        // On vérifie chaque nutriment clé.
        for (const [key, name] of Object.entries(fieldsToCheck)) {
            // On regarde la donnée brute dans `base_100g` pour voir si elle était absente à l'origine.
            if (typeof ing.base_100g[key] !== 'number') {
                missingNutrients.push(name);
            }
        }

        // Si on a trouvé au moins un nutriment manquant, on ajoute l'ingrédient à la liste pour l'avertissement.
        if (missingNutrients.length > 0) {
            incompleteIngredientsForDisclaimer.push({
                name: ing.name,
                missing: missingNutrients.join(', ')
            });
        }
    });
    
    const disclaimerIconHtml = incompleteIngredientsForDisclaimer.length > 0 ? `
        <button id="open-nutrition-disclaimer" class="text-yellow-400 hover:text-yellow-300 ml-3">
            <i class="fa-solid fa-triangle-exclamation text-xl"></i>
        </button>
    ` : '';
    // --- FIN DE LA NOUVELLE LOGIQUE ---

    const totalMacrosInGrams = allTotals.protein + allTotals.carbs + allTotals.fat;
    const proteinPercentage = totalMacrosInGrams > 0 ? (allTotals.protein / totalMacrosInGrams) * 100 : 0;
    const carbsPercentage = totalMacrosInGrams > 0 ? (allTotals.carbs / totalMacrosInGrams) * 100 : 0;
    const fatPercentage = totalMacrosInGrams > 0 ? (allTotals.fat / totalMacrosInGrams) * 100 : 0;
    const fiberPercentage = Math.min(100, (allTotals.fiber / 10) * 100);

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
        <header class="flex justify-center items-center mb-6">
            <h2 class="text-2xl font-bold text-center">Détails Nutritionnels</h2>
            ${disclaimerIconHtml}
        </header>
        
        <div class="flex justify-between items-center mb-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-fire-flame-curved streak-flame-gradient"></i>
                <span class="font-semibold text-lg">Calories</span>
            </div>
            <span class="font-bold text-lg">${allTotals.calories.toFixed(0)} kcal</span>
        </div>

        <div class="space-y-4">
            <div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-3"><i class="fa-solid fa-drumstick-bite text-xl text-sky-400 w-6 text-center"></i><span class="font-semibold">Protéines</span></div>
                    <span class="font-bold">${allTotals.protein.toFixed(1)} g</span>
                </div>
                <div class="w-full bg-black/20 rounded-full h-1.5 mt-2"><div class="bg-sky-400 h-1.5 rounded-full" style="width: ${proteinPercentage}%"></div></div>
            </div>
            <div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-3"><i class="fa-solid fa-bread-slice text-xl text-purple-400 w-6 text-center"></i><span class="font-semibold">Glucides</span></div>
                    <span class="font-bold">${allTotals.carbs.toFixed(1)} g</span>
                </div>
                <div class="w-full bg-black/20 rounded-full h-1.5 mt-2"><div class="bg-purple-400 h-1.5 rounded-full" style="width: ${carbsPercentage}%"></div></div>
                <div class="flex justify-between items-center mt-2 pl-9">
                    <span class="text-sm text-gray-400">dont Sucres</span><span class="text-sm font-semibold text-gray-300">${allTotals.sugars.toFixed(1)} g</span>
                </div>
            </div>
            <div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-3"><i class="fa-solid fa-cheese text-xl text-yellow-400 w-6 text-center"></i><span class="font-semibold">Lipides</span></div>
                    <span class="font-bold">${allTotals.fat.toFixed(1)} g</span>
                </div>
                <div class="w-full bg-black/20 rounded-full h-1.5 mt-2"><div class="bg-yellow-400 h-1.5 rounded-full" style="width: ${fatPercentage}%"></div></div>
                <div class="flex justify-between items-center mt-2 pl-9">
                    <span class="text-sm text-gray-400">dont Graisses saturées</span><span class="text-sm font-semibold text-gray-300">${allTotals.saturated_fat.toFixed(1)} g</span>
                </div>
            </div>
             <div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-3"><i class="fa-solid fa-leaf text-xl text-green-400 w-6 text-center"></i><span class="font-semibold">Fibres</span></div>
                    <span class="font-bold">${allTotals.fiber.toFixed(1)} g</span>
                </div>
                <div class="w-full bg-black/20 rounded-full h-1.5 mt-2"><div class="bg-green-400 h-1.5 rounded-full" style="width: ${fiberPercentage}%"></div></div>
            </div>
        </div>

        <button class="close-modal w-full mt-8 btn-primary">Fermer</button>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        const disclaimerBtn = modalWrapper.querySelector('#open-nutrition-disclaimer');
        if (disclaimerBtn) {
            disclaimerBtn.addEventListener('click', () => {
                openNutritionDisclaimerModal(incompleteIngredientsForDisclaimer);
            });
        }
    });
}

function openNutritionDisclaimerModal(invalidIngredients) {
    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <header class="flex justify-center items-center gap-3 mb-4">
            <i class="fa-solid fa-triangle-exclamation text-3xl text-yellow-400"></i>
            <h2 class="text-xl font-bold">Avertissement</h2>
        </header>
        <p class="text-gray-300 text-sm leading-relaxed">
            Les totaux nutritionnels de ce repas sont des <strong>estimations</strong>.
            Certains ingrédients ont des données incomplètes, ce qui peut fausser le résultat final.
        </p>
        <div class="bg-black/20 p-3 rounded-lg mt-4 text-left max-h-40 overflow-y-auto scrollbar-hide">
            ${invalidIngredients.map(ing => `
                <div class="mb-2">
                    <p class="font-bold text-white">${ing.name}</p>
                    <p class="text-xs text-yellow-300">Données manquantes : ${ing.missing}</p>
                </div>
            `).join('')}
        </div>
        <button class="close-modal w-full mt-6 btn-primary">J'ai compris</button>
    </div>`;
    showModal(modalContent);
}

function openFitScoreInfoModal() {
    const modalContent = `
    <div class="glass-card p-6 rounded-3xl w-full max-w-sm text-center">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <div class="flex-1 text-center">
                <i class="fa-solid fa-shield-halved text-4xl" style="color: var(--theme-primary);"></i>
            </div>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
        </header>
        <h2 class="text-xl font-bold mb-2">Qu'est-ce que le FitScore ?</h2>
        <p class="text-gray-300 mb-4 text-sm">
            C'est un score de <strong>0 à 100</strong> qui évalue la qualité nutritionnelle de votre repas selon plusieurs critères clés.
        </p>
        <div class="space-y-2 text-left text-sm">
            <p><strong class="text-green-400">Augmentent le score :</strong> Un bon Nutri-Score, un ratio élevé de protéines, la présence de fibres et la variété des ingrédients.</p>
            <p><strong class="text-red-400">Diminuent le score :</strong> Une quantité excessive de sucres ou de graisses saturées par rapport aux calories totales.</p>
            <p class="text-gray-500 italic mt-4">Note : Le FitScore est une estimation et ne prend pas en compte les additifs, allergènes ou micronutriments spécifiques.</p>
        </div>
    </div>`;
    showModal(modalContent);
}

        async function openItemSelectorModal(type, slotIndex = null) {
    const profileToEdit = state.tempUserProfile || state.userProfile;
    let items, inventory, equippedId;

    switch(type) {
        case 'border':
            items = BORDERS_DATABASE;
            inventory = profileToEdit.inventory.borders;
            equippedId = profileToEdit.equipped.border;
            break;
        case 'title':
            items = TITLES_DATABASE;
            inventory = profileToEdit.inventory.titles;
            equippedId = profileToEdit.equipped.title;
            break;
        case 'collectible':
            items = COLLECTIBLES_DATABASE;
            inventory = profileToEdit.inventory.collectibles;
            equippedId = profileToEdit.equipped.showcase[slotIndex];
            break;
    }

    const ownedItems = inventory.map(id => items.find(i => i.id === id)).filter(Boolean);
    
    const renderItemList = () => {
        const sortedItems = [...ownedItems].sort((a, b) => {
            const rarityA = RARITY_ORDER[a.rarity] || 0;
            const rarityB = RARITY_ORDER[b.rarity] || 0;
            const order = state.itemSelectorSortOrder === 'rarity_asc' ? 1 : -1;
            const rarityComparison = rarityA - rarityB;
            return (rarityComparison * order) || a.name.localeCompare(b.name);
        });

        return sortedItems.map(item => {
            const isSelected = equippedId === item.id;
            let itemHtml = '';

            if (type === 'title') {
                // --- LOGIQUE CORRIGÉE POUR SÉPARER LE STYLE DE L'ICÔNE ET DU TEXTE ---
                let titleClass = ''; // Pour le texte du titre
                let iconClass = '';  // Pour l'icône (fa-tag)

                // 1. Déterminer la classe de l'icône en fonction de la rareté
                if (item.rarity === 'Divin') {
                    iconClass = 'animated-icon-divin';
                } else if (item.rarity === 'Créateur') {
                    iconClass = 'animated-icon-createur';
                } else {
                    iconClass = `rarity-${normalizeString(item.rarity)}-text`; // Fallback pour les autres
                }

                // 2. Déterminer la classe du texte (inchangé, gère les titres secrets)
                if (item.source === 'secret') {
                    if (item.id === 't-gymbro-originel') titleClass = 'title-gymbro-originel';
                    else if (item.id === 't-pompier-muscle' || item.id === 't-the-bench-monster') titleClass = 'title-pompier-muscle';
                    else if (item.id === 't-createur-supreme') titleClass = 'title-createur-supreme';
                    else titleClass = `rarity-${normalizeString(item.rarity)}-text`;
                } else {
                    titleClass = `rarity-${normalizeString(item.rarity)}-text`;
                }
                // --- FIN DE LA LOGIQUE CORRIGÉE ---
                
                itemHtml = `<div class="flex items-center gap-4">
                                <div class="w-8 flex-shrink-0 flex justify-center">
                                    <i class="fa-solid fa-tag text-2xl ${iconClass}"></i>
                                </div>
                                <p class="font-bold truncate ${titleClass}">${item.name}</p>
                            </div>`;

            } else if (type === 'border') {
                itemHtml = `<div class="flex items-center gap-4">
                                <div class="w-10 h-10 rounded-full flex-shrink-0 flex items-center justify-center relative" style="${item.style}">
                                    <div class="w-full h-full rounded-full flex items-center justify-center" style="background-color: rgb(29, 31, 43);">
                                        <i class="fa-solid fa-user text-xl text-gray-500"></i>
                                    </div>
                                </div>
                                <p class="font-bold truncate ${'rarity-' + normalizeString(item.rarity) + '-text'}">${item.name}</p>
                            </div>`;
            } else { // Collectible
                itemHtml = `<div class="flex items-center gap-4">
                                <div class="w-8 flex-shrink-0 flex justify-center">
                                    <i class="fa-solid ${item.icon} text-3xl ${item.color}"></i>
                                </div>
                                <p class="font-bold truncate ${'rarity-' + normalizeString(item.rarity) + '-text'}">${item.name}</p>
                            </div>`;
            }
            return `<button class="item-select-btn w-full glass-card p-4 rounded-lg transition-colors hover:bg-white/20 text-left ${isSelected ? 'border-2' : ''}" data-item-id="${item.id}" ${isSelected ? 'style="border-color: var(--theme-primary);"' : ''}>
    ${itemHtml}
</button>`;
        }).join('');
    };
    
    const isSlotEmpty = type === 'collectible' && equippedId === null;

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto max-h-[70vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Choisir un objet</h2>
            <button id="toggle-item-sort-btn" class="glass-card rounded-full w-10 h-10 flex items-center justify-center text-gray-300 hover:text-white" title="Inverser l'ordre de tri">
                <i class="fa-solid fa-arrows-up-down"></i>
            </button>
        </header>
        <div id="item-selector-list-container" class="flex-grow overflow-y-auto pr-2 scrollbar-hide">
            <div class="space-y-3">
                ${type === 'collectible' ? `<button class="item-select-btn w-full glass-card p-4 rounded-lg text-gray-400 text-left flex items-center gap-4 ${isSlotEmpty ? 'border-2' : ''}" data-item-id="null" ${isSlotEmpty ? 'style="border-color: var(--theme-primary);"' : ''}><i class="fa-solid fa-ban text-2xl w-8 text-center"></i><span class="font-bold">Emplacement vide</span></button>` : ''}
                ${renderItemList()}
            </div>
        </div>
        <button class="close-modal w-full mt-6 btn-primary">Fermer</button>
    </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.addEventListener('click', async e => {
            const selectBtn = e.target.closest('.item-select-btn');
            if (selectBtn) {
                const itemId = selectBtn.dataset.itemId === 'null' ? null : selectBtn.dataset.itemId;
                switch(type) {
                    case 'border': profileToEdit.equipped.border = itemId; break;
                    case 'title': profileToEdit.equipped.title = itemId; break;
                    case 'collectible': profileToEdit.equipped.showcase[slotIndex] = itemId; break;
                }
                await saveState();
                closeModal();
                render();
            }
        });
        modalWrapper.querySelector('#toggle-item-sort-btn').onclick = () => {
            state.itemSelectorSortOrder = state.itemSelectorSortOrder === 'rarity_desc' ? 'rarity_asc' : 'rarity_desc';
            const listContent = modalWrapper.querySelector('#item-selector-list-container .space-y-3');
            if(listContent) {
                const emptySlotButtonHtml = type === 'collectible' ? `<button class="item-select-btn w-full glass-card p-4 rounded-lg text-gray-400 text-left flex items-center gap-4 ${equippedId === null ? 'border-2 border-violet-400' : ''}" data-item-id="null"><i class="fa-solid fa-ban text-2xl w-8 text-center"></i><span class="font-bold">Emplacement vide</span></button>` : '';
                listContent.innerHTML = emptySlotButtonHtml + renderItemList();
            }
        };
    });
}

function openExerciseEditorModal(groupId, exerciseIndex) {
    if (!state.editingWorkout) return;
    state.editingExerciseMode = state.editingExerciseMode || 'simple';

    const modalContent = `
    <div id="exercise-editor-modal-content" class="glass-card w-full max-w-lg p-6 rounded-t-3xl border-none h-[90vh] flex flex-col">
        </div>`;

    showModal(modalContent, (modalWrapper) => {
        // CORRECTION : On trouve l'élément de contenu DANS le wrapper de la modale
        const contentDiv = modalWrapper.querySelector('#exercise-editor-modal-content');
        // Et on passe CET élément spécifique à la fonction de rendu.
        renderExerciseEditorContent(contentDiv, groupId, exerciseIndex);
    });
}

/**
 * Gère le rendu interne de la modale d'édition d'exercice (simple vs avancé).
 */
function renderExerciseEditorContent(contentDiv, groupId, exerciseIndex) {
    if (!contentDiv) return;

    const workout = state.editingWorkout;
    const group = workout.groups.find(g => g.id === groupId);
    const exercise = group.exercises[exerciseIndex];
    const exerciseInfo = getExerciseById(exercise.exerciseId);
    const isSimpleMode = state.editingExerciseMode === 'simple';

    // L'en-tête est maintenant statique
    const headerHtml = `
    <header class="flex-shrink-0 mb-4">
        <h2 class="text-2xl font-bold">${exerciseInfo.name}</h2>
        <div class="flex items-center justify-between mt-2">
            <p class="text-sm text-gray-400">Configurez les séries pour cet exercice.</p>
            <div class="flex items-center gap-3">
                <span class="text-sm font-semibold ${isSimpleMode ? 'text-white' : 'text-gray-500'}">Simple</span>
                <label class="toggle-switch-v2">
                    <input type="checkbox" id="mode-toggle" ${!isSimpleMode ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
                <span class="text-sm font-semibold ${!isSimpleMode ? 'text-white' : 'text-gray-500'}">Avancé</span>
            </div>
        </div>
    </header>`;

    // Le contenu principal de la modale
    const setsListHtml = renderSetListForEditor(exercise, isSimpleMode ? 'simple' : 'advanced');
    const contentHtml = isSimpleMode 
        ? renderSimpleEditorView_v3(exercise)  // On garde cette structure pour les styles et le bouton "Ajouter"
        : renderAdvancedEditorView_v3(exercise);

    const footerHtml = `
    <div class="flex-shrink-0 pt-4 border-t border-white/10 mt-auto">
        <button class="close-modal w-full btn-primary">Terminé</button>
    </div>`;

    // On assemble le tout
    contentDiv.innerHTML = headerHtml + contentHtml + footerHtml;
    
    // On ré-attache les écouteurs d'événements
    const clickHandler = (e) => handleExerciseEditorModalEvents(e, groupId, exerciseIndex);
    const inputHandler = (e) => handleExerciseEditorModalEvents(e, groupId, exerciseIndex);
    
    if (contentDiv._clickHandler) contentDiv.removeEventListener('click', contentDiv._clickHandler);
    if (contentDiv._inputHandler) contentDiv.removeEventListener('input', contentDiv._inputHandler);
    
    contentDiv.addEventListener('click', clickHandler);
    contentDiv.addEventListener('input', inputHandler);

    contentDiv._clickHandler = clickHandler;
    contentDiv._inputHandler = inputHandler;
}

function renderSimpleEditorView_v3(exercise) {
    const setsHtml = (exercise.sets || []).map((set, index) => `
    <li class="set-row flex gap-4" data-set-index="${index}">
        <div class="timeline flex flex-col items-center">
            <div class="timeline-dot w-8 h-8 rounded-full border-2 border-gray-600 flex items-center justify-center font-bold text-gray-400">${index + 1}</div>
            <div class="timeline-connector flex-grow w-px bg-gray-700"></div>
        </div>

        <div class="set-content flex-grow pb-8 pt-1">
            <div class="grid grid-cols-2 gap-4">
                <div class="text-center">
                    <label class="text-sm font-semibold text-gray-400">Reps</label>
                    <input type="text" data-field="reps" value="${set.reps || ''}" placeholder="ex: 8-12" class="input-glass-v2-static mt-1">
                </div>
                <div class="text-center">
                    <label class="text-sm font-semibold text-gray-400">Repos (s)</label>
                    <input type="number" data-field="rest" value="${set.rest || ''}" placeholder="ex: 90" class="input-glass-v2-static mt-1">
                </div>
            </div>
        </div>
        <button data-action="remove-set" class="remove-set-btn pt-1"><i class="fa-solid fa-xmark"></i></button>
    </li>
    `).join('');

    return `
    <style>
        /* Ces styles sont partagés avec le mode avancé pour la cohérence */
        .timeline-dot { transition: all 0.3s ease; }
        .set-row:hover .timeline-dot { border-color: var(--theme-primary); color: var(--theme-primary); box-shadow: 0 0 10px var(--theme-shadow); }
        .set-row:last-child .timeline-connector { display: none; }
        .input-glass-v2-static {
            height: 42px; display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.3); border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.1);
            flex-grow: 1; text-align: center; font-size: 1.125rem; font-weight: 700; color: white; padding: 0; width: 100%;
        }
        .remove-set-btn { flex-shrink: 0; width: 32px; height: 32px; color: #4B5563; transition: all 0.2s; }
        .set-row:hover .remove-set-btn { color: #EF4444; }
    </style>
    <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-4">
        <ul id="sets-timeline" class="mt-2">${setsHtml}</ul>
        <button data-action="add-set" class="w-full text-center p-3 mt-2 rounded-lg text-violet-400 font-semibold hover:bg-white/5 transition-colors">+ Ajouter une série</button>
    </div>
    `;
}

/**
 * Affiche l'interface pour le mode d'édition AVANCÉ.
 */
function renderAdvancedEditorView_v3(exercise) {
    exercise.tempo = exercise.tempo || {};

    const setsHtml = (exercise.sets || []).map((set, index) => {
        const isDropset = set.type === 'dropset';

        const dropsHtml = (set.drops || []).map((drop, dropIndex) => {
            const isRepsMax = drop.repsType === 'max';
            return `
            <li class="dropset-item flex items-center gap-4 pl-4" data-drop-index="${dropIndex}">
                <div class="dropset-timeline flex flex-col items-center h-full">
                    <div class="w-px h-4 bg-violet-700"></div>
                    <div class="w-2 h-2 rounded-full bg-violet-500"></div>
                    <div class="w-px flex-grow bg-violet-700"></div>
                </div>
                <div class="flex-grow flex items-center gap-3">
                    <span class="text-sm font-semibold text-gray-400 w-14">Drop ${dropIndex + 1}</span>
                    <div class="p-1 bg-black/30 rounded-full flex text-xs flex-grow max-w-[120px]">
                        <button data-action="toggle-drop-reps-type" data-value="max" class="flex-1 py-1 rounded-full ${isRepsMax ? 'bg-gray-600 text-white font-bold' : ''}">Max</button>
                        <button data-action="toggle-drop-reps-type" data-value="fixed" class="flex-1 py-1 rounded-full ${!isRepsMax ? 'bg-gray-600 text-white font-bold' : ''}">Fixe</button>
                    </div>
                    <input type="text" data-field="drop-reps"
                           class="input-glass !py-2 text-center w-24 ${isRepsMax ? 'font-bold text-violet-300' : ''}"
                           placeholder="Reps"
                           ${isRepsMax ? `value="Max" readonly` : `value="${drop.reps || ''}"`}>
                </div>
                <button data-action="remove-drop" class="text-gray-600 hover:text-red-500 w-8 h-8 rounded-full"><i class="fa-solid fa-xmark"></i></button>
            </li>
            `;
        }).join('');

        return `
        <li class="set-row flex gap-4" data-set-index="${index}">
            <div class="timeline flex flex-col items-center">
                <div class="timeline-dot w-8 h-8 rounded-full border-2 border-gray-600 flex items-center justify-center font-bold text-gray-400">${index + 1}</div>
                <div class="timeline-connector flex-grow w-px bg-gray-700"></div>
            </div>

            <div class="set-content flex-grow pb-8">
                <div class="set-inputs grid grid-cols-3 gap-3">
                    <div class="text-center">
                        <label class="text-sm font-semibold text-gray-400">Reps</label>
                        <input type="text" data-field="reps" value="${set.reps || '10'}" class="input-glass-v2-static mt-1">
                    </div>
                    <div class="text-center">
                        <label class="text-sm font-semibold text-gray-400">RPE (op)</label>
                         <input type="text" data-field="rpe" value="${set.rpe || ''}" placeholder="-" class="input-glass-v2-static mt-1">
                    </div>
                    <div class="text-center">
                        <label class="text-sm font-semibold text-gray-400">Repos (s)</label>
                         <input type="number" data-field="rest" value="${set.rest || '90'}" class="input-glass-v2-static mt-1">
                    </div>
                </div>
                
                <div class="technique-container mt-4">
                ${isDropset ? `
                    <div class="dropset-container">
                        <div class="flex justify-between items-center"><h4 class="font-bold text-violet-400">Technique: Dropset</h4><button data-action="remove-technique-dropset" class="text-xs text-gray-500 hover:text-red-400">Retirer</button></div>
                        <ul class="mt-2">${dropsHtml}</ul>
                        <button data-action="add-drop" class="text-violet-400 text-sm font-semibold mt-2 hover:text-violet-300 w-full">+ Ajouter un palier</button>
                    </div>` : `
                    <button data-action="add-technique-dropset" class="add-technique-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> Ajouter une technique (Dropset)</button>
                `}
                </div>
            </div>
            <button data-action="remove-set" class="remove-set-btn"><i class="fa-solid fa-xmark"></i></button>
        </li>
        `;
    }).join('');

    return `
    <style>
        .timeline-dot { transition: all 0.3s ease; }
        .set-row:hover .timeline-dot { border-color: var(--theme-primary); color: var(--theme-primary); box-shadow: 0 0 10px var(--theme-shadow); }
        .set-row:last-child .timeline-connector { display: none; }
        .input-glass-v2-static {
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border-radius: 0.75rem;
            border: 1px solid rgba(255,255,255,0.1);
            flex-grow: 1;
            text-align: center;
            font-size: 1.125rem;
            font-weight: 700;
            color: white;
            padding: 0;
            width: 100%; /* S'assure qu'il remplit l'espace */
        }
        .remove-set-btn { flex-shrink: 0; width: 32px; height: 32px; color: #4B5563; transition: all 0.2s; }
        .set-row:hover .remove-set-btn { color: #EF4444; }
        .add-technique-btn { width: 100%; text-align: center; padding: 10px; border: 2px dashed #4B5563; border-radius: 12px; color: #9CA3AF; font-weight: 600; font-size: 0.875rem; transition: all 0.2s; }
        .add-technique-btn:hover { border-color: var(--theme-primary); color: var(--theme-primary); background: var(--theme-shadow); }
        /* LA LIGNE CI-DESSOUS A ÉTÉ SUPPRIMÉE POUR CORRIGER LE FLICKER */
        /* .dropset-container { animation: fadeIn 0.3s ease; } */
        .dropset-item:last-child .dropset-timeline .flex-grow { display: none; }
    </style>
    
    <div class="flex-grow overflow-y-auto pr-2 scrollbar-hide space-y-4">
        <div class="glass-card p-3 rounded-xl">
            <label class="font-bold">Tempo de l'exercice</label>
            <p class="text-xs text-gray-400 mb-2">S'applique à toutes les séries.</p>
            <div class="flex items-center justify-center gap-1 bg-black/30 p-1 rounded-lg">
                <input type="number" data-field="global-tempo" data-tempo-part="ecc" value="${exercise.tempo.ecc || ''}" class="w-16 bg-transparent text-center focus:outline-none text-2xl" placeholder="E">
                <span class="text-gray-500">-</span>
                <input type="number" data-field="global-tempo" data-tempo-part="pause1" value="${exercise.tempo.pause1 || ''}" class="w-16 bg-transparent text-center focus:outline-none text-2xl" placeholder="P">
                <span class="text-gray-500">-</span>
                <input type="number" data-field="global-tempo" data-tempo-part="con" value="${exercise.tempo.con || ''}" class="w-16 bg-transparent text-center focus:outline-none text-2xl" placeholder="C">
                <span class="text-gray-500">-</span>
                <input type="number" data-field="global-tempo" data-tempo-part="pause2" value="${exercise.tempo.pause2 || ''}" class="w-16 bg-transparent text-center focus:outline-none text-2xl" placeholder="P">
            </div>
        </div>
        
        <ul id="sets-timeline" class="mt-6">${setsHtml}</ul>
        
        <button data-action="add-set" class="w-full text-center p-3 mt-2 rounded-lg text-violet-400 font-semibold hover:bg-white/5 transition-colors">+ Ajouter une série</button>
    </div>
    `;
}

function renderSetListForEditor(exercise, mode) {
    if (mode === 'simple') {
        // Logique copiée de renderSimpleEditorView_v3
        return (exercise.sets || []).map((set, index) => `
        <li class="set-row flex gap-4" data-set-index="${index}">
            <div class="timeline flex flex-col items-center">
                <div class="timeline-dot w-8 h-8 rounded-full border-2 border-gray-600 flex items-center justify-center font-bold text-gray-400">${index + 1}</div>
                <div class="timeline-connector flex-grow w-px bg-gray-700"></div>
            </div>
            <div class="set-content flex-grow pb-8 pt-1">
                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center">
                        <label class="text-sm font-semibold text-gray-400">Reps</label>
                        <input type="text" data-field="reps" value="${set.reps || ''}" placeholder="ex: 8-12" class="input-glass-v2-static mt-1">
                    </div>
                    <div class="text-center">
                        <label class="text-sm font-semibold text-gray-400">Repos (s)</label>
                        <input type="number" data-field="rest" value="${set.rest || ''}" placeholder="ex: 90" class="input-glass-v2-static mt-1">
                    </div>
                </div>
            </div>
            <button data-action="remove-set" class="remove-set-btn pt-1"><i class="fa-solid fa-xmark"></i></button>
        </li>
        `).join('');
    } else {
        // Logique copiée de renderAdvancedEditorView_v3
        return (exercise.sets || []).map((set, index) => {
            const isDropset = set.type === 'dropset';
            const dropsHtml = (set.drops || []).map((drop, dropIndex) => {
                const isRepsMax = drop.repsType === 'max';
                return `
                <li class="dropset-item flex items-center gap-4 pl-4" data-drop-index="${dropIndex}">
                    <div class="dropset-timeline flex flex-col items-center h-full"><div class="w-px h-4 bg-violet-700"></div><div class="w-2 h-2 rounded-full bg-violet-500"></div><div class="w-px flex-grow bg-violet-700"></div></div>
                    <div class="flex-grow flex items-center gap-3">
                        <span class="text-sm font-semibold text-gray-400 w-14">Drop ${dropIndex + 1}</span>
                        <div class="p-1 bg-black/30 rounded-full flex text-xs flex-grow max-w-[120px]"><button data-action="toggle-drop-reps-type" data-value="max" class="flex-1 py-1 rounded-full ${isRepsMax ? 'bg-gray-600 text-white font-bold' : ''}">Max</button><button data-action="toggle-drop-reps-type" data-value="fixed" class="flex-1 py-1 rounded-full ${!isRepsMax ? 'bg-gray-600 text-white font-bold' : ''}">Fixe</button></div>
                        <input type="text" data-field="drop-reps" class="input-glass !py-2 text-center w-24 ${isRepsMax ? 'font-bold text-violet-300' : ''}" placeholder="Reps" ${isRepsMax ? `value="Max" readonly` : `value="${drop.reps || ''}"`}>
                    </div>
                    <button data-action="remove-drop" class="text-gray-600 hover:text-red-500 w-8 h-8 rounded-full"><i class="fa-solid fa-xmark"></i></button>
                </li>`;
            }).join('');

            return `
            <li class="set-row flex gap-4" data-set-index="${index}">
                <div class="timeline flex flex-col items-center"><div class="timeline-dot w-8 h-8 rounded-full border-2 border-gray-600 flex items-center justify-center font-bold text-gray-400">${index + 1}</div><div class="timeline-connector flex-grow w-px bg-gray-700"></div></div>
                <div class="set-content flex-grow pb-8">
                    <div class="set-inputs grid grid-cols-3 gap-3">
                        <div class="text-center"><label class="text-sm font-semibold text-gray-400">Reps</label><input type="text" data-field="reps" value="${set.reps || '10'}" class="input-glass-v2-static mt-1"></div>
                        <div class="text-center"><label class="text-sm font-semibold text-gray-400">RPE (op)</label><input type="text" data-field="rpe" value="${set.rpe || ''}" placeholder="-" class="input-glass-v2-static mt-1"></div>
                        <div class="text-center"><label class="text-sm font-semibold text-gray-400">Repos (s)</label><input type="number" data-field="rest" value="${set.rest || '90'}" class="input-glass-v2-static mt-1"></div>
                    </div>
                    <div class="technique-container mt-4">
                    ${isDropset ? `<div class="dropset-container"><div class="flex justify-between items-center"><h4 class="font-bold text-violet-400">Technique: Dropset</h4><button data-action="remove-technique-dropset" class="text-xs text-gray-500 hover:text-red-400">Retirer</button></div><ul class="mt-2">${dropsHtml}</ul><button data-action="add-drop" class="text-violet-400 text-sm font-semibold mt-2 hover:text-violet-300 w-full">+ Ajouter un palier</button></div>` : `<button data-action="add-technique-dropset" class="add-technique-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> Ajouter une technique (Dropset)</button>`}
                    </div>
                </div>
                <button data-action="remove-set" class="remove-set-btn"><i class="fa-solid fa-xmark"></i></button>
            </li>`;
        }).join('');
    }
}

        function openGlobalRankDetailsModal() {
    const { globalRank, globalRankColor, totalSr } = calculateGlobalRank(state.userProfile);
    
    let muscleGroupsHtml = Object.keys(MUSCLE_GROUPS).map(key => {
        const { globalRank: groupRank, globalRankColor: groupColor } = calculateMuscleGroupRank(key);
        return `
            <div class="flex items-center justify-between py-3 border-b border-white/10">
                <span class="font-semibold">${MUSCLE_GROUPS[key]}</span>
                <span class="font-bold" style="color: ${groupColor.main};">${groupRank}</span>
            </div>
        `;
    }).join('');

    const modalContent = `
        <div class="rank-modal-content p-8 rounded-3xl w-full max-w-sm text-center flex flex-col items-center">
            <h3 class="font-semibold text-lg text-gray-300 mb-2 z-10">Rank Global</h3>
            <div class="relative w-32 h-32 mb-4 rank-badge-container">
                ${getRankBadgeSVG(globalRank)}
            </div>
            <div class="relative z-10 w-full">
                <h2 class="text-4xl font-extrabold mb-6">
    ${globalRank} ${totalSr > 0 ? `<span class="text-yellow-300 text-3xl">+${totalSr} SR</span>` : ''}
</h2>
                <div class="w-full bg-black/20 p-4 rounded-xl text-left space-y-2">
                    ${muscleGroupsHtml}
                </div>
                <button class="close-modal w-full mt-8 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold">Fermer</button>
            </div>
        </div>
    `;
    showModal(modalContent);
}

function openSessionHistoryModal() {
            const historyHtml = state.sessionHistory.slice().reverse().map(session => {
                const workout = state.workouts.find(w => w.id === session.workoutId) || {name: 'Séance supprimée'};
                const date = new Date(session.date).toLocaleDateString('fr-FR', {weekday: 'long', day: 'numeric', month: 'long'});
                return `<div class="p-3 glass-card rounded-lg">
                    <p class="font-bold">${workout.name}</p>
                    <p class="text-sm text-gray-400">${date} - ${formatDuration(session.duration)}</p>
                </div>`;
            }).join('');

            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[85vh] flex flex-col">
                <header class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h2 class="text-2xl font-bold">Historique des Séances</h2>
                    <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
                </header>
                <div class="flex-grow overflow-y-auto space-y-3 pr-2 scrollbar-hide">
                    ${historyHtml || '<p class="text-gray-500 text-center mt-8">Aucune séance terminée pour le moment.</p>'}
                </div>
            </div>`;
            showModal(modalContent);
        }

        function openSessionRecapModal() {
            const modalContent = `
                <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col">
                    <h2 class="text-2xl font-bold mb-4">Récapitulatif de la séance</h2>
                    <div class="flex-grow overflow-y-auto space-y-3 pr-2 scrollbar-hide">
                        ${state.activeWorkoutSession.workout.exercises.map((exo, index) => {
                             const exercise = getExerciseById(exo.exerciseId);
                             const perf = state.activeWorkoutSession.performance[index];
                             const setsDone = perf.sets.length;
                             const isCompleted = setsDone >= exo.sets;
                             let setsHtml = perf.sets.map((set, setIndex) => `<div class="text-sm text-gray-400">Série ${setIndex + 1}: ${set.weight} kg x ${set.reps} reps</div>`).join('');
                             if (setsDone === 0) setsHtml = `<div class="text-sm text-gray-600 italic">Pas encore commencé</div>`;
                            return `<div class="p-4 rounded-lg ${isCompleted ? 'bg-green-500/10' : 'bg-black/20'}">
                                <div class="flex justify-between items-center">
                                    <p class="font-bold">${exercise.name}</p>
                                    <p class="text-sm font-semibold ${isCompleted ? 'text-green-400' : 'text-gray-400'}">${setsDone}/${exo.sets} séries</p>
                                </div>
                                <div class="mt-2 pl-4 border-l-2 border-white/10">${setsHtml}</div>
                            </div>`;
                        }).join('')}
                    </div>
                    <button class="close-modal w-full mt-6 bg-white/10 hover:bg-white/20 p-3 rounded-lg font-bold">Retour</button>
                </div>
            `;
            showModal(modalContent);
        }

        function openAddExerciseModal() {
            const modalContent = `<div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[80vh] flex flex-col"><header class="flex justify-between items-center mb-4 flex-shrink-0"><h2 class="text-2xl font-bold">Ajouter un exercice</h2><button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button></header><div class="relative mb-4 flex-shrink-0"><i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i><input id="search-exercise-input" type="text" placeholder="Rechercher..." class="input-glass pl-12 w-full"></div><div id="exercise-selection-list" class="flex-grow overflow-y-auto space-y-2 pr-2"></div></div>`;
            
            showModal(modalContent, (modalWrapper) => {
                const searchInput = modalWrapper.querySelector('#search-exercise-input');
                const selectionList = modalWrapper.querySelector('#exercise-selection-list');

                const renderList = (filter = '') => {
                    const normalizedFilter = filter.toLowerCase();
                    const filteredExercises = EXERCISE_DATABASE.filter(ex => ex.name.toLowerCase().includes(normalizedFilter));
                    selectionList.innerHTML = filteredExercises.map(ex => `<button class="select-exercise-btn w-full text-left glass-card hover:bg-white/20 p-3 rounded-lg" data-exercise-id="${ex.id}">${ex.name}</button>`).join('');
                };

                selectionList.onclick = (e) => {
                    const btn = e.target.closest('.select-exercise-btn');
                    if (btn) {
                        const newExercise = { id: generateId(), exerciseId: btn.dataset.exerciseId, sets: 3, reps: 10, rest: 60 };
                        state.editingWorkout.exercises.push(newExercise);
                        closeModal();
                        render();
                    }
                };
                
                searchInput.oninput = (e) => renderList(e.target.value);
                renderList();
            });
        }

        async function openEditExerciseModal(instanceId) {
    const exercise = state.editingWorkout.exercises.find(ex => ex.id === instanceId);
    if (!exercise) return;

    // Le champ de saisie a été modifié pour les limitations et la validation
    const modalContent = `
        <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
            <h2 class="text-2xl font-bold mb-4">${getExerciseById(exercise.exerciseId).name}</h2>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="text-sm text-gray-400">Séries</label>
                    <input id="sets-input" type="number" class="input-glass" value="${exercise.sets}"
                           oninput="this.value = Math.min(999, Math.max(1, parseInt(this.value) || 1));">
                </div>
                <div>
                    <label class="text-sm text-gray-400">Répétitions</label>
                    <input id="reps-input" type="number" class="input-glass" value="${exercise.reps}"
                           oninput="this.value = Math.min(999, Math.max(1, parseInt(this.value) || 1));">
                </div>
                <div>
                    <label class="text-sm text-gray-400">Repos (s)</label>
                    <input id="rest-input" type="number" class="input-glass" value="${exercise.rest}"
                           oninput="this.value = Math.min(999, Math.max(0, parseInt(this.value) || 0));">
                </div>
            </div>
            <div class="flex gap-4 mt-auto pt-4">
                <button id="delete-exercise-btn" class="w-full glass-card p-3 rounded-lg text-red-400 font-bold">Supprimer</button>
                <button id="save-exercise-btn" class="w-full btn-primary">OK</button>
            </div>
        </div>`;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#save-exercise-btn').onclick = async () => {
            const sets = parseInt(modalWrapper.querySelector('#sets-input').value) || 1;
            const reps = parseInt(modalWrapper.querySelector('#reps-input').value) || 1;
            const rest = parseInt(modalWrapper.querySelector('#rest-input').value) || 0;

            // Applique les limites avant de sauvegarder
            exercise.sets = Math.min(999, Math.max(1, sets));
            exercise.reps = Math.min(999, Math.max(1, reps));
            exercise.rest = Math.min(999, Math.max(0, rest));
            await saveState();
            closeModal();
            render();
        };
        modalWrapper.querySelector('#delete-exercise-btn').onclick = async () => {
            state.editingWorkout.exercises = state.editingWorkout.exercises.filter(ex => ex.id !== instanceId);
            await saveState();
            closeModal();
            render();
        };
    });
}

        async function openPlanModal(itemId, date, type) {
            const item = type === 'workout' ? state.workouts.find(i => i.id === itemId) : state.meals.find(i => i.id === itemId);
            if (!item) return;

            const [year, month, day] = date.split('-');
            const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm"><h2 class="text-xl font-bold mb-2">Planifier: ${item.name}</h2><p class="text-gray-400 mb-6">${new Date(year, parseInt(month) - 1, day).toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p><div class="space-y-4"><div><label class="text-sm text-gray-400">Heure</label><input id="plan-time-input" type="time" class="input-glass" value="12:00"></div><div><label class="text-sm text-gray-400">Note (optionnel)</label><input id="plan-note-input" type="text" class="input-glass" placeholder="Ex: Focus sur la technique"></div></div><div class="flex gap-4 mt-8"><button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button><button id="confirm-plan" class="w-full btn-primary">Planifier</button></div></div>`;
            
            showModal(modalContent, (modalWrapper) => {
                modalWrapper.querySelector('#confirm-plan').onclick = async () => {
                    const newEvent = { id: generateId(), date, refId: item.id, title: item.name, time: modalWrapper.querySelector('#plan-time-input').value, note: modalWrapper.querySelector('#plan-note-input').value, type, completed: false, validated: false };
                    state.calendarEvents.push(newEvent);
                    await saveState();
                    closeModal();
                    render();
                };
            });
        }

        async function openDayDetailsModal(date, events) {
    const [year, month, day] = date.split('-');
    const formattedDate = new Date(year, parseInt(month) - 1, day).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
    
    const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm"><h2 class="text-xl font-bold mb-6">${formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1)}</h2><div id="day-details-content" class="space-y-4 max-h-64 overflow-y-auto">${events.sort((a,b) => a.time.localeCompare(b.time)).map(event => `<div class="flex items-center justify-between glass-card p-3 rounded-lg"><div><p class="font-bold ${event.completed || event.validated ? 'text-gray-400 line-through' : ''}">${event.title} <span class="text-sm text-gray-400 font-normal">à ${event.time}</span></p>${event.note ? `<p class="text-sm text-gray-300 mt-1 italic">"${event.note}"</p>` : ''}</div>${!event.isFromRecurrence ? `<button class="delete-event-btn text-red-400 hover:text-red-300 p-2 ml-2" data-event-id="${event.id}"><i class="fa-solid fa-trash-can"></i></button>` : ''}</div>`).join('')}</div><button class="close-modal w-full mt-6 glass-card p-3 rounded-lg font-bold">Fermer</button></div>`;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#day-details-content').onclick = async e => {
            const deleteBtn = e.target.closest('.delete-event-btn');
            if (deleteBtn) {
                state.calendarEvents = state.calendarEvents.filter(ev => ev.id !== deleteBtn.dataset.eventId);
                await saveState();
                closeModal();
                render();
            }
        };
    });
}

        function openDashboardHelpModal() {
            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
                <header class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h2 class="text-2xl font-bold">Aide du Tableau de Bord</h2>
                    <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
                </header>
                <div class="flex-grow overflow-y-auto space-y-4 pr-2 text-gray-300">
                    <div>
                        <h3 class="font-bold text-lg text-white mb-1">Analyse de Progression</h3>
                        <p class="text-sm">Ce graphique montre l'évolution de votre force pour un exercice donné. L'axe vertical représente votre 1-Rep Max (1RM) estimé en kg, et l'axe horizontal représente le temps. Une courbe ascendante est le signe d'une belle progression !</p>
                    </div>
                     <div>
                        <h3 class="font-bold text-lg text-white mb-1">1-Rep Max (1RM) Estimé</h3>
                        <p class="text-sm">Le 1RM est la charge maximale que vous pourriez théoriquement soulever en une seule répétition. Nous l'estimons à partir de votre meilleure performance enregistrée sur l'exercice sélectionné. C'est un excellent indicateur de votre force maximale.</p>
                    </div>
                     <div>
                        <h3 class="font-bold text-lg text-white mb-1">Vos Insights</h3>
                        <p class="text-sm">Cette section analyse vos habitudes. Le 'Jour fétiche' est le jour où vous vous entraînez le plus souvent, et le 'Focus sur' est le groupe musculaire que vous sollicitez le plus fréquemment. Ces données deviennent fiables après 3 séances enregistrées.</p>
                    </div>
                </div>
            </div>`;
            showModal(modalContent);
        }

        function openVolumeModal() {
            let currentPeriod = 'all';

            const renderContent = (period) => {
                const volumeData = getVolumeDetails(period);
                const totalVolume = volumeData.reduce((sum, [, vol]) => sum + vol, 0);
                const contentEl = document.getElementById('details-content');
                
                if (contentEl) {
                    contentEl.innerHTML = volumeData.length > 0 ? volumeData.map(([group, vol]) => {
                        const percentage = totalVolume > 0 ? (vol / totalVolume * 100).toFixed(1) : 0;
                        return `
                        <div class="mb-2">
                            <div class="flex justify-between items-center text-sm mb-1">
                                <span class="font-bold">${MUSCLE_GROUPS[group]}</span>
                                <span class="text-gray-400">${formatVolume(vol)}</span>
                            </div>
                            <div class="w-full bg-black/20 rounded-full h-2.5">
                                <div class="bg-violet-500 h-2.5 rounded-full" style="width: ${percentage}%"></div>
                            </div>
                        </div>`;
                    }).join('') : '<p class="text-gray-500 text-center">Aucune donnée pour cette période.</p>';
                }
                
                // Met à jour le bouton actif
                document.querySelectorAll('#period-filter button').forEach(btn => {
                    btn.classList.toggle('btn-primary', btn.dataset.period === period);
                    btn.classList.toggle('glass-card', btn.dataset.period !== period);
                });
            };

            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
                <header class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Volume par Groupe Musculaire</h2>
                    <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
                </header>
                <div id="period-filter" class="flex justify-between gap-2 mb-4 text-sm">
                    <button data-period="7d" class="flex-1 p-2 rounded-lg glass-card">7j</button>
                    <button data-period="30d" class="flex-1 p-2 rounded-lg glass-card">30j</button>
                    <button data-period="365d" class="flex-1 p-2 rounded-lg glass-card">1a</button>
                    <button data-period="all" class="flex-1 p-2 rounded-lg glass-card">Total</button>
                </div>
                <div id="details-content" class="space-y-3"></div>
            </div>`;
            
            showModal(modalContent, (modal) => {
                modal.querySelector('#period-filter').addEventListener('click', e => {
                    if (e.target.dataset.period) {
                        currentPeriod = e.target.dataset.period;
                        renderContent(currentPeriod);
                    }
                });
                renderContent(currentPeriod); // Affichage initial
            });
        }

        async function openGoalsModal() {
            const modalContent = `
            <div class="glass-card p-6 rounded-3xl w-full max-w-sm">
                <h2 class="text-xl font-bold mb-4">Modifier les Objectifs</h2>
                <div class="space-y-4">
                    <div>
                        <label for="goal-calories-modal" class="text-sm font-semibold text-gray-400">Calories (kcal)</label>
                        <input id="goal-calories-modal" type="number" class="input-glass mt-1" value="${state.userGoals.calories}">
                    </div>
                    <div>
                        <label for="goal-protein-modal" class="text-sm font-semibold text-gray-400">Protéines (g)</label>
                        <input id="goal-protein-modal" type="number" class="input-glass mt-1" value="${state.userGoals.protein}">
                    </div>
                </div>
                <div class="flex gap-4 mt-8">
                    <button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button>
                    <button id="save-goals-btn-modal" class="w-full btn-primary">Valider</button>
                </div>
            </div>`;

            showModal(modalContent, (modal) => {
                modal.querySelector('#save-goals-btn-modal').onclick = async () => {
                    state.userGoals.calories = parseInt(document.getElementById('goal-calories-modal').value) || 0;
                    state.userGoals.protein = parseInt(document.getElementById('goal-protein-modal').value) || 0;
                    await saveState();
                    showToast('Objectifs mis à jour !');
                    closeModal();
                    // On redessine la page d'accueil pour que les stats de calories/protéines se mettent à jour
                    if(state.activePage === 'Accueil') render(); 
                };
            });
        }

        function openTimeModal() {
            let currentPeriod = 'all';
            let currentUnit = 'time'; // 'time' ou 'percent'
            let timeChart = null;

            const renderChart = () => {
                if (timeChart) timeChart.destroy();
                const sessions = filterSessionsByPeriod(currentPeriod);
                const canvas = document.getElementById('time-day-chart');
                if (!canvas) return;

                const timeByDay = [0, 0, 0, 0, 0, 0, 0];
                sessions.forEach(session => {
                    let day = new Date(session.date).getDay() - 1;
                    if (day === -1) day = 6;
                    timeByDay[day] += session.duration;
                });

                const totalMs = timeByDay.reduce((sum, ms) => sum + ms, 0);
                const chartData = currentUnit === 'percent' ? timeByDay.map(ms => totalMs > 0 ? (ms / totalMs * 100).toFixed(1) : 0) : timeByDay;

                timeChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: { 
                        labels: ['L', 'M', 'M', 'J', 'V', 'S', 'D'], 
                        datasets: [{ 
                            data: chartData, 
                            backgroundColor: 'rgba(167, 139, 250, 0.6)',
                            borderColor: 'rgba(167, 139, 250, 1)',
                            borderWidth: 1,
                            borderRadius: 4
                        }] 
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => currentUnit === 'percent' ? `${ctx.raw}%` : formatDuration(ctx.raw)
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true, 
                                ticks: { 
                                    color: '#9CA3AF',
                                    callback: (value) => currentUnit === 'percent' ? `${value}%` : formatDuration(value).replace(/min|s/g, '')
                                }, 
                                grid: { color: 'rgba(255,255,255,0.05)' } 
                            },
                            x: { ticks: { color: '#9CA3AF' }, grid: { display: false } }
                        }
                    }
                });
            };

            const renderContent = () => {
                const timeData = getTimeDetails(currentPeriod);
                const contentEl = document.getElementById('details-content');
                if (contentEl) {
                    contentEl.innerHTML = `
                        <div class="grid grid-cols-3 gap-3 text-center">
                            <div class="glass-card p-3 rounded-xl"><p class="text-xs text-gray-400">Temps Total</p><p class="text-xl font-bold">${timeData.total}</p></div>
                            <div class="glass-card p-3 rounded-xl"><p class="text-xs text-gray-400">Durée Moyenne</p><p class="text-xl font-bold">${timeData.avg}</p></div>
                            <div class="glass-card p-3 rounded-xl"><p class="text-xs text-gray-400">Séance Max</p><p class="text-xl font-bold">${timeData.longest}</p></div>
                        </div>
                    `;
                }
                renderChart();
                document.querySelectorAll('#period-filter button').forEach(btn => btn.classList.toggle('btn-primary', btn.dataset.period === currentPeriod));
                document.querySelectorAll('#unit-toggle button').forEach(btn => btn.classList.toggle('btn-primary', btn.dataset.unit === currentUnit));
            };

            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
                <header class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Analyse du Temps</h2>
                    <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
                </header>
                <div id="period-filter" class="flex justify-between gap-2 mb-4 text-sm">
                    <button data-period="7d" class="flex-1 p-2 rounded-lg glass-card">7j</button>
                    <button data-period="30d" class="flex-1 p-2 rounded-lg glass-card">30j</button>
                    <button data-period="365d" class="flex-1 p-2 rounded-lg glass-card">1a</button>
                    <button data-period="all" class="flex-1 p-2 rounded-lg glass-card">Total</button>
                </div>
                <div id="details-content" class="mb-4"></div>
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-semibold">Répartition par jour</h3>
                    <div id="unit-toggle" class="flex text-xs border border-gray-700 rounded-full p-1">
                        <button data-unit="time" class="px-3 py-1 rounded-full">Temps</button>
                        <button data-unit="percent" class="px-3 py-1 rounded-full">Pourcent</button>
                    </div>
                </div>
                <div class="h-40"><canvas id="time-day-chart"></canvas></div>
            </div>`;

            showModal(modalContent, (modal) => {
                modal.addEventListener('click', e => {
                    const target = e.target.closest('button');
                    if (!target) return;

                    if (target.dataset.period) { 
                        currentPeriod = target.dataset.period; 
                        renderContent(); 
                    }
                    if (target.dataset.unit) { 
                        currentUnit = target.dataset.unit; 
                        renderContent(); 
                    }
                });
                renderContent();
            });
        }
        
        function openSessionsModal() {
            let currentPeriod = 'all';
            let currentUnit = 'count'; // 'count' ou 'percent'
            let dayChart = null;

            const renderChart = () => {
                if (dayChart) dayChart.destroy();
                const sessions = filterSessionsByPeriod(currentPeriod);
                const canvas = document.getElementById('sessions-day-chart');
                if (!canvas) return;

                const dayCounts = [0, 0, 0, 0, 0, 0, 0]; // Lundi -> Dimanche
                sessions.forEach(session => {
                    let day = new Date(session.date).getDay() - 1;
                    if (day === -1) day = 6;
                    dayCounts[day]++;
                });
                
                const total = dayCounts.reduce((sum, count) => sum + count, 0);
                const chartData = currentUnit === 'percent' ? dayCounts.map(c => total > 0 ? (c / total * 100).toFixed(1) : 0) : dayCounts;

                dayChart = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ['L', 'M', 'M', 'J', 'V', 'S', 'D'],
                        datasets: [{
                            data: chartData,
                            backgroundColor: 'rgba(167, 139, 250, 0.6)',
                            borderColor: 'rgba(167, 139, 250, 1)',
                            borderWidth: 1,
                            borderRadius: 4
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false }, 
                            tooltip: { callbacks: { label: (ctx) => `${ctx.raw}${currentUnit === 'percent' ? '%' : ''}` } } 
                        },
                        scales: { 
                            y: { beginAtZero: true, ticks: { color: '#9CA3AF', precision: 0 }, grid: { color: 'rgba(255,255,255,0.05)' } }, 
                            x: { ticks: { color: '#9CA3AF' }, grid: { display: false } } 
                        }
                    }
                });
            };

            const renderContent = () => {
                const sessionData = getSessionDetails(currentPeriod);
                const contentEl = document.getElementById('details-content');
                if (contentEl) {
                    contentEl.innerHTML = `
                        <div class="grid grid-cols-2 gap-3 text-center">
                            <div class="glass-card p-3 rounded-xl"><p class="text-xs text-gray-400">Séances</p><p class="text-2xl font-bold">${sessionData.total}</p></div>
                            <div class="glass-card p-3 rounded-xl"><p class="text-xs text-gray-400">Fréquence</p><p class="text-lg font-bold">${sessionData.avgPerWeek} <span class="text-xs">/sem</span></p></div>
                        </div>
                        <div class="glass-card p-3 rounded-xl mt-3 text-center">
                            <p class="text-xs text-gray-400">Séance Favorite</p>
                            <p class="font-bold truncate">${sessionData.mostFrequent}</p>
                        </div>
                    `;
                }
                renderChart();
                document.querySelectorAll('#period-filter button').forEach(btn => btn.classList.toggle('btn-primary', btn.dataset.period === currentPeriod));
                document.querySelectorAll('#unit-toggle button').forEach(btn => btn.classList.toggle('btn-primary', btn.dataset.unit === currentUnit));
            };
            
            const modalContent = `
            <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-auto flex flex-col">
                <header class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Analyse des Séances</h2>
                    <button class="close-modal w-8 h-8 rounded-full bg-white/10 flex items-center justify-center">&times;</button>
                </header>
                <div id="period-filter" class="flex justify-between gap-2 mb-4 text-sm">
                    <button data-period="7d" class="flex-1 p-2 rounded-lg glass-card">7j</button>
                    <button data-period="30d" class="flex-1 p-2 rounded-lg glass-card">30j</button>
                    <button data-period="365d" class="flex-1 p-2 rounded-lg glass-card">1a</button>
                    <button data-period="all" class="flex-1 p-2 rounded-lg glass-card">Total</button>
                </div>
                <div id="details-content" class="mb-4"></div>
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-semibold">Répartition par jour</h3>
                    <div id="unit-toggle" class="flex text-xs border border-gray-700 rounded-full p-1">
                        <button data-unit="count" class="px-3 py-1 rounded-full">Nombre</button>
                        <button data-unit="percent" class="px-3 py-1 rounded-full">Pourcent</button>
                    </div>
                </div>
                <div class="h-40"><canvas id="sessions-day-chart"></canvas></div>
            </div>`;

            showModal(modalContent, (modal) => {
                modal.addEventListener('click', e => {
                    const target = e.target.closest('button');
                    if (!target) return;

                    if (target.dataset.period) { 
                        currentPeriod = target.dataset.period; 
                        renderContent(); 
                    }
                    if (target.dataset.unit) { 
                        currentUnit = target.dataset.unit; 
                        renderContent(); 
                    }
                });
                renderContent();
            });
        }

        function showModal(content, setupCallback, closeCallback, isNested = false) {
    const modalWrapper = document.createElement('div');
    modalWrapper.className = 'fixed inset-0 modal-bg flex justify-center items-center p-4 pointer-events-auto animate-fadeIn';
    modalWrapper.innerHTML = content;

    const performClose = () => {
        modalWrapper.classList.add('animate-fadeOut');
        modalWrapper.addEventListener('animationend', () => {
            modalWrapper.remove();
            if (!modalContainer.querySelector('.modal-bg')) {
                modalContainer.classList.add('pointer-events-none');
            }
        }, { once: true });
        
        if (typeof closeCallback === 'function') {
            closeCallback();
        }
    };

    modalWrapper.querySelectorAll('.close-modal, .cancel').forEach(btn => {
        btn.onclick = performClose;
    });
    
    if (!isNested) {
        modalContainer.innerHTML = '';
    }

    modalContainer.appendChild(modalWrapper);
    modalContainer.classList.remove('pointer-events-none');
    
    if (setupCallback) setupCallback(modalWrapper);

    return modalWrapper; 
}


// Remplacez votre fonction closeModal() existante par celle-ci
function closeModal(callback) {
    const lastModal = modalContainer.querySelector('.modal-bg:last-child');
    if (lastModal) {
        lastModal.classList.add('animate-fadeOut');
        lastModal.addEventListener('animationend', () => {
            lastModal.remove();
            if (!modalContainer.querySelector('.modal-bg')) {
                modalContainer.classList.add('pointer-events-none');
            }
            
            // --- CORRECTION APPLIQUÉE ICI ---
            // Si on ferme une modale et que la page en dessous est le classement, on le met à jour.
            // Cela garantit que le rang de l'utilisateur est toujours correct.
            if (state.activePage === 'Leaderboard') {
                renderLeaderboardContent();
            }
            // --- FIN DE LA CORRECTION ---

        }, { once: true });
    }
    if (typeof callback === 'function') {
        callback();
    }
}

function removeFutureRecurrentEvents() {
    const todayStr = formatDateToYYYYMMDD(new Date());
    state.calendarEvents = state.calendarEvents.filter(event => 
        !event.isFromRecurrence || event.date < todayStr
    );
    console.log("Événements récurrents futurs nettoyés.");
}

function getWeek(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return weekNo;
}

// CORRECTION FINALE : Applique le template de récurrence au calendrier.
function applyRecurrenceToCalendar() {
    removeFutureRecurrentEvents();
    const settings = state.recurrence[state.activeSide];
    if (!settings.enabled) return;

    const template = settings.templates[settings.period];
    if (!template || Object.keys(template).length === 0) return;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const daysToPlan = settings.period === 'week' ? 14 : 35;

    for (let i = 0; i < daysToPlan; i++) {
        const targetDate = new Date(today);
        targetDate.setDate(today.getDate() + i);
        const dateStr = formatDateToYYYYMMDD(targetDate);

        const manualEventExists = state.calendarEvents.some(e => e.date === dateStr && !e.isFromRecurrence && e.type === state.activeSide);
        if (manualEventExists) continue;

        let dayKey;
        const dayOfWeek = targetDate.getDay() === 0 ? 6 : targetDate.getDay() - 1; // Lundi=0

        if (settings.period === 'week') {
            dayKey = `day_${dayOfWeek}`;
        } else { // 'month' - LOGIQUE CORRIGÉE
            const weekNumber = getWeek(targetDate);
            const weekInCycle = (weekNumber - 1) % 4; // Cycle de 4 semaines (0, 1, 2, 3)
            const dayIndexInTemplate = (weekInCycle * 7) + dayOfWeek;
            dayKey = `day_${dayIndexInTemplate}`;
        }

        const templateItems = template[dayKey] || [];
        templateItems.forEach(item => {
        const originalItem = (item.type === 'workout' ? state.workouts : state.meals).find(i => i.id === item.refId);
        if (originalItem) {
            state.calendarEvents.push({
                id: generateId(), 
                date: dateStr, 
                refId: item.refId, 
                title: originalItem.name,
                type: item.type, 
                time: item.time, // <-- NOUVEAU
                note: item.note, // <-- NOUVEAU
                isFromRecurrence: true
            });
        }
    });
    }
}

function renderFriendListInModal(friends) {
    const container = document.getElementById('modal-friend-list-container');
    if (!container) return;

    if (friends.length === 0) {
        container.innerHTML = `<p class="text-center text-gray-500 pt-8">Aucun ami trouvé pour cette recherche.</p>`;
        return;
    }

    container.innerHTML = friends.map(friend => renderUnifiedUserCard(friend, 'friend-list')).join('');
}

/**
 * Récupère les données des amis et construit la modale principale.
 */
async function openFriendListModal() {
    closeAllPopovers();
    const sortLabels = {
        'rank_desc': 'Rangs',
        'alpha': 'Alphabétique',
        'since': 'Plus récents'
    };

    const modalContent = `
    <div class="glass-card w-full max-w-sm p-6 rounded-3xl h-[75%] flex flex-col">

        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Liste d'amis</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        <div class="flex gap-2 mb-4 flex-shrink-0">
            <div class="relative flex-1">
                <i class="fa-solid fa-search absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"></i>
                <input id="friend-search-input" type="text" placeholder="Rechercher un ami..." class="input-glass pl-12 w-full">
            </div>
            <div class="relative custom-select-container flex-1">
                <button id="friend-sort-button" class="custom-select-button">
                    <span id="friend-sort-display">${sortLabels[state.friends.sortOrder]}</span>
                    <i class="fa-solid fa-chevron-down text-gray-500"></i>
                </button>
                <div id="friend-sort-options" class="custom-select-options">
                    <div class="custom-select-option" data-value="rank_desc">${sortLabels['rank_desc']}</div>
                    <div class="custom-select-option" data-value="alpha">${sortLabels['alpha']}</div>
                    <div class="custom-select-option" data-value="since">${sortLabels['since']}</div>
                </div>
            </div>
        </div>
        <div id="modal-friend-list-container" class="flex-grow overflow-y-auto pr-2 space-y-3 scrollbar-hide min-h-0">
            <p class="text-center text-gray-400 pt-16">Chargement des amis...</p>
        </div>
    </div>`;

    showModal(modalContent, async (modalWrapper) => {
        // ... Le reste de la logique interne de la fonction reste inchangé ...
        const modalContainer = modalWrapper.querySelector('.glass-card');
        if (modalContainer) {
            modalContainer.style.position = 'relative';
        }

        const friendUids = state.friends.accepted.map(f => f.uid || f);
        const friendPromises = friendUids.map(uid => getDoc(doc(db, 'publicProfiles', uid)));
        const friendDocs = await Promise.all(friendPromises);

        let detailedFriends = friendDocs
        .map(doc => doc.exists() ? {
            ...doc.data(),
            since: state.friends.friendshipTimestamps?.[doc.id] || null
        } : null)
        .filter(Boolean);

        const sortFriends = () => {
            detailedFriends.sort((a, b) => {
                switch (state.friends.sortOrder) {
                    case 'alpha':
                        return a.name.localeCompare(b.name);
                    case 'since':
                        return (b.since?.toDate() || 0) - (a.since?.toDate() || 0);
                    case 'rank_desc':
                    default:
                        const pointsA = RANK_POINTS_MAP[a.globalRank] || 0;
                        const pointsB = RANK_POINTS_MAP[b.globalRank] || 0;
                        return pointsB - pointsA;
                }
            });
        };

        sortFriends();
        renderFriendListInModal(detailedFriends);

        const searchInput = modalWrapper.querySelector('#friend-search-input');
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            const filteredFriends = detailedFriends.filter(f => f.name.toLowerCase().includes(query));
            renderFriendListInModal(filteredFriends);
        });

        const sortButton = modalWrapper.querySelector('#friend-sort-button');
        sortButton.addEventListener('click', (e) => {
            const options = modalWrapper.querySelector('#friend-sort-options');
            closeAllDropdowns();
            options.classList.toggle('active');
            e.stopPropagation();
        });

        const sortOptions = modalWrapper.querySelector('#friend-sort-options');
        sortOptions.addEventListener('click', (e) => {
            const option = e.target.closest('.custom-select-option');
            if (option) {
                state.friends.sortOrder = option.dataset.value;
                sortFriends();
                renderFriendListInModal(detailedFriends);
                sortOptions.classList.remove('active');
                modalWrapper.querySelector('#friend-sort-display').textContent = sortLabels[state.friends.sortOrder];
            }
        });

        modalWrapper.addEventListener('click', e => {
            const optionsBtn = e.target.closest('[data-action="open-friend-options"]');
            if (optionsBtn) {
                openFriendOptionsMenu(optionsBtn.dataset.uid, optionsBtn);
            }
            const confirmRemoveBtn = e.target.closest('[data-action="confirm-remove-friend"]');
            if (confirmRemoveBtn) {
                 closeAllPopovers();
                 const friendId = confirmRemoveBtn.dataset.uid;
                 openRemoveFriendConfirmationModal(friendId, () => openFriendListModal());
            }
        });

        document.addEventListener('click', (e) => {
            if (!modalWrapper.contains(e.target)) {
                closeAllDropdowns();
            }
        });
    });
}

// AJOUTEZ CES NOUVELLES FONCTIONS DANS VOTRE SCRIPT

/**
 * Ouvre la modale principale pour configurer la récurrence.
 */
async function openRecurrenceModal() {
    const settings = state.recurrence[state.activeSide];
    let activeMonthWeek = 0;
    let isStoryScrolling = false;

    const renderWeekSwitcher = () => {
        if (settings.period !== 'month') return '';
        let buttonsHtml = '';
        for (let i = 0; i < 4; i++) {
            buttonsHtml += `<button data-week-index="${i}" class="week-switcher-btn flex-1 p-2 rounded-md text-sm font-semibold ${i === activeMonthWeek ? 'bg-white/10' : 'bg-transparent'}">S.${i + 1}</button>`;
        }
        return `<div class="flex-shrink-0 my-4 p-1 bg-black/20 rounded-lg flex gap-1">${buttonsHtml}</div>`;
    };

    const modalContent = `
    <div class="glass-card w-full max-w-md p-6 rounded-t-3xl border-none h-[85vh] flex flex-col">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-2xl font-bold">Planification Récurrente</h2>
            <button class="close-modal w-8 h-8 rounded-full bg-white/10">&times;</button>
        </header>
        <div class="flex items-center justify-between glass-card p-3 rounded-xl mb-4">
            <label for="recurrence-toggle" class="font-semibold">Activer la récurrence</label>
            <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="recurrence-toggle" class="sr-only peer" ${settings.enabled ? 'checked' : ''}>
                <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
            </label>
        </div>
        <div class="flex-shrink-0 mb-2 p-1 bg-black/20 rounded-lg flex gap-1">
            <button data-period="week" class="period-btn flex-1 p-2 rounded-md font-semibold ${settings.period === 'week' ? 'bg-white/10' : ''}">Semaine</button>
            <button data-period="month" class="period-btn flex-1 p-2 rounded-md font-semibold ${settings.period === 'month' ? 'bg-white/10' : ''}">Mois</button>
        </div>
        <div class="flex-shrink-0">
            <div class="flex justify-between items-center mb-2">
                 <span class="text-sm font-semibold text-gray-400">Glissez vos modèles ici :</span>
                 <div class="flex items-center gap-2">
                    <button id="recurrence-scroll-left-btn" class="w-7 h-7 rounded-md flex items-center justify-center text-gray-400 hover:text-white transition-opacity opacity-0 bg-black/20 backdrop-blur-sm pointer-events-none"><i class="fa-solid fa-chevron-left text-xs"></i></button>
                    <button id="recurrence-scroll-right-btn" class="w-7 h-7 rounded-md flex items-center justify-center text-gray-400 hover:text-white transition-opacity opacity-0 bg-black/20 backdrop-blur-sm pointer-events-none"><i class="fa-solid fa-chevron-right text-xs"></i></button>
                </div>
            </div>
            <div id="recurrence-story-container" class="h-32 flex items-center gap-3 overflow-x-auto scrollbar-hide pr-4" style="scroll-behavior: smooth;">${renderRecurrencePlannerItems()}</div>
        </div>
        <div id="grid-main-container" class="flex-grow flex flex-col min-h-0 pt-3">
            ${renderWeekSwitcher()}
            <div id="recurrence-grid-container" class="flex-grow overflow-y-auto pr-2 scrollbar-hide">${renderRecurrenceGrid()}</div>
        </div>
        <button id="save-recurrence-btn" class="w-full mt-6 btn-primary">Terminé</button>
    </div>`;

    showModal(modalContent, (modalWrapper) => {
        const gridMainContainer = modalWrapper.querySelector('#grid-main-container');
        const updateGrid = () => {
            const currentPeriod = state.recurrence[state.activeSide].period;
            let weekSwitcherHTML = '';
            if (currentPeriod === 'month') {
                weekSwitcherHTML = `
                <div class="flex-shrink-0 my-4 p-1 bg-black/20 rounded-lg flex gap-1">
                    <button data-week-index="0" class="week-switcher-btn flex-1 p-2 rounded-md text-sm font-semibold ${activeMonthWeek === 0 ? 'bg-white/10' : 'bg-transparent'}">S.1</button>
                    <button data-week-index="1" class="week-switcher-btn flex-1 p-2 rounded-md text-sm font-semibold ${activeMonthWeek === 1 ? 'bg-white/10' : 'bg-transparent'}">S.2</button>
                    <button data-week-index="2" class="week-switcher-btn flex-1 p-2 rounded-md text-sm font-semibold ${activeMonthWeek === 2 ? 'bg-white/10' : 'bg-transparent'}">S.3</button>
                    <button data-week-index="3" class="week-switcher-btn flex-1 p-2 rounded-md text-sm font-semibold ${activeMonthWeek === 3 ? 'bg-white/10' : 'bg-transparent'}">S.4</button>
                </div>`;
            }
            gridMainContainer.innerHTML = `${weekSwitcherHTML}<div id="recurrence-grid-container" class="flex-grow overflow-y-auto pr-2 scrollbar-hide">${renderRecurrenceGrid()}</div>`;
            setupRecurrenceDragAndDrop(modalWrapper);
        };
        const scrollAssets = (direction) => {
            if (isStoryScrolling) return;
            isStoryScrolling = true;
            const container = modalWrapper.querySelector('#recurrence-story-container');
            const firstAsset = container.querySelector('.recurrence-draggable');
            if (!firstAsset) { isStoryScrolling = false; return; }
            const assetWidthWithGap = firstAsset.offsetWidth + 12;
            const itemsToScroll = Math.max(1, Math.floor(container.clientWidth / assetWidthWithGap));
            container.scrollLeft += (itemsToScroll * assetWidthWithGap) * direction;
            setTimeout(() => { isStoryScrolling = false; }, 400);
        };
        modalWrapper.querySelector('#recurrence-scroll-left-btn').onclick = () => scrollAssets(-1);
        modalWrapper.querySelector('#recurrence-scroll-right-btn').onclick = () => scrollAssets(1);
        modalWrapper.querySelector('#recurrence-toggle').addEventListener('change', (e) => { settings.enabled = e.target.checked; });
        modalWrapper.querySelector('#save-recurrence-btn').addEventListener('click', async () => { // <-- 1. AJOUT DE ASYNC
    if (settings.enabled) { 
        applyRecurrenceToCalendar(); 
    } else { 
        removeFutureRecurrentEvents(); 
    }

    await saveState(); // <-- Maintenant, c'est valide
    
    closeModal(); 
    render();
});
        modalWrapper.addEventListener('click', e => {
            const periodBtn = e.target.closest('.period-btn');
            if (periodBtn) {
                settings.period = periodBtn.dataset.period;
                activeMonthWeek = 0;
                modalWrapper.querySelectorAll('.period-btn').forEach(btn => btn.classList.remove('bg-white/10'));
                periodBtn.classList.add('bg-white/10');
                updateGrid();
            }
            const weekBtn = e.target.closest('.week-switcher-btn');
            if (weekBtn) {
                activeMonthWeek = parseInt(weekBtn.dataset.weekIndex);
                modalWrapper.querySelectorAll('.week-switcher-btn').forEach(btn => btn.classList.remove('bg-white/10'));
                weekBtn.classList.add('bg-white/10');
                updateGrid();
            }
            const removeBtn = e.target.closest('.remove-item-from-template');
            if (removeBtn) {
                const dayKey = removeBtn.dataset.dayKey;
                const refId = removeBtn.dataset.refId;
                const template = settings.templates[settings.period];
                if (template && template[dayKey]) {
                    template[dayKey] = template[dayKey].filter(item => item.refId !== refId);
                    if (template[dayKey].length === 0) delete template[dayKey];
                    updateGrid();
                }
            }
        });
        setupRecurrenceDragAndDrop(modalWrapper);
    });
}

// CORRECTION FINALE : Affiche la grille.
function renderRecurrenceGrid() {
    const { period, templates } = state.recurrence[state.activeSide];
    const template = templates[period] || {};
    const dayLabels = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
    const activeMonthWeek = document.querySelector('.week-switcher-btn.bg-white\\/10')?.dataset.weekIndex || 0;
    let gridHtml = `<div class="grid grid-cols-1 gap-3">`;
    const daysToShow = 7;
    const dayOffset = period === 'month' ? parseInt(activeMonthWeek) * 7 : 0;

    for (let i = 0; i < daysToShow; i++) {
        const dayIndex = dayOffset + i;
        const dayKey = `day_${dayIndex}`;
        const itemsOnDay = template[dayKey] || [];
        let dayLabel = dayLabels[i];
        if (period === 'month') {
            dayLabel += ` (S.${parseInt(activeMonthWeek) + 1})`;
        }
        const itemsHtml = itemsOnDay.map(item => {
            const originalItem = (item.type === 'workout' ? state.workouts : state.meals).find(w => w.id === item.refId);
            return `<div class="bg-gray-800 p-2 rounded-md text-sm flex justify-between items-center"><span class="truncate pr-2">${item.time} - ${originalItem ? originalItem.name : 'Élément introuvable'}</span><button class="remove-item-from-template text-red-400 hover:text-red-300 w-5 h-5 flex-shrink-0" data-day-key="${dayKey}" data-ref-id="${item.refId}">&times;</button></div>`;
        }).join('');
        gridHtml += `<div class="recurrence-day-dropzone bg-black/20 rounded-lg p-3 min-h-[90px]" data-day-key="${dayKey}"><p class="font-bold text-gray-300 text-sm mb-2">${dayLabel}</p><div class="space-y-2">${itemsHtml}</div></div>`;
    }
    gridHtml += `</div>`;
    return gridHtml;
}

// CORRECTION FINALE : Affiche les modèles.
function renderRecurrencePlannerItems() {
    const items = state.activeSide === 'workout' 
        ? state.workouts.map(w => ({...w, itemType: 'workout'}))
        : state.meals.filter(m => !m.isQuickAdd).map(m => ({...m, itemType: 'meal'}));
    if (items.length === 0) return `<p class="text-sm text-gray-500 w-full text-center">Créez d'abord des modèles.</p>`;
    return items.map(item => {
        const icon = item.itemType === 'workout' ? 'fa-dumbbell' : 'fa-utensils';
        const tagId = item.tags && item.tags[0];
        const tagList = item.itemType === 'workout' ? state.workoutTags : state.mealTags;
        const tag = tagId ? tagList.find(t => t.id === tagId) : null;
        return `<div class="recurrence-draggable flex-shrink-0 w-48 glass-card p-3 rounded-xl flex items-center gap-3 cursor-grab" draggable="true" data-item-id="${item.id}" data-item-type="${item.itemType}"><i class="fa-solid ${icon} text-2xl text-gray-400 w-8 text-center"></i><div class="flex-grow min-w-0 h-10 flex flex-col justify-center"><p class="text-sm font-semibold truncate">${item.name}</p>${tag ? `<span class="text-xs font-bold px-2 py-0.5 rounded-full mt-1 inline-block" style="background-color:${tag.color}30; color:${tag.color};">${tag.name}</span>` : ''}</div></div>`;
    }).join('');
}

// CORRECTION FINALE : Gère le Drag & Drop et la visibilité des flèches.
function setupRecurrenceDragAndDrop(modalWrapper) {
    const storyContainer = modalWrapper.querySelector('#recurrence-story-container');
    const scrollLeftBtn = modalWrapper.querySelector('#recurrence-scroll-left-btn');
    const scrollRightBtn = modalWrapper.querySelector('#recurrence-scroll-right-btn');
    let scrollObserver;

    const updateLeftButton = () => {
        if (!storyContainer) return;
        const canScrollLeft = storyContainer.scrollLeft > 5;
        scrollLeftBtn.style.opacity = canScrollLeft ? '1' : '0';
        scrollLeftBtn.style.pointerEvents = canScrollLeft ? 'auto' : 'none';
    };

    if (storyContainer) {
        if (scrollObserver) scrollObserver.disconnect();
        storyContainer.addEventListener('scroll', updateLeftButton, { passive: true });
        const lastAsset = storyContainer.querySelector('.recurrence-draggable:last-child');
        if (lastAsset) {
            scrollObserver = new IntersectionObserver((entries) => {
                const isVisible = entries[0].isIntersecting;
                scrollRightBtn.style.opacity = isVisible ? '0' : '1';
                scrollRightBtn.style.pointerEvents = isVisible ? 'none' : 'auto';
            }, { root: storyContainer, threshold: 0.95 });
            scrollObserver.observe(lastAsset);
        } else {
            scrollRightBtn.style.opacity = '0';
            scrollRightBtn.style.pointerEvents = 'none';
        }
        setTimeout(updateLeftButton, 100);
    }
    
    modalWrapper.querySelectorAll('.recurrence-draggable').forEach(el => {
        el.ondragstart = e => { e.dataTransfer.setData('text/plain', `${el.dataset.itemId},${el.dataset.itemType}`); setTimeout(() => el.classList.add('dragging'), 0); };
        el.ondragend = e => el.classList.remove('dragging');
    });

    modalWrapper.querySelectorAll('.recurrence-day-dropzone').forEach(day => {
        day.ondragover = e => { e.preventDefault(); day.style.backgroundColor = 'rgba(167, 139, 250, 0.2)'; };
        day.ondragleave = e => { day.style.backgroundColor = ''; };
        day.ondrop = e => {
            e.preventDefault();
            day.style.backgroundColor = '';
            const [refId, type] = e.dataTransfer.getData('text/plain').split(',');
            const dayKey = day.dataset.dayKey;
            
            // Appelle la modale de planification pour la récurrence
            if (refId && type && dayKey) {
                openPlanModalForRecurrence(refId, dayKey, type, modalWrapper);
            }
        };
    });
}

function openPlanModalForRecurrence(itemId, dayKey, type, recurrenceModalWrapper) {
    const item = type === 'workout' ? state.workouts.find(i => i.id === itemId) : state.meals.find(i => i.id === itemId);
    if (!item) return;

    const modalContent = `<div class="glass-card p-6 rounded-3xl w-full max-w-sm"><h2 class="text-xl font-bold mb-2">Planifier: ${item.name}</h2><p class="text-gray-400 mb-6">Pour le modèle de récurrence</p><div class="space-y-4"><div><label class="text-sm text-gray-400">Heure</label><input id="plan-time-input" type="time" class="input-glass" value="12:00"></div><div><label class="text-sm text-gray-400">Note (optionnel)</label><input id="plan-note-input" type="text" class="input-glass" placeholder="Ex: Focus sur la technique"></div></div><div class="flex gap-4 mt-8"><button class="cancel w-full glass-card p-3 rounded-lg font-bold">Annuler</button><button id="confirm-plan-recurrence" class="w-full btn-primary">Planifier</button></div></div>`;
    
    showModal(modalContent, (modalWrapper) => {
        modalWrapper.querySelector('#confirm-plan-recurrence').onclick = () => {
            const time = modalWrapper.querySelector('#plan-time-input').value;
            const note = modalWrapper.querySelector('#plan-note-input').value;

            const settings = state.recurrence[state.activeSide];
            const template = settings.templates[settings.period];
            if (!template[dayKey]) template[dayKey] = [];
            
            template[dayKey].push({ refId: itemId, type, time, note });
            
            // Fermer uniquement la modale de planification sans affecter la modale parente
            closeModal();
            
            // Mettre à jour le contenu de la grille de récurrence pour afficher le nouvel élément
            const gridContainer = recurrenceModalWrapper.querySelector('#recurrence-grid-container');
            if (gridContainer) {
                gridContainer.innerHTML = renderRecurrenceGrid();
                setupRecurrenceDragAndDrop(recurrenceModalWrapper);
            }
        };

        // Gérer le bouton 'Annuler' de la même manière
        modalWrapper.querySelector('.cancel').onclick = () => {
            closeModal();
        };
    }, () => {}, true); // Le dernier paramètre 'true' est la clé du changement !
}
        
        // --- INITIAL RENDER ---
        function startMyApplication() {
    if (!app) {
        app = initializeApp(firebaseConfig); 
        auth = getAuth(app);
        db = getFirestore(app);
        console.log("Firebase a été initialisé.");
    }

    onAuthStateChanged(auth, async (user) => {
    if (user) {
        // --- L'UTILISATEUR EST CONNECTÉ ---
        currentUserId = user.uid;
        console.log("Utilisateur connecté :", currentUserId);

        // On nettoie les anciens écouteurs pour éviter les bugs et les fuites de mémoire
        if (userProfileListener) userProfileListener();
        if (clanListener) clanListener();
        if (inboxListener) inboxListener();

        // Écouteur principal pour les données privées de l'utilisateur (profil, séances, etc.)
        const userProfileRef = doc(db, 'users', user.uid);
        userProfileListener = onSnapshot(userProfileRef, async (docSnapshot) => { // <-- Ajout de 'async' ici
    if (docSnapshot.exists()) {
        const firebaseData = docSnapshot.data();

let userNeedsUpdate = false;
        const updatesForUser = {};
        const updatesForPublicProfile = {};

        // On vérifie si les nouveaux champs SBD manquent
        if (!firebaseData.userProfile.sbd_ranks) {
            updatesForUser['userProfile.sbd_ranks'] = {
                squat: { best_1rm: 0, rank: "Non classé" },
                bench: { best_1rm: 0, rank: "Non classé" },
                deadlift: { best_1rm: 0, rank: "Non classé" },
                total: 0
            };
            // On ajoute aussi au profil public
            updatesForPublicProfile['sbd_ranks'] = updatesForUser['userProfile.sbd_ranks'];
            userNeedsUpdate = true;
        }

        // On vérifie si les champs de juge manquent
        if (typeof firebaseData.userProfile.judgeStatus === 'undefined') {
            updatesForUser['userProfile.judgeStatus'] = 'none';
            updatesForPublicProfile['judgeStatus'] = 'none';
            userNeedsUpdate = true;
        }
        if (typeof firebaseData.userProfile.judgeHonorScore === 'undefined') {
            updatesForUser['userProfile.judgeHonorScore'] = 100;
            updatesForPublicProfile['judgeHonorScore'] = 100;
            userNeedsUpdate = true;
        }

        // Si une mise à jour est nécessaire, on l'exécute une bonne fois pour toutes
        if (userNeedsUpdate) {
            console.log(`Migration du profil de l'utilisateur ${currentUserId}...`);
            const userRef = doc(db, 'users', currentUserId);
            const publicProfileRef = doc(db, 'publicProfiles', currentUserId);
            
            await Promise.all([
                updateDoc(userRef, updatesForUser),
                updateDoc(publicProfileRef, updatesForPublicProfile)
            ]);
            console.log("Profil migré avec succès !");
        }

        state = deepMerge(state, firebaseData);
        
        console.log("Données utilisateur mises à jour depuis Firebase.");

        // --- DÉBUT DE LA CORRECTION DÉFINITIVE ---
        let needsPublicProfileUpdate = false;

        // 1. On vérifie et charge les données de l'équipe (clan)
        const clanId = state.userProfile.clanId;
        if (clanId && (!state.currentClanData || state.currentClanData.id !== clanId)) {
            const clanDoc = await getDoc(doc(db, 'clans', clanId));
            if (clanDoc.exists()) {
                state.currentClanData = { id: clanDoc.id, ...clanDoc.data() };
                console.log("Données de l'équipe chargées :", state.currentClanData.name);
                needsPublicProfileUpdate = true; // On signale qu'une mise à jour est nécessaire
            }
        } else if (!clanId) {
            state.currentClanData = null; // Nettoyage si l'utilisateur n'a plus d'équipe
        }

        // 2. On vérifie et charge les données de la salle (gym)
        const gymId = state.userProfile.gymId;
        if (gymId && (!state.currentGymData || state.currentGymData.id !== gymId)) {
            const gymDoc = await getDoc(doc(db, 'gyms', gymId));
            if (gymDoc.exists()) {
                state.currentGymData = { id: gymDoc.id, ...gymDoc.data() };
                console.log("Données de la salle chargées :", state.currentGymData.name);
                needsPublicProfileUpdate = true; // On signale qu'une mise à jour est nécessaire
            }
        } else if (!gymId) {
            state.currentGymData = null; // Nettoyage si l'utilisateur n'a plus de salle
        }

        // 3. Si des noms ont été chargés, on force la sauvegarde du profil public
        if (needsPublicProfileUpdate) {
            console.log("Mise à jour du profil public forcée au démarrage.");
            await saveState(); 
        }
        // --- FIN DE LA CORRECTION DÉFINITIVE ---

        // Le reste de votre code (quêtes, séries, navigation, etc.) reste ici
        checkAndResetQuests();
        updateStreaks();
        updateSocialNotificationBadge();

        if (state.activePage === 'Login' || state.activePage === 'Onboarding') {
            navigate('Accueil');
        } else if (!state.isAnimating) {
            render();
        }

    } else {
        console.log("Nouvel utilisateur, redirection vers l'onboarding.");
        state.showOnboardingForm = true;
        navigate('Onboarding');
    }
});

        // Écouteur pour la boîte de réception (messages, demandes d'amis)
        const inboxQuery = query(collection(db, 'inboxMessages'), where('recipientUid', '==', user.uid));
        inboxListener = onSnapshot(inboxQuery, (snapshot) => {
            const unreadMessages = [];
            snapshot.forEach(doc => {
                unreadMessages.push({ id: doc.id, ...doc.data() });
            });

            // CORRECTION : Trie les messages pour que les plus récents soient en premier.
            unreadMessages.sort((a, b) => {
                const dateA = a.timestamp?.toDate() || 0;
                const dateB = b.timestamp?.toDate() || 0;
                return dateB - dateA;
            });

            state.inbox = { unreadMessages };
            updateSocialNotificationBadge();
        });

    } else {
        // --- L'UTILISATEUR EST DÉCONNECTÉ ---
        currentUserId = null;
        console.log("Utilisateur déconnecté.");

        // On nettoie tous les écouteurs
        if (userProfileListener) { userProfileListener(); userProfileListener = null; }
        if (clanListener) { clanListener(); clanListener = null; }
        if (inboxListener) { inboxListener(); inboxListener = null; }

        // On réinitialise l'état de l'application et on redirige vers la page de connexion
        state = getInitialState();
        navigate('Login');
    }
    
    isFirebaseReady = true;
    render();
});

    checkAndResetQuests();
    updateStreaks();
}
        
        startMyApplication();

    </script>
</body>
</html>
